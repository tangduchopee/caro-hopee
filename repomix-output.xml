This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  src/
    config/
      database.ts
      socket.io.ts
    controllers/
      authController.ts
      gameController.ts
      gameStatsController.ts
      leaderboardController.ts
      userController.ts
    middleware/
      authMiddleware.ts
      errorHandler.ts
      rateLimiter.ts
      validateScore.ts
    models/
      Game.ts
      GameHistory.ts
      GameMove.ts
      GameSession.ts
      GameStats.ts
      GameType.ts
      Leaderboard.ts
      User.ts
    routes/
      authRoutes.ts
      gameRoutes.ts
      gameStatsRoutes.ts
      leaderboardRoutes.ts
      userRoutes.ts
    scripts/
      initGameTypes.ts
      migrateUserStats.ts
    services/
      antiCheatService.ts
      gameEngine.ts
      ruleEngine.ts
      socketService.ts
      winChecker.ts
    types/
      game.types.ts
    utils/
      jwt.ts
    server.ts
  .gitignore
  package.json
  tsconfig.json
frontend/
  public/
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt
  src/
    components/
      GameBoard/
        GameBoard.tsx
        GameCell.tsx
      GameCard/
        GameCard.tsx
      GameControls/
        GameControls.tsx
      GameInfo/
        GameInfo.tsx
      HistoryModal/
        HistoryModal.tsx
      RoomCodeDisplay.tsx
    contexts/
      AuthContext.tsx
      GameContext.tsx
      SocketContext.tsx
    pages/
      GameRoomPage.tsx
      HomePage.tsx
      JoinGamePage.tsx
      LeaderboardPage.tsx
      LoginPage.tsx
      ProfilePage.tsx
    services/
      api.ts
      socketService.ts
    types/
      game.types.ts
      socket.types.ts
      user.types.ts
    utils/
      constants.ts
      guestHistory.ts
      guestId.ts
      logger.ts
      roomCode.ts
      winChecker.ts
    App.css
    App.test.tsx
    App.tsx
    index.css
    index.tsx
    logo.svg
    react-app-env.d.ts
    reportWebVitals.ts
    setupTests.ts
  .gitignore
  package.json
  README.md
  tsconfig.json
.gitignore
GAME_FEATURES_AND_LOGIC.md
MIGRATION_GUIDE.md
README.md
SYSTEM_ARCHITECTURE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/components/GameCard/GameCard.tsx">
import React, { memo } from 'react';
import { Paper, Box, Typography, Chip, Button, CircularProgress, Fade } from '@mui/material';

interface WaitingGame {
  _id: string;
  roomId: string;
  roomCode: string;
  boardSize: number;
  gameStatus: string;
  displayStatus?: 'waiting' | 'ready' | 'playing';
  statusLabel?: string;
  canJoin?: boolean;
  hasPlayer1: boolean;
  hasPlayer2: boolean;
  playerCount?: number;
  player1Username: string | null;
  createdAt: string;
}

interface GameCardProps {
  game: WaitingGame;
  isNewGame: boolean;
  joiningGameId: string | null;
  onJoin: (game: WaitingGame) => void;
}

const GameCard: React.FC<GameCardProps> = memo(({ game, isNewGame, joiningGameId, onJoin }) => {
  const handleClick = (): void => {
    if (game.canJoin !== false) {
      onJoin(game);
    }
  };

  const handleButtonClick = (e: React.MouseEvent): void => {
    e.stopPropagation();
    onJoin(game);
  };

  return (
    <Fade in timeout={isNewGame ? 400 : 0}>
      <Paper
        elevation={0}
        sx={{
          p: 3,
          bgcolor: 'rgba(255, 255, 255, 0.8)',
          backdropFilter: 'blur(8px)',
          WebkitBackdropFilter: 'blur(8px)',
          willChange: 'transform',
          border: '1px solid rgba(126, 200, 227, 0.2)',
          borderRadius: 3,
          boxShadow: '0 4px 16px rgba(126, 200, 227, 0.1)',
          transition: 'all 0.3s ease',
          cursor: game.canJoin === false ? 'not-allowed' : 'pointer',
          opacity: game.canJoin === false ? 0.7 : 1,
          '&:hover': game.canJoin === false ? {} : {
            boxShadow: '0 8px 24px rgba(126, 200, 227, 0.2)',
            transform: 'translateY(-4px)',
            borderColor: 'rgba(126, 200, 227, 0.4)',
          },
        }}
        onClick={handleClick}
      >
        <Box sx={{ mb: 2.5 }}>
          <Typography
            variant="h5"
            sx={{
              fontFamily: 'monospace',
              fontWeight: 800,
              letterSpacing: 2,
              background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              backgroundClip: 'text',
              fontSize: '1.75rem',
              mb: 1.5,
            }}
          >
            {game.roomCode}
          </Typography>
          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', mb: 1.5 }}>
            <Chip
              label={`${game.boardSize}x${game.boardSize}`}
              size="small"
              sx={{
                bgcolor: 'rgba(126, 200, 227, 0.15)',
                color: '#7ec8e3',
                fontWeight: 600,
                fontSize: '0.75rem',
                height: 24,
              }}
            />
            <Chip
              label={game.statusLabel || (game.hasPlayer1 && !game.hasPlayer2 ? '1/2 Players' : 'Waiting')}
              size="small"
              sx={{
                bgcolor: 
                  game.displayStatus === 'playing' 
                    ? 'rgba(255, 152, 0, 0.2)'
                    : game.displayStatus === 'ready'
                    ? 'rgba(76, 175, 80, 0.2)'
                    : 'rgba(33, 150, 243, 0.2)',
                color: 
                  game.displayStatus === 'playing'
                    ? '#ff9800'
                    : game.displayStatus === 'ready'
                    ? '#4caf50'
                    : '#2196f3',
                fontWeight: 700,
                fontSize: '0.75rem',
                height: 24,
                border: 
                  game.displayStatus === 'playing'
                    ? '1px solid rgba(255, 152, 0, 0.3)'
                    : game.displayStatus === 'ready'
                    ? '1px solid rgba(76, 175, 80, 0.3)'
                    : '1px solid rgba(33, 150, 243, 0.3)',
              }}
            />
          </Box>
          {game.player1Username && (
            <Typography variant="caption" sx={{ color: '#5a6a7a', fontSize: '0.8rem' }}>
              Host: {game.player1Username}
            </Typography>
          )}
        </Box>
        <Button
          variant="contained"
          fullWidth
          disabled={joiningGameId === game.roomId || game.canJoin === false}
          onClick={handleButtonClick}
          sx={{
            py: 1.25,
            borderRadius: 2.5,
            textTransform: 'none',
            fontWeight: 600,
            fontSize: '0.9rem',
            background: game.canJoin === false 
              ? 'linear-gradient(135deg, #9e9e9e 0%, #757575 100%)'
              : 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            boxShadow: game.canJoin === false
              ? 'none'
              : '0 4px 12px rgba(126, 200, 227, 0.3)',
            '&:hover': game.canJoin === false ? {} : {
              background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
              boxShadow: '0 6px 16px rgba(126, 200, 227, 0.4)',
            },
          }}
        >
          {joiningGameId === game.roomId ? (
            <>
              <CircularProgress size={16} sx={{ mr: 1, color: '#ffffff' }} />
              Joining...
            </>
          ) : game.canJoin === false ? (
            game.displayStatus === 'playing' ? 'Playing...' : 'Full (2/2)'
          ) : (
            'Join Game'
          )}
        </Button>
      </Paper>
    </Fade>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function for memo
  return (
    prevProps.game.roomId === nextProps.game.roomId &&
    prevProps.game.displayStatus === nextProps.game.displayStatus &&
    prevProps.game.canJoin === nextProps.game.canJoin &&
    prevProps.game.statusLabel === nextProps.game.statusLabel &&
    prevProps.joiningGameId === nextProps.joiningGameId &&
    prevProps.isNewGame === nextProps.isNewGame
  );
});

GameCard.displayName = 'GameCard';

export default GameCard;
export type { WaitingGame };
</file>

<file path="frontend/src/utils/guestHistory.ts">
import { GameHistory } from '../types/game.types';
import { logger } from './logger';

const GUEST_HISTORY_KEY = 'caro_guest_history';
const MAX_GUEST_HISTORY = 20;

/**
 * Save game history to localStorage for guest users
 * Only keeps the last 20 games
 */
export const saveGuestHistory = (game: {
  roomId: string;
  roomCode: string;
  boardSize: number;
  board: number[][];
  winner: 1 | 2 | null | 'draw';
  winningLine?: Array<{ row: number; col: number }>;
  score: { player1: number; player2: number };
  finishedAt: string | null;
  createdAt: string;
  myPlayerNumber: 1 | 2;
  opponentUsername: string;
  result: 'win' | 'loss' | 'draw';
}): void => {
  try {
    // Get existing history
    const existingHistory = getGuestHistory();
    
    // Create history entry
    const historyEntry: GameHistory = {
      _id: `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      roomId: game.roomId,
      roomCode: game.roomCode,
      boardSize: game.boardSize,
      board: game.board,
      winner: game.winner,
      winningLine: game.winningLine,
      result: game.result,
      opponentUsername: game.opponentUsername,
      finishedAt: game.finishedAt,
      createdAt: game.createdAt,
      score: game.score,
    };
    
    // Add new entry at the beginning
    const updatedHistory = [historyEntry, ...existingHistory];
    
    // Keep only last 20 games
    const trimmedHistory = updatedHistory.slice(0, MAX_GUEST_HISTORY);
    
    // Save to localStorage
    localStorage.setItem(GUEST_HISTORY_KEY, JSON.stringify(trimmedHistory));
    
    logger.log('[guestHistory] Saved game to guest history:', historyEntry.roomCode);
  } catch (error) {
    logger.error('[guestHistory] Failed to save guest history:', error);
    // Don't throw - localStorage might not be available
  }
};

/**
 * Get game history from localStorage for guest users
 */
export const getGuestHistory = (): GameHistory[] => {
  try {
    const historyJson = localStorage.getItem(GUEST_HISTORY_KEY);
    if (!historyJson) {
      return [];
    }
    
    const history = JSON.parse(historyJson) as GameHistory[];
    // Validate and filter out invalid entries
    return history.filter(h => h && h.roomId && h.board);
  } catch (error) {
    logger.error('[guestHistory] Failed to read guest history:', error);
    return [];
  }
};

/**
 * Clear guest history from localStorage
 */
export const clearGuestHistory = (): void => {
  try {
    localStorage.removeItem(GUEST_HISTORY_KEY);
    logger.log('[guestHistory] Cleared guest history');
  } catch (error) {
    logger.error('[guestHistory] Failed to clear guest history:', error);
  }
};
</file>

<file path="frontend/src/utils/logger.ts">
/**
 * Logger utility - Disables console logs in production for better performance
 */
const isDevelopment = process.env.NODE_ENV === 'development';

export const logger = {
  log: (...args: any[]): void => {
    if (isDevelopment) {
      console.log(...args);
    }
  },
  error: (...args: any[]): void => {
    // Always log errors, even in production
    console.error(...args);
  },
  warn: (...args: any[]): void => {
    if (isDevelopment) {
      console.warn(...args);
    }
  },
  info: (...args: any[]): void => {
    if (isDevelopment) {
      console.info(...args);
    }
  },
  debug: (...args: any[]): void => {
    if (isDevelopment) {
      console.debug(...args);
    }
  },
};
</file>

<file path="GAME_FEATURES_AND_LOGIC.md">
# Mini Game Caro - T√†i Li·ªáu Ch·ª©c NƒÉng v√† Logic

## üìã M·ª•c L·ª•c
1. [T·ªïng Quan](#t·ªïng-quan)
2. [Tr·∫°ng Th√°i Game](#tr·∫°ng-th√°i-game)
3. [T·∫°o v√† Tham Gia Game](#t·∫°o-v√†-tham-gia-game)
4. [B·∫Øt ƒê·∫ßu Game](#b·∫Øt-ƒë·∫ßu-game)
5. [Lu·∫≠t Ch∆°i](#lu·∫≠t-ch∆°i)
6. [ƒêi·ªÅu Khi·ªÉn Game](#ƒëi·ªÅu-khi·ªÉn-game)
7. [R·ªùi Game v√† Qu·∫£n L√Ω Host](#r·ªùi-game-v√†-qu·∫£n-l√Ω-host)
8. [L·ªãch S·ª≠ Game](#l·ªãch-s·ª≠-game)
9. [Real-time Updates](#real-time-updates)
10. [X√°c Th·ª±c v√† Guest](#x√°c-th·ª±c-v√†-guest)

---

## üéÆ T·ªïng Quan

Mini Game Caro l√† m·ªôt game c·ªù caro online multiplayer v·ªõi c√°c t√≠nh nƒÉng:
- **Multiplayer Real-time**: 2 ng∆∞·ªùi ch∆°i c√πng l√∫c
- **Guest Mode**: Ch∆°i kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p
- **Authenticated Mode**: Ch∆°i v·ªõi t√†i kho·∫£n, l∆∞u l·ªãch s·ª≠ vƒ©nh vi·ªÖn
- **Multiple Board Sizes**: 3x3, 15x15, 19x19, 20x20
- **Game Rules**: Block Two Ends, Undo, Time Limit
- **Game History**: Xem l·∫°i c√°c v√°n ƒë√£ ch∆°i
- **Winning Line Visualization**: Hi·ªÉn th·ªã ƒë∆∞·ªùng k·∫ª chi·∫øn th·∫Øng, v√† n∆∞·ªõc ƒëi g·∫ßn nh·∫•t

---

## üìä Tr·∫°ng Th√°i Game

### L∆∞u √Ω v·ªÅ Tr·∫°ng Th√°i

**Tr·∫°ng th√°i trong Database (`gameStatus`)**:
- `waiting`: Ch·ªù ng∆∞·ªùi ch∆°i (c√≥ th·ªÉ 1 ho·∫∑c 2 ng∆∞·ªùi)
- `playing`: ƒêang ch∆°i
- `finished`: ƒê√£ k·∫øt th√∫c

**Tr·∫°ng th√°i hi·ªÉn th·ªã trong UI (`displayStatus`)**:
- `waiting`: Ch·ªâ c√≥ 1 ng∆∞·ªùi ch∆°i (1/2)
- `ready`: C√≥ ƒë·ªß 2 ng∆∞·ªùi ch∆°i nh∆∞ng ch∆∞a b·∫Øt ƒë·∫ßu (2/2, ch∆∞a start)
- `playing`: ƒêang ch∆°i (2/2, ƒë√£ start)

**S·ª± kh√°c bi·ªát**:
- Trong DB, khi c√≥ 2 ng∆∞·ªùi nh∆∞ng ch∆∞a start ‚Üí V·∫´n l√† `waiting`
- Trong UI, khi c√≥ 2 ng∆∞·ªùi nh∆∞ng ch∆∞a start ‚Üí Hi·ªÉn th·ªã l√† `ready`
- Logic x·ª≠ l√Ω d·ª±a tr√™n `gameStatus` (DB) v√† `playerCount` ƒë·ªÉ x√°c ƒë·ªãnh `displayStatus` (UI)

---

### Chi Ti·∫øt C√°c Tr·∫°ng Th√°i

#### 1. `waiting` - ƒêang ch·ªù ng∆∞·ªùi ch∆°i th·ª© 2 (1/2 players)

**Trong Database**: `gameStatus = 'waiting'`  
**Trong UI**: `displayStatus = 'waiting'`

- **M√¥ t·∫£**: Game ƒë√£ ƒë∆∞·ª£c t·∫°o nh∆∞ng ch·ªâ c√≥ 1 ng∆∞·ªùi ch∆°i (host)
- **ƒêi·ªÅu ki·ªán**: 
  - Ch·ªâ c√≥ player1 (host)
  - Ch∆∞a c√≥ player2
  - `playerCount = 1`
- **UI**: 
  - Hi·ªÉn th·ªã "Waiting for players..." message
  - Kh√¥ng hi·ªÉn th·ªã b√†n c·ªù
  - Kh√¥ng hi·ªÉn th·ªã Start button
- **H√†nh ƒë·ªông cho ph√©p**: 
  - ‚úÖ Join game (cho ng∆∞·ªùi ch∆°i kh√°c)
  - ‚ùå Start game (ch∆∞a ƒë·ªß 2 ng∆∞·ªùi)
- **Logic x·ª≠ l√Ω**: 
  - Game hi·ªÉn th·ªã trong lobby v·ªõi status "Waiting (1/2)"
  - `canJoin = true` (c√≥ th·ªÉ join)
  - Kh√¥ng th·ªÉ start
  - Sau khi c√≥ ng∆∞·ªùi join ‚Üí Chuy·ªÉn sang tr·∫°ng th√°i `ready` (2/2, ch∆∞a start)

**L∆∞u √Ω**: 
- Khi `playerCount = 1` ‚Üí `gameStatus = 'waiting'`, `displayStatus = 'waiting'` (1/2)
- Khi `playerCount = 2` v√† ch∆∞a start ‚Üí `gameStatus = 'waiting'`, `displayStatus = 'ready'` (2/2)
- Khi ƒë√£ start ‚Üí `gameStatus = 'playing'`, `displayStatus = 'playing'`

### 2. `playing` - ƒêang ch∆°i
- **M√¥ t·∫£**: Game ƒë√£ b·∫Øt ƒë·∫ßu, 2 ng∆∞·ªùi ch∆°i ƒëang ƒë√°nh
- **ƒêi·ªÅu ki·ªán**: 
  - C√≥ ƒë·ªß 2 ng∆∞·ªùi ch∆°i
  - ƒê√£ click "Start Game"
  - `gameStatus = 'playing'`
- **UI**: Hi·ªÉn th·ªã b√†n c·ªù ƒë·∫ßy ƒë·ªß, n√∫t ƒëi·ªÅu khi·ªÉn, game info
- **H√†nh ƒë·ªông cho ph√©p**: 
  - ‚úÖ Make move (theo l∆∞·ª£t)
  - ‚úÖ Request undo (n·∫øu ƒë·ªß ƒëi·ªÅu ki·ªán)
  - ‚úÖ Surrender
  - ‚ùå Join game (ƒë√£ ƒë·ªß 2 ng∆∞·ªùi v√† ƒëang ch∆°i)
  - ‚ùå Start game (ƒë√£ b·∫Øt ƒë·∫ßu r·ªìi)
- **Logic x·ª≠ l√Ω**: 
  - Game hi·ªÉn th·ªã trong lobby v·ªõi status "Playing"
  - Kh√¥ng th·ªÉ join
  - C√≥ th·ªÉ ƒë√°nh c·ªù, undo, surrender

#### 4. `finished` - ƒê√£ k·∫øt th√∫c

**Trong Database**: `gameStatus = 'finished'`  
**Trong UI**: `displayStatus = 'finished'` (kh√¥ng hi·ªÉn th·ªã trong lobby)
- **M√¥ t·∫£**: Game ƒë√£ k·∫øt th√∫c (c√≥ ng∆∞·ªùi th·∫Øng ho·∫∑c h√≤a)
- **ƒêi·ªÅu ki·ªán**: 
  - C√≥ 5 d·∫•u li√™n ti·∫øp (ho·∫∑c 3 cho b√†n 3x3) ‚Üí `winner = 1 ho·∫∑c 2`
  - Ho·∫∑c b√†n c·ªù ƒë·∫ßy (draw) ‚Üí `winner = 'draw'`
  - Ho·∫∑c c√≥ ng∆∞·ªùi ƒë·∫ßu h√†ng ‚Üí `winner = opponent`
- **UI**: 
  - Hi·ªÉn th·ªã modal "Play Again" v·ªõi k·∫øt qu·∫£
  - ƒê∆∞·ªùng k·∫ª chi·∫øn th·∫Øng (n·∫øu c√≥ ng∆∞·ªùi th·∫Øng)
  - Final score
- **H√†nh ƒë·ªông cho ph√©p**: 
  - ‚úÖ Play Again (new game)
  - ‚úÖ Leave game
  - ‚ùå Make move (ƒë√£ k·∫øt th√∫c)
- **Logic x·ª≠ l√Ω**: 
  - Game kh√¥ng hi·ªÉn th·ªã trong lobby (ƒë√£ finished)
  - Kh√¥ng th·ªÉ join
  - C√≥ th·ªÉ play again ho·∫∑c leave

---

## üéØ T·∫°o v√† Tham Gia Game

### T·∫°o Game (`createGame`)

**Endpoint**: `POST /api/games/create`

**Logic x·ª≠ l√Ω**:
1. **X√°c th·ª±c ng∆∞·ªùi ch∆°i**:
   - N·∫øu c√≥ JWT token ‚Üí Authenticated user
   - N·∫øu kh√¥ng c√≥ token ‚Üí Guest user
   - L∆∞u `player1` = userId (n·∫øu authenticated) ho·∫∑c `player1GuestId` = guestId

2. **T·∫°o game**:
   - T·∫°o `roomId` (UUID)
   - T·∫°o `roomCode` (6 k√Ω t·ª± A-Z, 0-9, unique)
   - Kh·ªüi t·∫°o b√†n c·ªù r·ªóng
   - Set `gameStatus = 'waiting'` (ch·ªâ c√≥ 1 ng∆∞·ªùi ch∆°i)
   - L∆∞u rules (blockTwoEnds, allowUndo, maxUndoPerGame, timeLimit)

3. **Emit Socket Event**:
   - `game-created`: G·ª≠i ƒë·∫øn t·∫•t c·∫£ clients trong lobby
   - Data: `{ roomId, roomCode, boardSize, gameStatus, player1Username, createdAt }`

4. **Response**: Tr·∫£ v·ªÅ game data v·ªõi `roomId` v√† `roomCode`

**K·∫øt qu·∫£**: Game ƒë∆∞·ª£c t·∫°o v·ªõi tr·∫°ng th√°i `waiting` (1/2 players), ch·ªâ c√≥ player1

---

### Tham Gia Game (`joinGame`)

**Endpoint**: `POST /api/games/:roomId/join`

**Logic x·ª≠ l√Ω**:
1. **Ki·ªÉm tra game t·ªìn t·∫°i**: T√¨m game theo `roomId`

2. **Ki·ªÉm tra ƒëi·ªÅu ki·ªán join**:
   - ‚ùå Game ƒëang `playing` ‚Üí Kh√¥ng cho join
   - ‚ùå Game kh√¥ng ph·∫£i `waiting` ‚Üí Kh√¥ng cho join
   - ‚ùå Game ƒë√£ ƒë·ªß 2 ng∆∞·ªùi (`hasPlayer1 && hasPlayer2`) ‚Üí Kh√¥ng cho join
   - ‚úÖ Game ƒëang `waiting` v√† ch∆∞a ƒë·ªß 2 ng∆∞·ªùi ‚Üí Cho ph√©p join

3. **Ki·ªÉm tra ng∆∞·ªùi ch∆°i ƒë√£ trong game**:
   - N·∫øu user ƒë√£ l√† player1 ho·∫∑c player2 ‚Üí Tr·∫£ v·ªÅ game data (kh√¥ng join l·∫°i)

4. **G√°n player2**:
   - N·∫øu authenticated ‚Üí `player2 = userId`, `player2GuestId = null`
   - N·∫øu guest ‚Üí `player2 = null`, `player2GuestId = guestId`

5. **Emit Socket Events**:
   - `player-joined`: G·ª≠i ƒë·∫øn room (th√¥ng b√°o player2 ƒë√£ join)
   - `game-status-updated`: G·ª≠i ƒë·∫øn lobby (c·∫≠p nh·∫≠t status t·ª´ `waiting` 1/2 ‚Üí `ready` 2/2)

6. **Response**: Tr·∫£ v·ªÅ game data ƒë√£ c·∫≠p nh·∫≠t

**K·∫øt qu·∫£**: Game c√≥ ƒë·ªß 2 ng∆∞·ªùi ch∆°i, tr·∫°ng th√°i v·∫´n l√† `waiting` (ch∆∞a b·∫Øt ƒë·∫ßu)

---

## üöÄ B·∫Øt ƒê·∫ßu Game

### Start Game (`start-game` socket event)

**Logic x·ª≠ l√Ω**:
1. **Ki·ªÉm tra ƒëi·ªÅu ki·ªán**:
   - Game ph·∫£i ·ªü tr·∫°ng th√°i `waiting` (trong DB)
   - Ph·∫£i c√≥ ƒë·ªß 2 ng∆∞·ªùi ch∆°i (`player2` ho·∫∑c `player2GuestId`)
   - Tr·∫°ng th√°i hi·ªÉn th·ªã ph·∫£i l√† `ready` (2/2 players)

2. **X√°c ƒë·ªãnh ng∆∞·ªùi ƒëi tr∆∞·ªõc**:
   - Ng∆∞·ªùi click "Start Game" s·∫Ω ƒëi tr∆∞·ªõc
   - X√°c ƒë·ªãnh b·∫±ng c√°ch so s√°nh `socketData.userId` ho·∫∑c `socketData.playerId` v·ªõi `game.player1/player2` ho·∫∑c `game.player1GuestId/player2GuestId`
   - N·∫øu kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ‚Üí M·∫∑c ƒë·ªãnh player1 ƒëi tr∆∞·ªõc

3. **C·∫≠p nh·∫≠t game**:
   - `gameStatus = 'playing'` (chuy·ªÉn t·ª´ `waiting` sang `playing`)
   - `currentPlayer = startingPlayer` (ng∆∞·ªùi click start)

4. **Emit Socket Events**:
   - `game-started`: G·ª≠i ƒë·∫øn room v·ªõi `currentPlayer`
   - `game-status-updated`: G·ª≠i ƒë·∫øn lobby (c·∫≠p nh·∫≠t status t·ª´ `ready` ‚Üí `playing`)

**K·∫øt qu·∫£**: 
- Game chuy·ªÉn t·ª´ tr·∫°ng th√°i `ready` (2/2, ch∆∞a b·∫Øt ƒë·∫ßu) sang `playing` (ƒëang ch∆°i)
- Ng∆∞·ªùi click start ƒëi tr∆∞·ªõc
- C√≥ th·ªÉ b·∫Øt ƒë·∫ßu ƒë√°nh c·ªù

---

## üé≤ Lu·∫≠t Ch∆°i

### 1. Win Condition (ƒêi·ªÅu Ki·ªán Th·∫Øng)

**Logic**: `checkWin(board, row, col, player, boardSize, blockTwoEnds)`

**Quy t·∫Øc**:
- **B√†n 3x3**: C·∫ßn 3 d·∫•u li√™n ti·∫øp
- **B√†n kh√°c (15x15, 19x19, 20x20)**: C·∫ßn 5 d·∫•u li√™n ti·∫øp
- **H∆∞·ªõng th·∫Øng**: Horizontal, Vertical, Diagonal (\), Diagonal (/)

**C√°ch ki·ªÉm tra**:
1. T·ª´ v·ªã tr√≠ v·ª´a ƒë√°nh, ki·ªÉm tra 4 h∆∞·ªõng
2. ƒê·∫øm s·ªë d·∫•u li√™n ti·∫øp v·ªÅ m·ªói ph√≠a (positive v√† negative direction)
3. N·∫øu t·ªïng >= winCount (3 ho·∫∑c 5) ‚Üí Th·∫Øng
4. L∆∞u `winningLine`: M·∫£ng c√°c cell t·∫°o th√†nh ƒë∆∞·ªùng th·∫Øng

**Block Two Ends Rule**:
- N·∫øu `blockTwoEnds = true`:
  - Ki·ªÉm tra 2 ƒë·∫ßu c·ªßa ƒë∆∞·ªùng 5 d·∫•u
  - N·∫øu c·∫£ 2 ƒë·∫ßu ƒë·ªÅu b·ªã ch·∫∑n (b·ªüi ƒë·ªëi th·ªß ho·∫∑c bi√™n) ‚Üí Kh√¥ng t√≠nh l√† th·∫Øng
  - Pattern: `x o o o o o x` ‚Üí Kh√¥ng th·∫Øng

**K·∫øt qu·∫£**: Tr·∫£ v·ªÅ `{ isWin: boolean, winningLine?: Array<{row, col}> }`

---

### 2. Block Two Ends Rule (Ch·∫∑n 2 ƒê·∫ßu)

**M√¥ t·∫£**: NgƒÉn ch·∫∑n n∆∞·ªõc ƒëi s·∫Ω ch·∫∑n c·∫£ 2 ƒë·∫ßu c·ªßa ƒë∆∞·ªùng 4 d·∫•u m·ªü c·ªßa ƒë·ªëi th·ªß

**Logic**: `checkBlockTwoEnds(game, row, col, player)`

**C√°ch ho·∫°t ƒë·ªông**:
1. Qu√©t b√†n c·ªù t√¨m c√°c chu·ªói 4 d·∫•u li√™n ti·∫øp c·ªßa ƒë·ªëi th·ªß
2. Ki·ªÉm tra 2 ƒë·∫ßu c·ªßa chu·ªói:
   - End 1 (negative direction): Cell tr∆∞·ªõc chu·ªói
   - End 2 (positive direction): Cell sau chu·ªói
3. N·∫øu c·∫£ 2 ƒë·∫ßu ƒë·ªÅu m·ªü (empty):
   - Ki·ªÉm tra n∆∞·ªõc ƒëi hi·ªán t·∫°i c√≥ ƒë·∫∑t ·ªü 1 trong 2 ƒë·∫ßu kh√¥ng
   - N·∫øu c√≥ v√† ƒë·∫ßu kia ƒë√£ b·ªã ch·∫∑n ‚Üí Kh√¥ng cho ph√©p ƒëi
   - M·ª•c ƒë√≠ch: NgƒÉn ch·∫∑n vi·ªác ch·∫∑n c·∫£ 2 ƒë·∫ßu c·ªßa ƒë∆∞·ªùng 4 m·ªü

**V√≠ d·ª•**:
```
B√†n c·ªù: _ o o o o _
N∆∞·ªõc ƒëi: X v√†o ƒë·∫ßu tr√°i ‚Üí Ch·∫∑n 1 ƒë·∫ßu ‚Üí Cho ph√©p
N∆∞·ªõc ƒëi: X v√†o ƒë·∫ßu ph·∫£i ‚Üí Ch·∫∑n 1 ƒë·∫ßu ‚Üí Cho ph√©p
N∆∞·ªõc ƒëi: X v√†o ƒë·∫ßu tr√°i khi ƒë·∫ßu ph·∫£i ƒë√£ b·ªã ch·∫∑n ‚Üí Ch·∫∑n c·∫£ 2 ƒë·∫ßu ‚Üí Kh√¥ng cho ph√©p
```

---

### 3. Undo Move (Ho√†n T√°c)

**M√¥ t·∫£**: Cho ph√©p ng∆∞·ªùi ch∆°i y√™u c·∫ßu ho√†n t√°c n∆∞·ªõc ƒëi c·ªßa m√¨nh

**ƒêi·ªÅu ki·ªán**:
- `allowUndo = true` trong rules
- S·ªë l·∫ßn undo ch∆∞a v∆∞·ª£t qu√° `maxUndoPerGame` (m·∫∑c ƒë·ªãnh: 3)
- Ch·ªâ c√≥ th·ªÉ undo n∆∞·ªõc ƒëi c·ªßa ch√≠nh m√¨nh
- Kh√¥ng th·ªÉ undo ·ªü l∆∞·ª£t ƒë·∫ßu ti√™n (ch∆∞a c√≥ ƒë·ªß moves)

**Quy tr√¨nh**:
1. **Request Undo** (`request-undo`):
   - Player g·ª≠i `{ roomId, moveNumber }`
   - Server t√¨m move v√† emit `undo-requested` ƒë·∫øn ƒë·ªëi th·ªß
   - Frontend hi·ªÉn th·ªã dialog x√°c nh·∫≠n cho ƒë·ªëi th·ªß

2. **Approve Undo** (`approve-undo`):
   - ƒê·ªëi th·ªß ch·∫•p nh·∫≠n ‚Üí G·ªçi `undoMove(game, moveNumber)`
   - Logic:
     - T√¨m move trong database
     - X√≥a d·∫•u tr√™n b√†n c·ªù (`board[row][col] = 0`)
     - ƒê√°nh d·∫•u move l√† `isUndone = true`
     - Revert `currentPlayer` v·ªÅ ng∆∞·ªùi ƒë√£ undo
     - Set `gameStatus = 'playing'` (n·∫øu ƒë√£ finished)
   - Emit `undo-approved` v·ªõi board m·ªõi

3. **Reject Undo** (`reject-undo`):
   - ƒê·ªëi th·ªß t·ª´ ch·ªëi ‚Üí Emit `undo-rejected`
   - Game ti·∫øp t·ª•c nh∆∞ b√¨nh th∆∞·ªùng

**Gi·ªõi h·∫°n**:
- Ch·ªâ undo ƒë∆∞·ª£c n∆∞·ªõc ƒëi c·ªßa ch√≠nh m√¨nh
- T·ªëi ƒëa `maxUndoPerGame` l·∫ßn undo trong 1 game
- Kh√¥ng th·ªÉ undo khi game ƒë√£ finished

---

### 4. Draw (H√≤a)

**ƒêi·ªÅu ki·ªán**: B√†n c·ªù ƒë·∫ßy (t·∫•t c·∫£ cells ƒë·ªÅu != 0) v√† kh√¥ng c√≥ ng∆∞·ªùi th·∫Øng

**Logic**:
- Ki·ªÉm tra sau m·ªói n∆∞·ªõc ƒëi
- N·∫øu `isBoardFull && !isWin` ‚Üí `winner = 'draw'`, `gameStatus = 'finished'`

---

### 5. Surrender (ƒê·∫ßu H√†ng)

**M√¥ t·∫£**: Ng∆∞·ªùi ch∆°i t·ª± nguy·ªán ƒë·∫ßu h√†ng

**Logic**:
1. X√°c ƒë·ªãnh ng∆∞·ªùi ƒë·∫ßu h√†ng (player1 ho·∫∑c player2)
2. Set `winner = opponent` (ƒë·ªëi th·ªß th·∫Øng)
3. Set `gameStatus = 'finished'`
4. TƒÉng score cho ng∆∞·ªùi th·∫Øng
5. Emit `game-finished` v·ªõi reason "Opponent surrendered"

---

## üéÆ ƒêi·ªÅu Khi·ªÉn Game

### Make Move (ƒê√°nh C·ªù)

**Socket Event**: `make-move`

**Logic x·ª≠ l√Ω**:
1. **X√°c ƒë·ªãnh ng∆∞·ªùi ch∆°i**:
   - Ki·ªÉm tra `socketData.userId` (authenticated) ho·∫∑c `socketData.playerId` (guest)
   - So s√°nh v·ªõi `game.player1/player2` ho·∫∑c `game.player1GuestId/player2GuestId`
   - X√°c ƒë·ªãnh `player` (1 ho·∫∑c 2)

2. **Validate Move**:
   - Ki·ªÉm tra `currentPlayer === player` (ƒë√∫ng l∆∞·ª£t)
   - Ki·ªÉm tra `gameStatus === 'playing'` (game ƒëang ch∆°i)
   - Ki·ªÉm tra `board[row][col] === 0` (cell tr·ªëng)
   - Ki·ªÉm tra bounds (row, col trong ph·∫°m vi)
   - Ki·ªÉm tra Block Two Ends rule (n·∫øu enabled)

3. **Th·ª±c hi·ªán n∆∞·ªõc ƒëi**:
   - `board[row][col] = player`
   - `currentPlayer = player === 1 ? 2 : 1` (ƒë·ªïi l∆∞·ª£t)
   - L∆∞u move v√†o `GameMove` collection

4. **Ki·ªÉm tra th·∫Øng**:
   - G·ªçi `checkWin()` ‚Üí Tr·∫£ v·ªÅ `{ isWin, winningLine }`
   - N·∫øu th·∫Øng:
     - `gameStatus = 'finished'`
     - `winner = player`
     - `finishedAt = new Date()`
     - L∆∞u `winningLine` v√†o game
     - TƒÉng score cho ng∆∞·ªùi th·∫Øng
   - N·∫øu h√≤a (board full):
     - `gameStatus = 'finished'`
     - `winner = 'draw'`
     - `finishedAt = new Date()`

5. **Emit Socket Events**:
   - `move-made`: G·ª≠i ƒë·∫øn room v·ªõi board m·ªõi v√† currentPlayer
   - N·∫øu finished: `game-finished` v·ªõi winner v√† reason
   - `score-updated`: C·∫≠p nh·∫≠t score

**K·∫øt qu·∫£**: B√†n c·ªù ƒë∆∞·ª£c c·∫≠p nh·∫≠t, l∆∞·ª£t ch∆°i ƒë·ªïi, ho·∫∑c game k·∫øt th√∫c

---

### New Game (Ch∆°i L·∫°i)

**Socket Event**: `new-game`

**Logic x·ª≠ l√Ω**:
1. Reset b√†n c·ªù v·ªÅ tr·∫°ng th√°i r·ªóng
2. Gi·ªØ nguy√™n score (kh√¥ng reset)
3. `currentPlayer = 1`
4. `gameStatus = 'playing'`
5. `winner = null`
6. `finishedAt = null`
7. Emit `move-made` v·ªõi board m·ªõi

**K·∫øt qu·∫£**: Game m·ªõi b·∫Øt ƒë·∫ßu v·ªõi score c≈© ƒë∆∞·ª£c gi·ªØ l·∫°i

---

## üö™ R·ªùi Game v√† Qu·∫£n L√Ω Host

### Leave Game (`leaveGame` API)

**Endpoint**: `POST /api/games/:roomId/leave`

**Logic x·ª≠ l√Ω chi ti·∫øt**:

#### B∆∞·ªõc 1: X√°c ƒë·ªãnh ng∆∞·ªùi r·ªùi
- Ki·ªÉm tra authenticated user (`authReq.user?.userId`)
- Ki·ªÉm tra guest (`guestId`)
- X√°c ƒë·ªãnh `isPlayer1` ho·∫∑c `isPlayer2`

#### B∆∞·ªõc 2: Ki·ªÉm tra tr·∫°ng th√°i tr∆∞·ªõc khi r·ªùi
- `hasPlayer1Before`: C√≥ player1 tr∆∞·ªõc khi r·ªùi?
- `hasPlayer2Before`: C√≥ player2 tr∆∞·ªõc khi r·ªùi?
- `wasFinished`: Game ƒë√£ finished tr∆∞·ªõc khi r·ªùi?

#### B∆∞·ªõc 3: X√≥a ng∆∞·ªùi ch∆°i kh·ªèi game
- N·∫øu `isPlayer1` ‚Üí `game.player1 = null`, `game.player1GuestId = null`
- N·∫øu `isPlayer2` ‚Üí `game.player2 = null`, `game.player2GuestId = null`

#### B∆∞·ªõc 4: Ki·ªÉm tra tr·∫°ng th√°i sau khi r·ªùi
- `hasPlayer1After`: C√≤n player1 sau khi r·ªùi?
- `hasPlayer2After`: C√≤n player2 sau khi r·ªùi?
- `hasNoPlayers`: Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i n√†o?

---

### Case 1: Game Finished + C·∫£ 2 Player R·ªùi ‚Üí L∆∞u History v√† X√≥a Game

**ƒêi·ªÅu ki·ªán**:
- `hasNoPlayers = true` (kh√¥ng c√≤n ng∆∞·ªùi ch∆°i n√†o)
- `game.gameStatus === 'finished'`
- `game.finishedAt` t·ªìn t·∫°i

**Logic x·ª≠ l√Ω**:
1. **Ki·ªÉm tra c√≥ authenticated player kh√¥ng**:
   - `hasAuthenticatedPlayer = !!(game.player1 || game.player2)`
   
2. **N·∫øu c√≥ authenticated player**:
   - T·∫°o `GameHistory` record:
     - L∆∞u t·∫•t c·∫£ th√¥ng tin game (board, winner, score, rules, winningLine)
     - `player1GuestId = null`, `player2GuestId = null` (kh√¥ng l∆∞u guest IDs)
     - `savedAt = new Date()`
   - L∆∞u v√†o database
   - Cleanup old history (gi·ªØ l·∫°i 50 games g·∫ßn nh·∫•t cho m·ªói authenticated user)
   
3. **N·∫øu ch·ªâ c√≥ guest players**:
   - Kh√¥ng l∆∞u v√†o database
   - Frontend s·∫Ω t·ª± l∆∞u v√†o localStorage

4. **X√≥a game**:
   - `Game.deleteOne({ roomId })`

5. **Emit Socket Events**:
   - `game-deleted`: G·ª≠i ƒë·∫øn t·∫•t c·∫£ clients trong lobby (kh√¥ng ch·ªâ room)
   - Data: `{ roomId }`

**K·∫øt qu·∫£**: Game b·ªã x√≥a, history ƒë∆∞·ª£c l∆∞u (n·∫øu c√≥ authenticated user), UI c·∫≠p nh·∫≠t real-time

---

### Case 2: Game Finished + 1 Player R·ªùi ‚Üí Reset V·ªÅ Waiting (1/2)

**ƒêi·ªÅu ki·ªán**:
- `hasNoPlayers = false` (c√≤n 1 ng∆∞·ªùi ch∆°i)
- `wasFinished = true` (game ƒë√£ finished)

**Logic x·ª≠ l√Ω**:
1. **Host Transfer** (n·∫øu player1 r·ªùi):
   - N·∫øu `isPlayer1 && hasPlayer2After`:
     - `game.player1 = game.player2` (chuy·ªÉn player2 th√†nh player1)
     - `game.player1GuestId = game.player2GuestId`
     - `game.player2 = null`
     - `game.player2GuestId = null`
     - `hostTransferred = true`

2. **Reset Game**:
   - `gameStatus = 'waiting'` (chuy·ªÉn t·ª´ `finished` v·ªÅ `waiting` - ch·ªâ c√≥ 1 ng∆∞·ªùi)
   - `winner = null`
   - `finishedAt = null`
   - Reset board v·ªÅ tr·∫°ng th√°i r·ªóng
   - `currentPlayer = 1`
   - `gameReset = true`

3. **Emit Socket Events**:
   - `player-left`: G·ª≠i ƒë·∫øn room v·ªõi `hostTransferred` v√† `gameReset`
   - `game-status-updated`: G·ª≠i ƒë·∫øn lobby (c·∫≠p nh·∫≠t status t·ª´ `finished` ‚Üí `waiting` 1/2)

**K·∫øt qu·∫£**: 
- Game reset v·ªÅ `waiting` (1/2 players)
- Ng∆∞·ªùi c√≤n l·∫°i tr·ªü th√†nh host (n·∫øu host c≈© r·ªùi)
- C√≥ th·ªÉ ch·ªù ng∆∞·ªùi ch∆°i m·ªõi join
- UI hi·ªÉn th·ªã "Waiting for players..."

---

### Case 3: Game Ch∆∞a Finished + C·∫£ 2 Player R·ªùi ‚Üí X√≥a Game

**ƒêi·ªÅu ki·ªán**:
- `hasNoPlayers = true`
- `game.gameStatus !== 'finished'` (ch∆∞a finished)

**Logic x·ª≠ l√Ω**:
1. X√≥a game tr·ª±c ti·∫øp: `Game.deleteOne({ roomId })`
2. Kh√¥ng l∆∞u history (v√¨ game ch∆∞a k·∫øt th√∫c)

3. **Emit Socket Events**:
   - `game-deleted`: G·ª≠i ƒë·∫øn t·∫•t c·∫£ clients trong lobby

**K·∫øt qu·∫£**: Game b·ªã x√≥a, kh√¥ng l∆∞u history

---

### Case 4: Game Playing + 1 Player R·ªùi ‚Üí Reset V·ªÅ Waiting (1/2)

**ƒêi·ªÅu ki·ªán**:
- `hasNoPlayers = false` (c√≤n 1 ng∆∞·ªùi ch∆°i)
- `game.gameStatus === 'playing'` (ƒëang ch∆°i)

**Logic x·ª≠ l√Ω**:
1. **Host Transfer** (n·∫øu player1 r·ªùi):
   - N·∫øu `isPlayer1 && hasPlayer2After`:
     - `game.player1 = game.player2` (chuy·ªÉn player2 th√†nh player1)
     - `game.player1GuestId = game.player2GuestId`
     - `game.player2 = null`
     - `game.player2GuestId = null`
     - `hostTransferred = true`

2. **Reset Game**:
   - `gameStatus = 'waiting'` (chuy·ªÉn t·ª´ `playing` v·ªÅ `waiting` - ch·ªâ c√≥ 1 ng∆∞·ªùi)
   - `winner = null`
   - `finishedAt = null`
   - Reset board v·ªÅ tr·∫°ng th√°i r·ªóng
   - `currentPlayer = 1`
   - `gameReset = true`

3. **Emit Socket Events**:
   - `player-left`: G·ª≠i ƒë·∫øn room v·ªõi `hostTransferred` v√† `gameReset`
   - `game-status-updated`: G·ª≠i ƒë·∫øn lobby (c·∫≠p nh·∫≠t status t·ª´ `playing` ‚Üí `waiting` 1/2)

**K·∫øt qu·∫£**: 
- Game reset v·ªÅ `waiting` (1/2 players)
- Ng∆∞·ªùi c√≤n l·∫°i tr·ªü th√†nh host (n·∫øu host c≈© r·ªùi)
- C√≥ th·ªÉ ch·ªù ng∆∞·ªùi ch∆°i m·ªõi join
- UI hi·ªÉn th·ªã "Waiting for players..."

---

### Disconnect Handler (Socket)

**Khi socket disconnect** (browser ƒë√≥ng, m·∫•t m·∫°ng, v.v.):

**Logic x·ª≠ l√Ω**:
1. T√¨m game m√† player ƒëang tham gia (`socketData.currentRoomId`)
2. X√°c ƒë·ªãnh player ƒëang disconnect (t∆∞∆°ng t·ª± `leaveGame`)
3. **Th·ª±c hi·ªán logic gi·ªëng `leaveGame`**:
   - X√≥a player kh·ªèi game
   - X·ª≠ l√Ω c√°c case 1-4 nh∆∞ tr√™n
   - L∆∞u history n·∫øu c·∫ßn
   - Emit socket events

**L∆∞u √Ω**: Logic disconnect ph·∫£i gi·ªëng h·ªát `leaveGame` ƒë·ªÉ ƒë·∫£m b·∫£o consistency

---

## üìö L·ªãch S·ª≠ Game

### L∆∞u L·ªãch S·ª≠

#### Authenticated Users
- **L∆∞u v√†o Database**: `GameHistory` collection
- **Khi n√†o l∆∞u**: Khi game finished v√† c·∫£ 2 player r·ªùi (Case 1)
- **D·ªØ li·ªáu l∆∞u**:
  - Board state (tr·∫°ng th√°i b√†n c·ªù)
  - Winner v√† winningLine
  - Score
  - Rules
  - Players (ch·ªâ authenticated users, kh√¥ng l∆∞u guest IDs)
  - Timestamps (createdAt, finishedAt, savedAt)
- **Gi·ªõi h·∫°n**: Gi·ªØ l·∫°i 50 games g·∫ßn nh·∫•t cho m·ªói user
- **Cleanup**: T·ª± ƒë·ªông x√≥a games c≈© h∆°n 50

#### Guest Users
- **L∆∞u v√†o localStorage**: Kh√¥ng l∆∞u v√†o database
- **Khi n√†o l∆∞u**: Khi game finished (trong `handleGameFinished` c·ªßa GameContext)
- **D·ªØ li·ªáu l∆∞u**: T∆∞∆°ng t·ª± authenticated nh∆∞ng l∆∞u v√†o localStorage
- **Gi·ªõi h·∫°n**: T·ªëi ƒëa 20 games
- **L∆∞u √Ω**: 
  - Ch·ªâ t·ªìn t·∫°i khi tab c√≤n m·ªü
  - T·∫Øt tab ‚Üí M·∫•t l·ªãch s·ª≠
  - M·ªói tab c√≥ localStorage ri√™ng

---

### ƒê·ªçc L·ªãch S·ª≠

#### Authenticated Users
- **API**: `POST /api/games/history`
- **Logic**:
  - Query database v·ªõi `player1 = userId OR player2 = userId`
  - S·∫Øp x·∫øp theo `finishedAt` gi·∫£m d·∫ßn
  - Limit 50 games
  - Format response v·ªõi `result` (win/loss/draw) v√† `opponentUsername`

#### Guest Users
- **Source**: localStorage
- **Logic**:
  - ƒê·ªçc t·ª´ `localStorage.getItem('caro_guest_history')`
  - Parse JSON
  - Validate v√† filter invalid entries
  - Tr·∫£ v·ªÅ t·ªëi ƒëa 20 games

---

### Hi·ªÉn Th·ªã L·ªãch S·ª≠

**Component**: `HistoryModal`

**T√≠nh nƒÉng**:
- Hi·ªÉn th·ªã danh s√°ch games (list view)
- Click v√†o game ‚Üí Xem b√†n c·ªù (board view)
- Hi·ªÉn th·ªã:
  - Result (Win/Loss/Draw) v·ªõi m√†u s·∫Øc
  - Opponent username
  - Board size
  - Final score
  - Finished date
  - **Winning line**: ƒê∆∞·ªùng k·∫ª ƒë·ªè tr√™n 5 d·∫•u th·∫Øng (n·∫øu c√≥)

**Winning Line Visualization**:
- Highlight c√°c cell trong winning line (border ƒë·ªè, background gradient)
- V·∫Ω SVG line t·ª´ cell ƒë·∫ßu ƒë·∫øn cell cu·ªëi
- √Åp d·ª•ng cho c·∫£ game ƒëang ch∆°i v√† l·ªãch s·ª≠

---

## üîÑ Real-time Updates

### Socket.IO Events

#### Client ‚Üí Server Events:
- `join-room`: Tham gia socket room
- `leave-room`: R·ªùi socket room
- `make-move`: ƒê√°nh c·ªù
- `request-undo`: Y√™u c·∫ßu undo
- `approve-undo`: Ch·∫•p nh·∫≠n undo
- `reject-undo`: T·ª´ ch·ªëi undo
- `surrender`: ƒê·∫ßu h√†ng
- `start-game`: B·∫Øt ƒë·∫ßu game
- `new-game`: Ch∆°i l·∫°i

#### Server ‚Üí Client Events:
- `room-joined`: ƒê√£ tham gia room
- `player-joined`: C√≥ ng∆∞·ªùi ch∆°i m·ªõi join
- `player-left`: C√≥ ng∆∞·ªùi ch∆°i r·ªùi
- `game-deleted`: Game b·ªã x√≥a
- `move-made`: C√≥ n∆∞·ªõc ƒëi m·ªõi
- `undo-requested`: C√≥ y√™u c·∫ßu undo
- `undo-approved`: Undo ƒë∆∞·ª£c ch·∫•p nh·∫≠n
- `undo-rejected`: Undo b·ªã t·ª´ ch·ªëi
- `game-finished`: Game k·∫øt th√∫c
- `game-started`: Game b·∫Øt ƒë·∫ßu
- `game-error`: C√≥ l·ªói x·∫£y ra
- `score-updated`: Score ƒë∆∞·ª£c c·∫≠p nh·∫≠t
- `game-created`: Game m·ªõi ƒë∆∞·ª£c t·∫°o (lobby)
- `game-status-updated`: Game status thay ƒë·ªïi (lobby)

---

### HomePage Real-time Updates

**T√≠nh nƒÉng**: C·∫≠p nh·∫≠t danh s√°ch game real-time kh√¥ng b·ªã flickering

**C∆° ch·∫ø**:
1. **Socket Listeners**:
   - `game-created`: Game m·ªõi ƒë∆∞·ª£c t·∫°o ‚Üí Reload list (silent)
   - `game-status-updated`: Game status thay ƒë·ªïi ‚Üí Reload list (silent)
   - `game-deleted`: Game b·ªã x√≥a ‚Üí X√≥a kh·ªèi list ngay l·∫≠p t·ª©c

2. **Smart Merge**:
   - Ch·ªâ update ph·∫ßn thay ƒë·ªïi, kh√¥ng replace to√†n b·ªô array
   - So s√°nh t·ª´ng game ƒë·ªÉ ph√°t hi·ªán thay ƒë·ªïi
   - Track mounted games ƒë·ªÉ animation optimization

3. **Conditional Animation**:
   - Game m·ªõi: Animate v·ªõi timeout 400ms
   - Game update: Kh√¥ng animate (timeout 0ms)

4. **Fallback Polling**:
   - Interval 30s (tƒÉng t·ª´ 5s) ƒë·ªÉ ƒë·∫£m b·∫£o sync n·∫øu socket fail

---

## üîê X√°c Th·ª±c v√† Guest

### Guest Mode

**C∆° ch·∫ø**:
- M·ªói tab c√≥ `guestId` ri√™ng (l∆∞u trong `sessionStorage`)
- Format: `guest_${timestamp}_${random}`
- T·ª± ƒë·ªông t·∫°o khi c·∫ßn

**H·∫°n ch·∫ø**:
- L·ªãch s·ª≠ ch·ªâ l∆∞u trong localStorage (t·∫°m th·ªùi)
- Kh√¥ng l∆∞u v√†o database
- M·∫•t khi t·∫Øt tab

---

### Authenticated Mode

**C∆° ch·∫ø**:
- S·ª≠ d·ª•ng JWT token
- User ID ƒë∆∞·ª£c l∆∞u trong `player1`/`player2` (ObjectId)
- Username ƒë∆∞·ª£c populate t·ª´ User model

**L·ª£i √≠ch**:
- L·ªãch s·ª≠ l∆∞u vƒ©nh vi·ªÖn trong database
- C√≥ th·ªÉ xem l·∫°i khi ƒëƒÉng nh·∫≠p l·∫°i
- Game stats tracking

---

### Mixed Mode (Authenticated + Guest)

**H·ªó tr·ª£**:
- Authenticated user c√≥ th·ªÉ ch∆°i v·ªõi Guest
- Game l∆∞u c·∫£ `player1` (authenticated) v√† `player2GuestId` (guest)
- Khi l∆∞u history: Ch·ªâ l∆∞u authenticated user, kh√¥ng l∆∞u guest ID

---

## üé® UI Features

### Game Board
- **Responsive**: T·ª± ƒë·ªông resize theo container
- **Cell Highlighting**: 
  - Last move: Border v√† background gradient
  - Winning cells: Border ƒë·ªè d√†y, background ƒë·ªè, box shadow
- **Winning Line**: SVG overlay v·ªõi ƒë∆∞·ªùng k·∫ª ƒë·ªè

### Game Controls
- **Start Game Button**: Ch·ªâ hi·ªán khi ƒë·ªß 2 ng∆∞·ªùi v√† game ƒëang `waiting`
- **Request Undo**: 
  - Ch·ªâ hi·ªán khi ƒë·ªß ƒëi·ªÅu ki·ªán (kh√¥ng ph·∫£i l∆∞·ª£t ƒë·∫ßu, ch∆∞a v∆∞·ª£t limit)
  - Visual feedback khi g·ª≠i request
- **Surrender Button**: Lu√¥n hi·ªán khi game ƒëang `playing`

### Game Info
- **Current Rules Display**: Hi·ªÉn th·ªã rules hi·ªán t·∫°i
- **Score Display**: Hi·ªÉn th·ªã score c·ªßa c·∫£ 2 ng∆∞·ªùi ch∆°i
- **Player Info**: Hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi ch∆°i

### Waiting State
- **UI**: Hi·ªÉn th·ªã "Waiting for players..." message
- **Kh√¥ng hi·ªán**: B√†n c·ªù v√† Start button (ch·ªâ hi·ªán khi ƒë·ªß 2 ng∆∞·ªùi)

---

## üîß Technical Details

### Database Models

#### Game Model
- `roomId`: UUID unique
- `roomCode`: 6 k√Ω t·ª± unique
- `player1`/`player2`: ObjectId (authenticated) ho·∫∑c null
- `player1GuestId`/`player2GuestId`: String (guest) ho·∫∑c null
- `board`: 2D array (0 = empty, 1 = player1, 2 = player2)
- `gameStatus`: 'waiting' | 'playing' | 'finished'
  - **L∆∞u √Ω**: `abandoned` kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong code
  - **Display Status** (trong UI): 'waiting' (1/2) | 'ready' (2/2, ch∆∞a start) | 'playing' (2/2, ƒëang ch∆°i)
- `winner`: 1 | 2 | null | 'draw'
- `winningLine`: Array<{row, col}>
- `rules`: { blockTwoEnds, allowUndo, maxUndoPerGame, timeLimit }
- `score`: { player1, player2 }

#### GameHistory Model
- T∆∞∆°ng t·ª± Game nh∆∞ng:
  - Kh√¥ng c√≥ `currentPlayer`
  - C√≥ `savedAt`: Th·ªùi ƒëi·ªÉm l∆∞u history
  - `player1GuestId`/`player2GuestId`: Kh√¥ng l∆∞u (null) cho authenticated games

#### GameMove Model
- L∆∞u t·ª´ng n∆∞·ªõc ƒëi
- `isUndone`: ƒê√°nh d·∫•u ƒë√£ b·ªã undo
- D√πng ƒë·ªÉ track undo count v√† undo moves

---

### Frontend State Management

#### GameContext
- Qu·∫£n l√Ω game state, socket connection
- Handle c√°c socket events
- L∆∞u guest history v√†o localStorage
- Submit game stats cho authenticated users

#### Smart State Updates
- S·ª≠ d·ª•ng functional updates ƒë·ªÉ tr√°nh stale closures
- Track `isMounted` ƒë·ªÉ tr√°nh memory leaks
- Cleanup timeouts v√† socket listeners

---

## üìù T√≥m T·∫Øt Logic Quan Tr·ªçng

### 1. Host Transfer
- **Khi n√†o**: Player1 (host) r·ªùi, Player2 c√≤n l·∫°i
- **Logic**: Chuy·ªÉn Player2 th√†nh Player1, x√≥a Player2
- **K·∫øt qu·∫£**: Player2 tr·ªü th√†nh host m·ªõi

### 2. Game Reset
- **Khi n√†o**: 
  - Game finished + 1 player r·ªùi ‚Üí Reset v·ªÅ `waiting` (1/2)
  - Game playing + 1 player r·ªùi ‚Üí Reset v·ªÅ `waiting` (1/2)
- **Logic**: 
  - Reset board v·ªÅ tr·∫°ng th√°i r·ªóng
  - `gameStatus = 'waiting'` (ch·ªâ c√≥ 1 ng∆∞·ªùi ch∆°i)
  - X√≥a winner, finishedAt
  - Host transfer n·∫øu c·∫ßn
- **K·∫øt qu·∫£**: 
  - Game v·ªÅ tr·∫°ng th√°i `waiting` (1/2 players)
  - S·∫µn s√†ng cho ng∆∞·ªùi ch∆°i m·ªõi join
  - Sau khi join ƒë·ªß 2 ng∆∞·ªùi ‚Üí Chuy·ªÉn sang `ready` (2/2, ch∆∞a b·∫Øt ƒë·∫ßu)

### 3. History Saving
- **Authenticated**: L∆∞u v√†o DB khi game finished + c·∫£ 2 r·ªùi
- **Guest**: L∆∞u v√†o localStorage khi game finished
- **Cleanup**: T·ª± ƒë·ªông x√≥a games c≈© (50 cho authenticated, 20 cho guest)

### 4. Winning Line
- **T√≠nh to√°n**: Trong `checkWin()`, tr·∫£ v·ªÅ array c√°c cell
- **L∆∞u tr·ªØ**: L∆∞u v√†o `game.winningLine` v√† `GameHistory.winningLine`
- **Hi·ªÉn th·ªã**: SVG overlay + cell highlighting

### 5. Real-time Sync
- **Socket Events**: C·∫≠p nh·∫≠t real-time cho t·∫•t c·∫£ clients
- **Smart Merge**: Ch·ªâ update ph·∫ßn thay ƒë·ªïi
- **Fallback**: Polling 30s n·∫øu socket fail

---

## üéØ K·∫øt Lu·∫≠n

Mini Game Caro l√† m·ªôt h·ªá th·ªëng ph·ª©c t·∫°p v·ªõi nhi·ªÅu edge cases ƒë∆∞·ª£c x·ª≠ l√Ω c·∫©n th·∫≠n:
- ‚úÖ Qu·∫£n l√Ω host transfer khi player r·ªùi
- ‚úÖ L∆∞u history ph√¢n bi·ªát guest v√† authenticated
- ‚úÖ Real-time updates kh√¥ng flickering
- ‚úÖ Winning line visualization
- ‚úÖ Undo system v·ªõi approval
- ‚úÖ Block two ends rule
- ‚úÖ Multiple board sizes
- ‚úÖ Game state management ch√≠nh x√°c

T·∫•t c·∫£ logic ƒë·ªÅu ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·ªÉ ƒë·∫£m b·∫£o tr·∫£i nghi·ªám ng∆∞·ªùi d√πng m∆∞·ª£t m√† v√† nh·∫•t qu√°n.
</file>

<file path="backend/src/config/database.ts">
import mongoose from 'mongoose';

export const connectDatabase = async (): Promise<void> => {
  try {
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/caro-game';
    await mongoose.connect(mongoUri);
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};
</file>

<file path="backend/src/config/socket.io.ts">
import { Server as SocketIOServer } from 'socket.io';
import { Server as HTTPServer } from 'http';
import { verifyToken } from '../utils/jwt';

export const setupSocketIO = (httpServer: HTTPServer): SocketIOServer => {
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: process.env.FRONTEND_URL || 'http://localhost:3000',
      methods: ['GET', 'POST'],
      credentials: true,
    },
  });

  // Socket authentication middleware
  io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    
    if (!token) {
      // Allow guest connections
      socket.data.isGuest = true;
      return next();
    }

    try {
      const decoded = verifyToken(token);
      socket.data.userId = decoded.userId;
      socket.data.username = decoded.username;
      socket.data.isGuest = false;
      next();
    } catch (error) {
      // Allow guest connections even if token is invalid
      socket.data.isGuest = true;
      next();
    }
  });

  return io;
};
</file>

<file path="backend/src/controllers/authController.ts">
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import User from '../models/User';
import { generateToken } from '../utils/jwt';
import { AuthRequest } from '../middleware/authMiddleware';

export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const { username, email, password } = req.body;

    // Validate input
    if (!username || !email || !password) {
      res.status(400).json({ message: 'All fields are required' });
      return;
    }

    // Check if user exists
    const existingUser = await User.findOne({
      $or: [{ email }, { username }],
    });

    if (existingUser) {
      res.status(400).json({ message: 'User already exists' });
      return;
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const user = new User({
      username,
      email,
      password: hashedPassword,
    });

    await user.save();

    // Generate token
    const token = generateToken({
      userId: user._id.toString(),
      username: user.username,
    });

    res.status(201).json({
      token,
      user: {
        _id: user._id,
        username: user.username,
        email: user.email,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
        totalScore: user.totalScore,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin,
      },
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      res.status(400).json({ message: 'Email and password are required' });
      return;
    }

    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      res.status(401).json({ message: 'Invalid credentials' });
      return;
    }

    // Check password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      res.status(401).json({ message: 'Invalid credentials' });
      return;
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    // Generate token
    const token = generateToken({
      userId: user._id.toString(),
      username: user.username,
    });

    res.json({
      token,
      user: {
        _id: user._id,
        username: user.username,
        email: user.email,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
        totalScore: user.totalScore,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin,
      },
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const getMe = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const user = await User.findById(req.user?.userId).select('-password');
    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }

    res.json({
      _id: user._id,
      username: user.username,
      email: user.email,
      wins: user.wins,
      losses: user.losses,
      draws: user.draws,
      totalScore: user.totalScore,
      createdAt: user.createdAt,
      lastLogin: user.lastLogin,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="backend/src/controllers/gameStatsController.ts">
import { Request, Response } from 'express';
import GameStats from '../models/GameStats';
import GameType from '../models/GameType';
import { AuthRequest } from '../middleware/authMiddleware';
import { createSessionAfterSubmission } from '../middleware/validateScore';

/**
 * Get stats for a specific user and game
 */
export const getUserGameStats = async (req: Request, res: Response): Promise<void> => {
  try {
    const { gameId, userId } = req.params;

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    const stats = await GameStats.findOne({
      userId,
      gameId,
    }).populate('userId', 'username');

    if (!stats) {
      // Return default stats if not found
      res.json({
        userId,
        gameId,
        wins: 0,
        losses: 0,
        draws: 0,
        totalScore: 0,
        customStats: {},
        lastPlayed: null,
      });
      return;
    }

    res.json({
      _id: stats._id,
      userId: stats.userId,
      gameId: stats.gameId,
      wins: stats.wins,
      losses: stats.losses,
      draws: stats.draws,
      totalScore: stats.totalScore,
      customStats: Object.fromEntries(stats.customStats || new Map()),
      lastPlayed: stats.lastPlayed,
      createdAt: stats.createdAt,
      updatedAt: stats.updatedAt,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get current user's stats for a game
 */
export const getMyGameStats = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { gameId } = req.params;
    const userId = req.user?.userId;

    if (!userId) {
      res.status(401).json({ message: 'Unauthorized' });
      return;
    }

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    let stats = await GameStats.findOne({
      userId,
      gameId,
    });

    if (!stats) {
      // Create default stats if not exists
      stats = new GameStats({
        userId,
        gameId,
        wins: 0,
        losses: 0,
        draws: 0,
        totalScore: 0,
      });
      await stats.save();
    }

    res.json({
      _id: stats._id,
      userId: stats.userId,
      gameId: stats.gameId,
      wins: stats.wins,
      losses: stats.losses,
      draws: stats.draws,
      totalScore: stats.totalScore,
      customStats: Object.fromEntries(stats.customStats || new Map()),
      lastPlayed: stats.lastPlayed,
      createdAt: stats.createdAt,
      updatedAt: stats.updatedAt,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Submit game result and update stats
 * This should be called after a game finishes
 */
export const submitGameResult = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { gameId } = req.params;
    const userId = req.user?.userId;
    const { result, score, customStats } = req.body; // result: 'win' | 'loss' | 'draw'

    if (!userId) {
      res.status(401).json({ message: 'Unauthorized' });
      return;
    }

    if (!['win', 'loss', 'draw'].includes(result)) {
      res.status(400).json({ message: 'Invalid result. Must be win, loss, or draw' });
      return;
    }

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    // Find or create stats
    let stats = await GameStats.findOne({
      userId,
      gameId,
    });

    if (!stats) {
      stats = new GameStats({
        userId,
        gameId,
        wins: 0,
        losses: 0,
        draws: 0,
        totalScore: 0,
      });
    }

    // Update stats based on result
    if (result === 'win') {
      stats.wins += 1;
    } else if (result === 'loss') {
      stats.losses += 1;
    } else if (result === 'draw') {
      stats.draws += 1;
    }

    // Update total score (can be customized per game)
    if (typeof score === 'number') {
      stats.totalScore += score;
    } else {
      // Default scoring: win = +10, loss = -5, draw = +2
      if (result === 'win') {
        stats.totalScore += 10;
      } else if (result === 'loss') {
        stats.totalScore = Math.max(0, stats.totalScore - 5);
      } else if (result === 'draw') {
        stats.totalScore += 2;
      }
    }

    // Update custom stats if provided
    if (customStats && typeof customStats === 'object') {
      for (const [key, value] of Object.entries(customStats)) {
        stats.customStats.set(key, value);
      }
    }

    stats.lastPlayed = new Date();
    await stats.save();

    // Create game session record for audit trail
    const { gameData, guestId } = req.body;
    await createSessionAfterSubmission(
      gameId,
      userId || null,
      guestId || null,
      result,
      stats.totalScore,
      gameData || {}
    );

    res.json({
      _id: stats._id,
      userId: stats.userId,
      gameId: stats.gameId,
      wins: stats.wins,
      losses: stats.losses,
      draws: stats.draws,
      totalScore: stats.totalScore,
      customStats: Object.fromEntries(stats.customStats || new Map()),
      lastPlayed: stats.lastPlayed,
      updatedAt: stats.updatedAt,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="backend/src/middleware/errorHandler.ts">
import { Request, Response, NextFunction } from 'express';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  console.error('Error:', err);

  res.status(500).json({
    message: err.message || 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
  });
};
</file>

<file path="backend/src/middleware/rateLimiter.ts">
import { Request, Response, NextFunction } from 'express';
import { AuthRequest } from './authMiddleware';

/**
 * Rate limiter middleware
 * Limits number of requests per user/IP
 */

// In-memory store (use Redis in production)
const requestCounts = new Map<string, { count: number; resetAt: number }>();

interface RateLimitOptions {
  windowMs: number; // Time window in milliseconds
  max: number; // Max requests per window
  message?: string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

const defaultOptions: RateLimitOptions = {
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: 'Too many requests, please try again later.',
};

/**
 * Create rate limiter middleware
 */
export const createRateLimiter = (options: Partial<RateLimitOptions> = {}) => {
  const opts = { ...defaultOptions, ...options };

  return (req: Request, res: Response, next: NextFunction): void => {
    const identifier = getIdentifier(req as AuthRequest);
    const now = Date.now();

    let limit = requestCounts.get(identifier);

    // Reset if window expired
    if (!limit || now > limit.resetAt) {
      limit = {
        count: 1,
        resetAt: now + opts.windowMs,
      };
      requestCounts.set(identifier, limit);
      return next();
    }

    // Check if limit exceeded
    if (limit.count >= opts.max) {
      res.status(429).json({
        message: opts.message,
        retryAfter: Math.ceil((limit.resetAt - now) / 1000),
      });
      return;
    }

    // Increment count
    limit.count++;
    next();
  };
};

/**
 * Get identifier for rate limiting (userId, IP, or guestId)
 */
function getIdentifier(req: AuthRequest): string {
  const authReq = req as AuthRequest;
  
  // Prefer authenticated user
  if (authReq.user?.userId) {
    return `user:${authReq.user.userId}`;
  }

  // Fallback to IP address
  const ip = req.ip || req.socket.remoteAddress || 'unknown';
  return `ip:${ip}`;
}

/**
 * Rate limiter for score submissions (stricter)
 */
export const scoreSubmissionLimiter = createRateLimiter({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // Max 10 score submissions per minute
  message: 'Too many score submissions. Please wait before trying again.',
});

/**
 * Rate limiter for API endpoints (general)
 */
export const apiLimiter = createRateLimiter({
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: 'Too many requests. Please try again later.',
});

/**
 * Rate limiter for authentication endpoints (stricter)
 */
export const authLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Max 5 login attempts per 15 minutes
  message: 'Too many authentication attempts. Please try again later.',
});
</file>

<file path="backend/src/middleware/validateScore.ts">
import { Request, Response, NextFunction } from 'express';
import { AuthRequest } from './authMiddleware';
import { validateGameSubmission, createGameSession } from '../services/antiCheatService';
import { v4 as uuidv4 } from 'uuid';

/**
 * Middleware to validate score submissions
 * Validates nonce, timestamp, rate limiting, and score reasonableness
 */
export const validateScore = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { gameId } = req.params;
    const { result, score, gameData, timestamp, nonce } = req.body;
    const userId = req.user?.userId || null;
    const guestId = req.body.guestId || null;

    // Generate nonce if not provided (for backward compatibility)
    const submissionNonce = nonce || uuidv4();
    const submissionTimestamp = timestamp || Date.now();

    // Validate submission
    const validation = await validateGameSubmission({
      gameId,
      userId,
      guestId,
      result,
      score,
      gameData: gameData || {},
      timestamp: submissionTimestamp,
      nonce: submissionNonce,
    });

    if (!validation.isValid) {
      res.status(400).json({
        message: validation.reason || 'Invalid score submission',
        suspicious: validation.suspicious,
      });
      return;
    }

    // Attach validation info to request
    (req as any).scoreValidation = {
      isValid: true,
      suspicious: validation.suspicious,
      nonce: submissionNonce,
      timestamp: submissionTimestamp,
    };

    next();
  } catch (error: any) {
    res.status(500).json({
      message: 'Score validation error',
      error: error.message,
    });
  }
};

/**
 * Middleware to create game session record after score submission
 */
export const recordGameSession = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // This will be called after score is successfully submitted
    // Store session info in request for later use
    (req as any).shouldRecordSession = true;
    next();
  } catch (error) {
    // Don't block request if session recording fails
    console.error('Error in recordGameSession middleware:', error);
    next();
  }
};

/**
 * Helper to create game session after successful score submission
 */
export const createSessionAfterSubmission = async (
  gameId: string,
  userId: string | null,
  guestId: string | null,
  result: 'win' | 'loss' | 'draw',
  score: number,
  gameData: any
): Promise<string | null> => {
  try {
    const sessionId = await createGameSession(
      gameId,
      [
        {
          userId,
          guestId,
          score,
          result,
        },
      ],
      gameData,
      true
    );
    return sessionId;
  } catch (error) {
    console.error('Error creating game session:', error);
    return null;
  }
};
</file>

<file path="backend/src/models/GameHistory.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IGameHistory extends Document {
  originalGameId: string; // Reference to original game _id (if needed)
  roomId: string;
  roomCode: string;
  gameType: string;
  player1: mongoose.Types.ObjectId | null;
  player2: mongoose.Types.ObjectId | null;
  player1GuestId: string | null;
  player2GuestId: string | null;
  boardSize: number;
  board: number[][];
  winner: 1 | 2 | null | 'draw';
  winningLine?: Array<{ row: number; col: number }>;
  score: {
    player1: number;
    player2: number;
  };
  rules: {
    blockTwoEnds: boolean;
    allowUndo: boolean;
    maxUndoPerGame: number;
    timeLimit: number | null;
  };
  finishedAt: Date;
  createdAt: Date; // Original game creation date
  savedAt: Date; // When this history record was created
}

const GameHistorySchema: Schema = new Schema({
  originalGameId: {
    type: String,
    default: null,
  },
  roomId: {
    type: String,
    required: true,
    index: true,
  },
  roomCode: {
    type: String,
    required: true,
  },
  gameType: {
    type: String,
    required: true,
    default: 'caro',
    trim: true,
    lowercase: true,
  },
  player1: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    default: null,
    index: true,
  },
  player2: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    default: null,
    index: true,
  },
  player1GuestId: {
    type: String,
    default: null,
    index: true,
  },
  player2GuestId: {
    type: String,
    default: null,
    index: true,
  },
  boardSize: {
    type: Number,
    required: true,
  },
  board: {
    type: [[Number]],
    required: true,
  },
  winner: {
    type: Schema.Types.Mixed,
    default: null,
  },
  winningLine: {
    type: [{
      row: { type: Number, required: true },
      col: { type: Number, required: true },
    }],
    default: undefined,
  },
  score: {
    player1: {
      type: Number,
      default: 0,
    },
    player2: {
      type: Number,
      default: 0,
    },
  },
  rules: {
    blockTwoEnds: {
      type: Boolean,
      default: false,
    },
    allowUndo: {
      type: Boolean,
      default: true,
    },
    maxUndoPerGame: {
      type: Number,
      default: 3,
    },
    timeLimit: {
      type: Number,
      default: null,
    },
  },
  finishedAt: {
    type: Date,
    required: true,
    index: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  savedAt: {
    type: Date,
    default: Date.now,
    index: true,
  },
});

// Compound indexes for efficient queries
GameHistorySchema.index({ player1: 1, finishedAt: -1 });
GameHistorySchema.index({ player2: 1, finishedAt: -1 });
GameHistorySchema.index({ player1GuestId: 1, finishedAt: -1 });
GameHistorySchema.index({ player2GuestId: 1, finishedAt: -1 });

export default mongoose.model<IGameHistory>('GameHistory', GameHistorySchema);
</file>

<file path="backend/src/models/GameMove.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IGameMove extends Document {
  gameId: mongoose.Types.ObjectId;
  player: 1 | 2;
  row: number;
  col: number;
  moveNumber: number;
  timestamp: Date;
  isUndone: boolean;
}

const GameMoveSchema: Schema = new Schema({
  gameId: {
    type: Schema.Types.ObjectId,
    ref: 'Game',
    required: true,
  },
  player: {
    type: Number,
    enum: [1, 2],
    required: true,
  },
  row: {
    type: Number,
    required: true,
  },
  col: {
    type: Number,
    required: true,
  },
  moveNumber: {
    type: Number,
    required: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
  isUndone: {
    type: Boolean,
    default: false,
  },
});

export default mongoose.model<IGameMove>('GameMove', GameMoveSchema);
</file>

<file path="backend/src/models/GameSession.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IPlayerResult {
  userId: mongoose.Types.ObjectId | null;
  guestId: string | null;
  score: number;
  result: 'win' | 'loss' | 'draw';
}

export interface IGameSession extends Document {
  gameId: string;
  sessionId: string;
  players: IPlayerResult[];
  gameData: any; // Game-specific data (flexible schema)
  startedAt: Date;
  finishedAt: Date | null;
  duration: number; // seconds
  isValid: boolean; // For anti-cheat validation
  createdAt: Date;
}

const PlayerResultSchema: Schema = new Schema({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  guestId: {
    type: String,
    default: null,
  },
  score: {
    type: Number,
    default: 0,
  },
  result: {
    type: String,
    enum: ['win', 'loss', 'draw'],
    required: true,
  },
}, { _id: false });

const GameSessionSchema: Schema = new Schema({
  gameId: {
    type: String,
    required: true,
    trim: true,
    lowercase: true,
  },
  sessionId: {
    type: String,
    required: true,
    unique: true,
  },
  players: {
    type: [PlayerResultSchema],
    required: true,
    validate: {
      validator: (players: IPlayerResult[]) => players.length > 0,
      message: 'At least one player is required',
    },
  },
  gameData: {
    type: Schema.Types.Mixed,
    default: {},
  },
  startedAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  finishedAt: {
    type: Date,
    default: null,
  },
  duration: {
    type: Number,
    default: 0,
    min: 0,
  },
  isValid: {
    type: Boolean,
    default: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

// Indexes for efficient queries
GameSessionSchema.index({ gameId: 1, finishedAt: -1 });
GameSessionSchema.index({ 'players.userId': 1 });
GameSessionSchema.index({ sessionId: 1 });
GameSessionSchema.index({ gameId: 1, createdAt: -1 });

// Calculate duration before save if finished
GameSessionSchema.pre('save', function (next) {
  const doc = this as any;
  if (doc.finishedAt && doc.startedAt) {
    const finished = doc.finishedAt instanceof Date 
      ? doc.finishedAt 
      : new Date(doc.finishedAt);
    const started = doc.startedAt instanceof Date 
      ? doc.startedAt 
      : new Date(doc.startedAt);
    doc.duration = Math.floor((finished.getTime() - started.getTime()) / 1000);
  }
  next();
});

export default mongoose.model<IGameSession>('GameSession', GameSessionSchema);
</file>

<file path="backend/src/models/GameStats.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IGameStats extends Document {
  userId: mongoose.Types.ObjectId;
  gameId: string;
  wins: number;
  losses: number;
  draws: number;
  totalScore: number;
  customStats: Map<string, any>;
  lastPlayed: Date;
  createdAt: Date;
  updatedAt: Date;
}

const GameStatsSchema: Schema = new Schema({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  gameId: {
    type: String,
    required: true,
    trim: true,
    lowercase: true,
  },
  wins: {
    type: Number,
    default: 0,
    min: 0,
  },
  losses: {
    type: Number,
    default: 0,
    min: 0,
  },
  draws: {
    type: Number,
    default: 0,
    min: 0,
  },
  totalScore: {
    type: Number,
    default: 0,
  },
  customStats: {
    type: Map,
    of: Schema.Types.Mixed,
    default: new Map(),
  },
  lastPlayed: {
    type: Date,
    default: Date.now,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

// Unique compound index: one stats record per user per game
GameStatsSchema.index({ userId: 1, gameId: 1 }, { unique: true });

// Indexes for leaderboard queries
GameStatsSchema.index({ gameId: 1, totalScore: -1 });
GameStatsSchema.index({ gameId: 1, wins: -1 });
GameStatsSchema.index({ userId: 1 });

// Update updatedAt before save
GameStatsSchema.pre('save', function (next) {
  this.updatedAt = new Date();
  next();
});

export default mongoose.model<IGameStats>('GameStats', GameStatsSchema);
</file>

<file path="backend/src/models/GameType.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IGameType extends Document {
  gameId: string;
  name: string;
  description: string;
  isActive: boolean;
  createdAt: Date;
}

const GameTypeSchema: Schema = new Schema({
  gameId: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true,
  },
  name: {
    type: String,
    required: true,
    trim: true,
  },
  description: {
    type: String,
    default: '',
  },
  isActive: {
    type: Boolean,
    default: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

// Index for faster lookups
GameTypeSchema.index({ gameId: 1 });
GameTypeSchema.index({ isActive: 1 });

export default mongoose.model<IGameType>('GameType', GameTypeSchema);
</file>

<file path="backend/src/models/Leaderboard.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IRanking {
  userId: mongoose.Types.ObjectId;
  rank: number;
  score: number;
  wins: number;
  updatedAt: Date;
}

export interface ILeaderboard extends Document {
  gameId: string;
  period: 'daily' | 'weekly' | 'all-time';
  periodStart: Date;
  periodEnd: Date | null;
  rankings: IRanking[];
  updatedAt: Date;
}

const RankingSchema: Schema = new Schema({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  rank: {
    type: Number,
    required: true,
    min: 1,
  },
  score: {
    type: Number,
    required: true,
    default: 0,
  },
  wins: {
    type: Number,
    required: true,
    default: 0,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
}, { _id: false });

const LeaderboardSchema: Schema = new Schema({
  gameId: {
    type: String,
    required: true,
    trim: true,
    lowercase: true,
  },
  period: {
    type: String,
    enum: ['daily', 'weekly', 'all-time'],
    required: true,
  },
  periodStart: {
    type: Date,
    required: true,
  },
  periodEnd: {
    type: Date,
    default: null,
  },
  rankings: {
    type: [RankingSchema],
    default: [],
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
});

// Indexes for efficient queries
LeaderboardSchema.index({ gameId: 1, period: 1, periodStart: -1 });
LeaderboardSchema.index({ gameId: 1, period: 1 });

// Update updatedAt before save
LeaderboardSchema.pre('save', function (next) {
  this.updatedAt = new Date();
  next();
});

export default mongoose.model<ILeaderboard>('Leaderboard', LeaderboardSchema);
</file>

<file path="backend/src/routes/authRoutes.ts">
import { Router } from 'express';
import { register, login, getMe } from '../controllers/authController';
import { authMiddleware } from '../middleware/authMiddleware';

const router = Router();

router.post('/register', register);
router.post('/login', login);
router.get('/me', authMiddleware, getMe);

export default router;
</file>

<file path="backend/src/routes/gameStatsRoutes.ts">
import { Router } from 'express';
import {
  getUserGameStats,
  getMyGameStats,
  submitGameResult,
} from '../controllers/gameStatsController';
import { authMiddleware } from '../middleware/authMiddleware';
import { validateScore } from '../middleware/validateScore';
import { scoreSubmissionLimiter } from '../middleware/rateLimiter';

const router = Router();

// Get stats for a specific user and game (public)
router.get('/:gameId/stats/:userId', getUserGameStats);

// Get current user's stats for a game (protected)
router.get('/:gameId/stats/my-stats', authMiddleware, getMyGameStats);

// Submit game result (protected with validation and rate limiting)
router.post(
  '/:gameId/stats/submit',
  authMiddleware,
  scoreSubmissionLimiter,
  validateScore,
  submitGameResult
);

export default router;
</file>

<file path="backend/src/scripts/initGameTypes.ts">
/**
 * Initialize game types in database
 * Run this once after deploying new models
 */

import mongoose from 'mongoose';
import dotenv from 'dotenv';
import GameType from '../models/GameType';

dotenv.config();

const initGameTypes = async (): Promise<void> => {
  try {
    const mongoUri = process.env.MONGODB_URI;
    if (!mongoUri) {
      throw new Error('MONGODB_URI not found in environment variables');
    }

    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');

    const gameTypes = [
      {
        gameId: 'caro',
        name: 'Caro',
        description: 'Classic strategy game',
        isActive: true,
      },
      // Add more games here in the future
    ];

    for (const gameTypeData of gameTypes) {
      const existing = await GameType.findOne({ gameId: gameTypeData.gameId });
      if (!existing) {
        const gameType = new GameType(gameTypeData);
        await gameType.save();
        console.log(`Created game type: ${gameTypeData.gameId}`);
      } else {
        console.log(`Game type already exists: ${gameTypeData.gameId}`);
      }
    }

    console.log('\nGame types initialization complete!');
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  } catch (error) {
    console.error('Initialization error:', error);
    process.exit(1);
  }
};

// Run if called directly
if (require.main === module) {
  initGameTypes()
    .then(() => {
      console.log('Initialization script completed');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Initialization script failed:', error);
      process.exit(1);
    });
}

export default initGameTypes;
</file>

<file path="backend/src/scripts/migrateUserStats.ts">
/**
 * Migration script to move user stats from User model to GameStats model
 * Run this once after deploying new models
 */

import mongoose from 'mongoose';
import dotenv from 'dotenv';
import User from '../models/User';
import GameStats from '../models/GameStats';
import GameType from '../models/GameType';

dotenv.config();

const migrateUserStats = async (): Promise<void> => {
  try {
    // Connect to database
    const mongoUri = process.env.MONGODB_URI;
    if (!mongoUri) {
      throw new Error('MONGODB_URI not found in environment variables');
    }

    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');

    // Ensure 'caro' game type exists
    let caroGameType = await GameType.findOne({ gameId: 'caro' });
    if (!caroGameType) {
      caroGameType = new GameType({
        gameId: 'caro',
        name: 'Caro',
        description: 'Classic strategy game',
        isActive: true,
      });
      await caroGameType.save();
      console.log('Created caro game type');
    }

    // Get all users with stats
    const users = await User.find({
      $or: [
        { wins: { $gt: 0 } },
        { losses: { $gt: 0 } },
        { draws: { $gt: 0 } },
        { totalScore: { $gt: 0 } },
      ],
    });

    console.log(`Found ${users.length} users with stats to migrate`);

    let migrated = 0;
    let skipped = 0;

    for (const user of users) {
      // Check if GameStats already exists for this user and game
      const existingStats = await GameStats.findOne({
        userId: user._id,
        gameId: 'caro',
      });

      if (existingStats) {
        console.log(`Skipping user ${user.username} - stats already exist`);
        skipped++;
        continue;
      }

      // Create GameStats from User stats
      const gameStats = new GameStats({
        userId: user._id,
        gameId: 'caro',
        wins: user.wins || 0,
        losses: user.losses || 0,
        draws: user.draws || 0,
        totalScore: user.totalScore || 0,
        lastPlayed: user.lastLogin || new Date(),
      });

      await gameStats.save();
      migrated++;
      console.log(`Migrated stats for user ${user.username}`);
    }

    console.log(`\nMigration complete!`);
    console.log(`Migrated: ${migrated} users`);
    console.log(`Skipped: ${skipped} users`);

    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  } catch (error) {
    console.error('Migration error:', error);
    process.exit(1);
  }
};

// Run migration if called directly
if (require.main === module) {
  migrateUserStats()
    .then(() => {
      console.log('Migration script completed');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Migration script failed:', error);
      process.exit(1);
    });
}

export default migrateUserStats;
</file>

<file path="backend/src/services/antiCheatService.ts">
/**
 * Anti-cheat service for validating game submissions
 */

import GameSession from '../models/GameSession';
import GameStats from '../models/GameStats';
import { v4 as uuidv4 } from 'uuid';

export interface GameSubmission {
  gameId: string;
  userId: string | null;
  guestId: string | null;
  result: 'win' | 'loss' | 'draw';
  score?: number;
  gameData: any;
  timestamp: number;
  nonce: string;
}

export interface ValidationResult {
  isValid: boolean;
  reason?: string;
  suspicious?: boolean;
}

/**
 * Validate game submission
 */
export const validateGameSubmission = async (
  submission: GameSubmission
): Promise<ValidationResult> => {
  try {
    // 1. Check nonce (replay attack prevention)
    const nonceCheck = await checkNonce(submission.nonce, submission.timestamp);
    if (!nonceCheck.isValid) {
      return {
        isValid: false,
        reason: nonceCheck.reason,
        suspicious: true,
      };
    }

    // 2. Check timestamp (prevent old submissions)
    const timestampCheck = checkTimestamp(submission.timestamp);
    if (!timestampCheck.isValid) {
      return {
        isValid: false,
        reason: timestampCheck.reason,
        suspicious: true,
      };
    }

    // 3. Check rate limiting
    const rateLimitCheck = await checkRateLimit(submission.userId, submission.guestId);
    if (!rateLimitCheck.isValid) {
      return {
        isValid: false,
        reason: rateLimitCheck.reason,
        suspicious: true,
      };
    }

    // 4. Validate score is reasonable
    const scoreCheck = validateScore(submission.score, submission.result);
    if (!scoreCheck.isValid) {
      return {
        isValid: false,
        reason: scoreCheck.reason,
        suspicious: true,
      };
    }

    // 5. Check for suspicious patterns
    const patternCheck = await checkSuspiciousPatterns(submission);
    if (patternCheck.suspicious) {
      return {
        isValid: false,
        reason: patternCheck.reason,
        suspicious: true,
      };
    }

    return { isValid: true };
  } catch (error: any) {
    return {
      isValid: false,
      reason: `Validation error: ${error.message}`,
      suspicious: true,
    };
  }
};

/**
 * Check if nonce is valid and not reused
 * In production, use Redis for this
 */
const nonceCache = new Map<string, number>(); // In-memory cache (use Redis in production)
const NONCE_TTL = 5 * 60 * 1000; // 5 minutes

async function checkNonce(nonce: string, timestamp: number): Promise<ValidationResult> {
  if (!nonce || typeof nonce !== 'string') {
    return {
      isValid: false,
      reason: 'Nonce is required',
    };
  }

  // Check if nonce was already used
  const existingTimestamp = nonceCache.get(nonce);
  if (existingTimestamp) {
    return {
      isValid: false,
      reason: 'Nonce already used (replay attack detected)',
    };
  }

  // Store nonce with TTL
  nonceCache.set(nonce, timestamp);
  setTimeout(() => {
    nonceCache.delete(nonce);
  }, NONCE_TTL);

  return { isValid: true };
}

/**
 * Check if timestamp is within acceptable range
 */
function checkTimestamp(timestamp: number): ValidationResult {
  const now = Date.now();
  const timeDiff = Math.abs(now - timestamp);

  // Allow submissions within 5 minutes
  if (timeDiff > 5 * 60 * 1000) {
    return {
      isValid: false,
      reason: 'Timestamp too old or too far in future',
    };
  }

  return { isValid: true };
}

/**
 * Check rate limiting
 */
const rateLimitCache = new Map<string, { count: number; resetAt: number }>();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
const RATE_LIMIT_MAX = 10; // Max 10 submissions per minute

async function checkRateLimit(
  userId: string | null,
  guestId: string | null
): Promise<ValidationResult> {
  const identifier = userId || guestId || 'unknown';
  const now = Date.now();

  const limit = rateLimitCache.get(identifier);

  if (!limit || now > limit.resetAt) {
    // Reset or create new limit
    rateLimitCache.set(identifier, {
      count: 1,
      resetAt: now + RATE_LIMIT_WINDOW,
    });
    return { isValid: true };
  }

  if (limit.count >= RATE_LIMIT_MAX) {
    return {
      isValid: false,
      reason: 'Rate limit exceeded. Please wait before submitting again.',
    };
  }

  limit.count++;
  return { isValid: true };
}

/**
 * Validate score is reasonable
 */
function validateScore(score: number | undefined, result: string): ValidationResult {
  if (score === undefined) {
    // Score is optional, will be calculated on server
    return { isValid: true };
  }

  if (typeof score !== 'number' || !isFinite(score)) {
    return {
      isValid: false,
      reason: 'Invalid score format',
    };
  }

  // Check for suspiciously high scores
  if (score > 1000000) {
    return {
      isValid: false,
      reason: 'Score too high (suspicious)',
      suspicious: true,
    };
  }

  // Check for negative scores (unless allowed)
  if (score < 0 && result !== 'loss') {
    return {
      isValid: false,
      reason: 'Invalid score for result type',
    };
  }

  return { isValid: true };
}

/**
 * Check for suspicious patterns
 */
async function checkSuspiciousPatterns(submission: GameSubmission): Promise<ValidationResult> {
  // 1. Check for too many wins in short time
  if (submission.result === 'win' && submission.userId) {
    const recentWins = await GameStats.findOne({ userId: submission.userId, gameId: submission.gameId });
    if (recentWins) {
      const winRate = recentWins.wins / (recentWins.wins + recentWins.losses + recentWins.draws || 1);
      // Suspicious if win rate > 95% with significant games
      if (winRate > 0.95 && (recentWins.wins + recentWins.losses) > 20) {
        return {
          isValid: true, // Still valid, but flagged
          suspicious: true,
          reason: 'Unusually high win rate detected',
        };
      }
    }
  }

  // 2. Check for rapid submissions
  const recentSessions = await GameSession.countDocuments({
    $or: [
      { 'players.userId': submission.userId },
      { 'players.guestId': submission.guestId },
    ],
    finishedAt: {
      $gte: new Date(Date.now() - 60 * 1000), // Last minute
    },
  });

  if (recentSessions > 5) {
    return {
      isValid: true, // Still valid, but flagged
      suspicious: true,
      reason: 'Too many games finished in short time',
    };
  }

  return { isValid: true };
}

/**
 * Create a game session record for audit trail
 */
export const createGameSession = async (
  gameId: string,
  players: Array<{ userId: string | null; guestId: string | null; score: number; result: 'win' | 'loss' | 'draw' }>,
  gameData: any,
  isValid: boolean = true
): Promise<string> => {
  const sessionId = uuidv4();
  const startedAt = new Date(Date.now() - 5 * 60 * 1000); // Assume game took 5 minutes (adjust based on actual)
  const finishedAt = new Date();

  await GameSession.create({
    gameId,
    sessionId,
    players,
    gameData,
    startedAt,
    finishedAt,
    duration: Math.floor((finishedAt.getTime() - startedAt.getTime()) / 1000),
    isValid,
  });

  return sessionId;
};

/**
 * Mark game session as invalid (cheat detected)
 */
export const markSessionInvalid = async (sessionId: string): Promise<void> => {
  await GameSession.updateOne(
    { sessionId },
    { isValid: false }
  );
};
</file>

<file path="backend/src/types/game.types.ts">
export type PlayerNumber = 1 | 2;
export type GameStatus = 'waiting' | 'playing' | 'finished' | 'abandoned';
export type Winner = PlayerNumber | null | 'draw';
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="frontend/public/manifest.json">
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="frontend/public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="frontend/src/components/HistoryModal/HistoryModal.tsx">
import React, { useState, useEffect, useRef } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  List,
  ListItem,
  ListItemButton,
  Chip,
  CircularProgress,
  Paper,
  IconButton,
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { gameApi } from '../../services/api';
import { GameHistory } from '../../types/game.types';
import { logger } from '../../utils/logger';

interface HistoryModalProps {
  open: boolean;
  onClose: () => void;
}

const HistoryModal: React.FC<HistoryModalProps> = ({ open, onClose }) => {
  const [history, setHistory] = useState<GameHistory[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedGame, setSelectedGame] = useState<GameHistory | null>(null);
  const [viewMode, setViewMode] = useState<'list' | 'board'>('list');

  useEffect(() => {
    if (open) {
      loadHistory();
    } else {
      // Reset when modal closes
      setHistory([]);
      setSelectedGame(null);
      setViewMode('list');
    }
  }, [open]);

  const loadHistory = async (): Promise<void> => {
    setLoading(true);
    try {
      logger.log('[HistoryModal] Loading game history...');
      const data = await gameApi.getGameHistory();
      logger.log('[HistoryModal] History loaded:', data);
      setHistory(data.history || []);
    } catch (error: any) {
      logger.error('[HistoryModal] Failed to load game history:', error);
      logger.error('[HistoryModal] Error details:', error.response?.data || error.message);
      setHistory([]);
    } finally {
      setLoading(false);
    }
  };

  const handleViewBoard = (game: GameHistory): void => {
    setSelectedGame(game);
    setViewMode('board');
  };

  const handleBackToList = (): void => {
    setViewMode('list');
    setSelectedGame(null);
  };

  const getResultColor = (result: 'win' | 'loss' | 'draw'): string => {
    switch (result) {
      case 'win':
        return '#a8e6cf';
      case 'loss':
        return '#ffaaa5';
      case 'draw':
        return '#ffd93d';
      default:
        return '#8a9ba8';
    }
  };

  const getResultLabel = (result: 'win' | 'loss' | 'draw'): string => {
    switch (result) {
      case 'win':
        return 'Win';
      case 'loss':
        return 'Loss';
      case 'draw':
        return 'Draw';
      default:
        return 'Unknown';
    }
  };

  const formatDate = (dateString: string): string => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 4,
          background: 'rgba(232, 235, 239, 0.98)',
          backdropFilter: 'blur(8px)',
          WebkitBackdropFilter: 'blur(8px)',
        },
      }}
    >
      <DialogTitle
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          pb: 2,
          borderBottom: '2px solid rgba(126, 200, 227, 0.2)',
        }}
      >
        <Typography variant="h5" sx={{ fontWeight: 700, color: '#2c3e50' }}>
          {viewMode === 'list' ? 'üìú Game History' : 'üéØ Game Board'}
        </Typography>
        {viewMode === 'board' && (
          <Button
            onClick={handleBackToList}
            size="small"
            sx={{ textTransform: 'none', fontWeight: 600 }}
          >
            ‚Üê Back to List
          </Button>
        )}
        <IconButton onClick={onClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <DialogContent sx={{ p: 0 }}>
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', py: 8 }}>
            <CircularProgress />
          </Box>
        ) : viewMode === 'list' ? (
          <Box sx={{ maxHeight: '60vh', overflowY: 'auto' }}>
            {history.length === 0 ? (
              <Box sx={{ p: 4, textAlign: 'center' }}>
                <Typography variant="body1" sx={{ color: '#8a9ba8' }}>
                  No game history found. Play some games to see your history here!
                </Typography>
              </Box>
            ) : (
              <List sx={{ p: 0 }}>
                {history.map((game, index) => (
                  <ListItem
                    key={game._id}
                    disablePadding
                    sx={{
                      borderBottom: '1px solid rgba(126, 200, 227, 0.1)',
                      '&:last-child': { borderBottom: 'none' },
                    }}
                  >
                    <ListItemButton
                      onClick={() => handleViewBoard(game)}
                      sx={{
                        py: 2,
                        px: 3,
                        '&:hover': {
                          bgcolor: 'rgba(126, 200, 227, 0.08)',
                        },
                      }}
                    >
                      <Box sx={{ flex: 1, display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Box
                          sx={{
                            width: 48,
                            height: 48,
                            borderRadius: 2,
                            bgcolor: getResultColor(game.result),
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontWeight: 700,
                            color: '#2c3e50',
                            fontSize: '0.9rem',
                          }}
                        >
                          {index + 1}
                        </Box>
                        <Box sx={{ flex: 1 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                            <Chip
                              label={getResultLabel(game.result)}
                              size="small"
                              sx={{
                                bgcolor: getResultColor(game.result),
                                color: '#2c3e50',
                                fontWeight: 700,
                                fontSize: '0.75rem',
                                height: 24,
                              }}
                            />
                            <Typography variant="body2" sx={{ color: '#8a9ba8', fontSize: '0.8rem' }}>
                              vs {game.opponentUsername}
                            </Typography>
                          </Box>
                          <Typography variant="caption" sx={{ color: '#8a9ba8', fontSize: '0.75rem' }}>
                            {formatDate(game.finishedAt || game.createdAt)} ‚Ä¢ {game.boardSize}x{game.boardSize} board
                          </Typography>
                        </Box>
                        <Typography variant="body2" sx={{ color: '#5a6a7a', fontWeight: 600 }}>
                          Score: {game.score.player1} - {game.score.player2}
                        </Typography>
                      </Box>
                    </ListItemButton>
                  </ListItem>
                ))}
              </List>
            )}
          </Box>
        ) : selectedGame ? (
          <Box sx={{ p: 3 }}>
            <Paper
              elevation={0}
              sx={{
                p: 3,
                mb: 2,
                bgcolor: 'rgba(255, 255, 255, 0.8)',
                borderRadius: 3,
              }}
            >
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 700, color: '#2c3e50', mb: 0.5 }}>
                    Game Details
                  </Typography>
                  <Typography variant="body2" sx={{ color: '#8a9ba8' }}>
                    {formatDate(selectedGame.finishedAt || selectedGame.createdAt)}
                  </Typography>
                </Box>
                <Chip
                  label={getResultLabel(selectedGame.result)}
                  sx={{
                    bgcolor: getResultColor(selectedGame.result),
                    color: '#2c3e50',
                    fontWeight: 700,
                  }}
                />
              </Box>
              <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
                <Box>
                  <Typography variant="caption" sx={{ color: '#8a9ba8', display: 'block' }}>
                    Opponent
                  </Typography>
                  <Typography variant="body2" sx={{ fontWeight: 600, color: '#2c3e50' }}>
                    {selectedGame.opponentUsername}
                  </Typography>
                </Box>
                <Box>
                  <Typography variant="caption" sx={{ color: '#8a9ba8', display: 'block' }}>
                    Board Size
                  </Typography>
                  <Typography variant="body2" sx={{ fontWeight: 600, color: '#2c3e50' }}>
                    {selectedGame.boardSize}x{selectedGame.boardSize}
                  </Typography>
                </Box>
                <Box>
                  <Typography variant="caption" sx={{ color: '#8a9ba8', display: 'block' }}>
                    Final Score
                  </Typography>
                  <Typography variant="body2" sx={{ fontWeight: 600, color: '#2c3e50' }}>
                    {selectedGame.score.player1} - {selectedGame.score.player2}
                  </Typography>
                </Box>
              </Box>
            </Paper>
            <Box
              sx={{
                display: 'flex',
                justifyContent: 'center',
                bgcolor: 'rgba(255, 255, 255, 0.8)',
                borderRadius: 3,
                p: 2,
              }}
            >
              <GameBoardStatic 
                board={selectedGame.board} 
                boardSize={selectedGame.boardSize}
                winningLine={selectedGame.winningLine}
              />
            </Box>
          </Box>
        ) : null}
      </DialogContent>

      <DialogActions sx={{ p: 2, borderTop: '1px solid rgba(126, 200, 227, 0.1)' }}>
        <Button onClick={onClose} variant="contained" sx={{ textTransform: 'none', fontWeight: 600 }}>
          Close
        </Button>
      </DialogActions>
    </Dialog>
  );
};

// Static GameBoard component for viewing finished games
interface GameBoardStaticProps {
  board: number[][];
  boardSize: number;
  winningLine?: Array<{ row: number; col: number }>;
}

const GameBoardStatic: React.FC<GameBoardStaticProps> = ({ board, boardSize, winningLine }) => {
  const [cellSize, setCellSize] = useState(30);
  const boardRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Calculate cell size based on board size
    const maxSize = Math.min(500, window.innerWidth * 0.6);
    const calculatedSize = Math.floor(maxSize / boardSize);
    setCellSize(Math.max(20, Math.min(calculatedSize, 40)));
  }, [boardSize]);

  const getCellContent = (value: number): string => {
    if (value === 1) return '‚úï';
    if (value === 2) return '‚óã';
    return '';
  };

  const getCellColor = (value: number): string => {
    if (value === 1) return '#5ba8c7';
    if (value === 2) return '#88d6b7';
    return 'transparent';
  };

  const isWinningCell = (row: number, col: number): boolean => {
    return winningLine?.some((line) => line.row === row && line.col === col) || false;
  };

  return (
    <Box
      sx={{
        position: 'relative',
        display: 'grid',
        gridTemplateColumns: `repeat(${boardSize}, 1fr)`,
        gap: 0,
        border: '3px solid #7ec8e3',
        borderRadius: 2,
        overflow: 'hidden',
        boxShadow: 'inset 0 2px 8px rgba(126, 200, 227, 0.1)',
      }}
      ref={boardRef}
    >
      {board.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
          const winning = isWinningCell(rowIndex, colIndex);
          return (
            <Box
              key={`${rowIndex}-${colIndex}`}
              sx={{
                width: `${cellSize}px`,
                height: `${cellSize}px`,
                minWidth: `${cellSize}px`,
                minHeight: `${cellSize}px`,
                border: winning
                  ? '3px solid #ff6b6b'
                  : '1px solid rgba(126, 200, 227, 0.3)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                backgroundColor: '#ffffff',
                background: winning && cell !== 0
                  ? `linear-gradient(135deg, rgba(255, 107, 107, 0.25) 0%, rgba(255, 107, 107, 0.35) 100%)`
                  : '#ffffff',
                fontSize: `${cellSize * 0.65}px`,
                fontWeight: 800,
                color: getCellColor(cell),
                boxShadow: winning
                  ? '0 0 12px rgba(255, 107, 107, 0.5), inset 0 0 6px rgba(255, 107, 107, 0.2)'
                  : 'none',
              }}
            >
              {getCellContent(cell)}
            </Box>
          );
        })
      )}
      {/* Winning line overlay */}
      {winningLine && winningLine.length >= 2 && (
        <svg
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            pointerEvents: 'none',
            zIndex: 10,
          }}
        >
          <line
            x1={(winningLine[0].col + 0.5) * cellSize}
            y1={(winningLine[0].row + 0.5) * cellSize}
            x2={(winningLine[winningLine.length - 1].col + 0.5) * cellSize}
            y2={(winningLine[winningLine.length - 1].row + 0.5) * cellSize}
            stroke="#ff6b6b"
            strokeWidth={4}
            strokeLinecap="round"
            opacity={0.8}
          />
        </svg>
      )}
    </Box>
  );
};

export default HistoryModal;
</file>

<file path="frontend/src/types/user.types.ts">
export interface User {
  _id: string;
  username: string;
  email: string;
  wins: number;
  losses: number;
  draws: number;
  totalScore: number;
  createdAt: string;
  lastLogin: string;
}

export interface AuthResponse {
  token: string;
  user: User;
}
</file>

<file path="frontend/src/utils/guestId.ts">
// Per-tab instance cache - each tab gets its own unique guest ID
// Use sessionStorage to persist guest ID across page reloads in the same tab
const GUEST_ID_KEY = 'caro_guest_id';

export const getGuestId = (): string => {
  // Try to get from sessionStorage first
  let guestId = sessionStorage.getItem(GUEST_ID_KEY);
  
  if (!guestId) {
    // Generate new guest ID
    guestId = `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    // Store in sessionStorage for persistence
    sessionStorage.setItem(GUEST_ID_KEY, guestId);
  }
  
  return guestId;
};
</file>

<file path="frontend/src/utils/roomCode.ts">
export const validateRoomCode = (code: string): boolean => {
  return /^[A-Z0-9]{6}$/.test(code.toUpperCase());
};

export const formatRoomCode = (code: string): string => {
  return code.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
};
</file>

<file path="frontend/src/App.css">
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</file>

<file path="frontend/src/App.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
</file>

<file path="frontend/src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="frontend/src/index.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
</file>

<file path="frontend/src/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
</file>

<file path="frontend/src/react-app-env.d.ts">
/// <reference types="react-scripts" />
</file>

<file path="frontend/src/reportWebVitals.ts">
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="frontend/src/setupTests.ts">
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}
</file>

<file path=".gitignore">
# OS
.DS_Store
Thumbs.db

# IDEs
.idea/
.vscode/
*.swp
*.swo
*~

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dependencies
node_modules/
frontend/node_modules/

# Build outputs
frontend/build/
frontend/dist/
backend/target/
backend/.mvn/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Testing
coverage/
.nyc_output/

/.claude/
</file>

<file path="MIGRATION_GUIDE.md">
# Migration Guide - Game Hub Architecture

This guide explains how to migrate from the old single-game architecture to the new multi-game hub architecture.

## Prerequisites

- MongoDB database connection
- Node.js and npm installed
- Backend dependencies installed (`npm install` in `backend/`)

## Migration Steps

### Step 1: Initialize Game Types

First, create the game types in the database:

```bash
cd backend
npm run init:gametypes
```

This will create the `caro` game type. You can add more game types later by editing `backend/src/scripts/initGameTypes.ts`.

### Step 2: Migrate User Stats

Migrate existing user statistics from the `User` model to the new `GameStats` model:

```bash
cd backend
npm run migrate:stats
```

This script will:
- Find all users with wins/losses/draws/totalScore > 0
- Create corresponding `GameStats` records for the `caro` game
- Skip users that already have stats (safe to run multiple times)

### Step 3: Deploy Backend

Deploy the updated backend to Render. The new models and APIs will be available.

### Step 4: Deploy Frontend

Deploy the updated frontend to Vercel. The new UI will use the new APIs.

## Database Changes

### New Collections

1. **GameTypes**: Stores game definitions
2. **GameStats**: Stores per-game statistics for each user
3. **Leaderboard**: Cached leaderboard data for performance
4. **GameSession**: Audit trail for game sessions
5. **RefreshToken**: Stores refresh tokens for JWT authentication

### Modified Collections

1. **Users**: Legacy fields (wins, losses, draws, totalScore) kept for backward compatibility
2. **Games**: Added `gameType` field to identify the game

## API Changes

### New Endpoints

- `GET /api/games/:gameId/stats/:userId` - Get user stats for a game
- `GET /api/games/:gameId/stats/my-stats` - Get current user's stats
- `POST /api/games/:gameId/stats/submit` - Submit game result
- `GET /api/leaderboard/:gameId` - Get leaderboard for a game
- `GET /api/leaderboard/:gameId/rank/:userId` - Get user's rank
- `GET /api/users/:userId/games` - Get all game stats for a user
- `POST /api/auth/refresh` - Refresh access token
- `POST /api/auth/logout` - Logout and invalidate refresh token

### Updated Endpoints

- `GET /api/leaderboard/top` - Still works, but now supports `gameId` query parameter
- `GET /api/users/:userId/profile` - Returns user profile (legacy stats included for compatibility)

## Environment Variables

No new environment variables required. Existing variables work:
- `MONGODB_URI`
- `JWT_SECRET`
- `JWT_REFRESH_SECRET` (optional, defaults to JWT_SECRET)
- `JWT_EXPIRES_IN` (optional, defaults to 24h)
- `JWT_REFRESH_EXPIRES_IN` (optional, defaults to 7d)

## Rollback Plan

If you need to rollback:

1. The legacy `User.wins/losses/draws/totalScore` fields are still present
2. Old API endpoints still work (backward compatible)
3. Frontend can be reverted to previous version
4. New collections can be dropped if needed (but data will be lost)

## Testing

After migration:

1. Test user login/register (should work as before)
2. Play a game and verify stats are saved to `GameStats`
3. Check leaderboard shows correct rankings
4. Verify profile page shows game-specific stats

## Adding New Games

To add a new game:

1. Add game type to `backend/src/scripts/initGameTypes.ts`
2. Run `npm run init:gametypes`
3. Create game-specific logic in `backend/src/games/{gameId}/`
4. Add frontend components for the new game
5. Update `HomePage.tsx` to include the new game in the sidebar

## Notes

- Migration scripts are idempotent (safe to run multiple times)
- Legacy user stats are kept for backward compatibility
- New games will automatically use the new stats system
- Leaderboard caching improves performance but may show slightly stale data (refreshes automatically)
</file>

<file path="SYSTEM_ARCHITECTURE.md">
# Game Hub System Architecture

## T·ªïng quan h·ªá th·ªëng

H·ªá th·ªëng Game Hub l√† m·ªôt n·ªÅn t·∫£ng web cho ph√©p ng∆∞·ªùi d√πng ch∆°i nhi·ªÅu mini-game, v·ªõi Caro (Tic-Tac-Toe) l√† game ƒë·∫ßu ti√™n. H·ªá th·ªëng ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ d·ªÖ d√†ng m·ªü r·ªông v·ªõi c√°c game m·ªõi trong t∆∞∆°ng lai.

### Tech Stack

**Frontend:**
- React 18 v·ªõi TypeScript
- Material-UI (MUI) cho UI components
- React Router v7 (Data Router) cho navigation
- Socket.io-client cho real-time communication
- Context API cho state management

**Backend:**
- Node.js v·ªõi Express.js
- TypeScript
- MongoDB v·ªõi Mongoose
- Socket.io Server cho real-time communication
- JWT cho authentication (single access token, 7 days expiry)
- bcryptjs cho password hashing

**Deployment:**
- Frontend: Vercel
- Backend: Railway/Render
- Database: MongoDB Atlas

---

## 1. System Architecture

### 1.1 Ki·∫øn tr√∫c t·ªïng th·ªÉ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend      ‚îÇ
‚îÇ   (React)       ‚îÇ
‚îÇ   Vercel        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ HTTP/REST + WebSocket
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Backend       ‚îÇ
‚îÇ   (Express)     ‚îÇ
‚îÇ   Railway/Render‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   MongoDB       ‚îÇ
‚îÇ   Atlas         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1.2 Ki·∫øn tr√∫c Monolith v·ªõi Modular Design

H·ªá th·ªëng s·ª≠ d·ª•ng ki·∫øn tr√∫c monolith nh∆∞ng ƒë∆∞·ª£c t·ªï ch·ª©c theo module ƒë·ªÉ d·ªÖ m·ªü r·ªông:

```
backend/src/
‚îú‚îÄ‚îÄ controllers/     # Route handlers
‚îú‚îÄ‚îÄ services/        # Business logic
‚îú‚îÄ‚îÄ models/          # Database models
‚îú‚îÄ‚îÄ routes/          # Express routes
‚îú‚îÄ‚îÄ middleware/      # Express middleware
‚îú‚îÄ‚îÄ config/         # Configuration
‚îî‚îÄ‚îÄ utils/          # Utility functions
```

### 1.3 Authentication Flow

**Single Access Token Approach:**
- User ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω ‚Üí Nh·∫≠n access token (JWT)
- Token c√≥ th·ªùi h·∫°n 7 ng√†y
- Token ƒë∆∞·ª£c l∆∞u trong localStorage (frontend)
- M·ªói request g·ª≠i token trong header: `Authorization: Bearer <token>`
- Token h·∫øt h·∫°n ‚Üí User ph·∫£i ƒëƒÉng nh·∫≠p l·∫°i

**Kh√¥ng s·ª≠ d·ª•ng Refresh Token:**
- ƒê√£ lo·∫°i b·ªè c∆° ch·∫ø refresh token ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a
- Token ƒë∆∞·ª£c t·∫°o v·ªõi `expiresIn: '7d'`

---

## 2. Database Design

### 2.1 ERD (Entity Relationship Diagram)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    User     ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)    ‚îÇ
‚îÇ username    ‚îÇ
‚îÇ email       ‚îÇ
‚îÇ password    ‚îÇ
‚îÇ wins        ‚îÇ (legacy)
‚îÇ losses      ‚îÇ (legacy)
‚îÇ draws       ‚îÇ (legacy)
‚îÇ totalScore  ‚îÇ (legacy)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 1:N
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    GameStats        ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)            ‚îÇ
‚îÇ userId (FK)         ‚îÇ
‚îÇ gameId              ‚îÇ
‚îÇ wins                ‚îÇ
‚îÇ losses              ‚îÇ
‚îÇ draws               ‚îÇ
‚îÇ totalScore          ‚îÇ
‚îÇ customStats (Map)   ‚îÇ
‚îÇ lastPlayed          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ N:1
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    GameType         ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)            ‚îÇ
‚îÇ gameId (unique)     ‚îÇ
‚îÇ name                ‚îÇ
‚îÇ description         ‚îÇ
‚îÇ isActive            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Game      ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)    ‚îÇ
‚îÇ roomId      ‚îÇ
‚îÇ roomCode    ‚îÇ
‚îÇ gameType    ‚îÇ
‚îÇ player1     ‚îÇ
‚îÇ player2     ‚îÇ
‚îÇ board       ‚îÇ
‚îÇ gameStatus  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 1:N
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   GameSession       ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)            ‚îÇ
‚îÇ gameId              ‚îÇ
‚îÇ sessionId (unique)  ‚îÇ
‚îÇ players[]           ‚îÇ
‚îÇ gameData            ‚îÇ
‚îÇ startedAt           ‚îÇ
‚îÇ finishedAt          ‚îÇ
‚îÇ duration            ‚îÇ
‚îÇ isValid             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Leaderboard ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ _id (PK)    ‚îÇ
‚îÇ gameId      ‚îÇ
‚îÇ period      ‚îÇ
‚îÇ periodStart ‚îÇ
‚îÇ periodEnd   ‚îÇ
‚îÇ rankings[]  ‚îÇ
‚îÇ updatedAt   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Database Models

#### 2.2.1 User Model
```typescript
interface IUser {
  _id: ObjectId;
  username: string;
  email: string;
  password: string; // hashed
  wins: number; // legacy, kept for backward compatibility
  losses: number; // legacy
  draws: number; // legacy
  totalScore: number; // legacy
  createdAt: Date;
  lastLogin: Date;
}
```

**Indexes:**
- `{ email: 1 }` (unique)
- `{ username: 1 }` (unique)

#### 2.2.2 GameType Model
```typescript
interface IGameType {
  _id: ObjectId;
  gameId: string; // unique, lowercase (e.g., 'caro')
  name: string; // Display name (e.g., 'C·ªù Caro')
  description: string;
  isActive: boolean;
  createdAt: Date;
}
```

**Indexes:**
- `{ gameId: 1 }` (unique)
- `{ isActive: 1 }`

#### 2.2.3 GameStats Model
```typescript
interface IGameStats {
  _id: ObjectId;
  userId: ObjectId; // FK to User
  gameId: string; // FK to GameType
  wins: number;
  losses: number;
  draws: number;
  totalScore: number;
  customStats: Map<string, any>; // Game-specific stats
  lastPlayed: Date;
  createdAt: Date;
  updatedAt: Date;
}
```

**Indexes:**
- `{ userId: 1, gameId: 1 }` (unique compound)
- `{ gameId: 1, totalScore: -1 }` (for leaderboard)
- `{ gameId: 1, wins: -1 }` (for leaderboard)
- `{ userId: 1 }` (for user queries)

#### 2.2.4 Leaderboard Model
```typescript
interface IRanking {
  userId: ObjectId;
  rank: number;
  score: number;
  wins: number;
  updatedAt: Date;
}

interface ILeaderboard {
  _id: ObjectId;
  gameId: string;
  period: 'daily' | 'weekly' | 'all-time';
  periodStart: Date;
  periodEnd: Date | null;
  rankings: IRanking[];
  updatedAt: Date;
}
```

**Indexes:**
- `{ gameId: 1, period: 1, periodStart: -1 }`
- `{ gameId: 1, period: 1 }`

**Caching Strategy:**
- Daily leaderboard: Refresh m·ªói 1 gi·ªù
- Weekly leaderboard: Refresh m·ªói 6 gi·ªù
- All-time: Query tr·ª±c ti·∫øp t·ª´ GameStats (kh√¥ng cache)

#### 2.2.5 GameSession Model
```typescript
interface IPlayerResult {
  userId: ObjectId | null;
  guestId: string | null;
  score: number;
  result: 'win' | 'loss' | 'draw';
}

interface IGameSession {
  _id: ObjectId;
  gameId: string;
  sessionId: string; // unique UUID
  players: IPlayerResult[];
  gameData: any; // Flexible schema for game-specific data
  startedAt: Date;
  finishedAt: Date | null;
  duration: number; // seconds (calculated)
  isValid: boolean; // For anti-cheat validation
  createdAt: Date;
}
```

**Indexes:**
- `{ gameId: 1, finishedAt: -1 }`
- `{ 'players.userId': 1 }`
- `{ sessionId: 1 }` (unique)
- `{ gameId: 1, createdAt: -1 }`

**Auto-calculation:**
- `duration` ƒë∆∞·ª£c t√≠nh t·ª± ƒë·ªông khi `finishedAt` ƒë∆∞·ª£c set

#### 2.2.6 Game Model (Existing)
```typescript
interface IGame {
  _id: ObjectId;
  roomId: string; // unique
  roomCode: string; // unique, 6 chars, uppercase
  gameType: string; // 'caro' (default)
  player1: ObjectId | null;
  player2: ObjectId | null;
  player1GuestId: string | null;
  player2GuestId: string | null;
  boardSize: number;
  board: number[][];
  currentPlayer: 1 | 2;
  gameStatus: 'waiting' | 'playing' | 'finished' | 'abandoned';
  winner: 1 | 2 | 'draw' | null;
  rules: GameRules;
  score: GameScore;
  createdAt: Date;
  updatedAt: Date;
  finishedAt: Date | null;
}
```

---

## 3. API Design

### 3.1 Authentication APIs

**Base Path:** `/api/auth`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| POST | `/register` | No | ƒêƒÉng k√Ω user m·ªõi |
| POST | `/login` | No | ƒêƒÉng nh·∫≠p, nh·∫≠n JWT token |
| GET | `/me` | Yes | L·∫•y th√¥ng tin user hi·ªán t·∫°i |

**Request/Response Examples:**

```typescript
// POST /api/auth/register
Request: {
  username: string;
  email: string;
  password: string;
}

Response: {
  token: string; // JWT access token
  user: {
    _id: string;
    username: string;
    email: string;
    wins: number;
    losses: number;
    draws: number;
    totalScore: number;
    createdAt: Date;
    lastLogin: Date;
  }
}

// POST /api/auth/login
Request: {
  email: string;
  password: string;
}

Response: {
  token: string; // JWT access token (7 days expiry)
  user: User
}
```

### 3.2 Game Stats APIs

**Base Path:** `/api/games/:gameId/stats`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| GET | `/:gameId/stats/:userId` | No | L·∫•y stats c·ªßa user cho game |
| GET | `/:gameId/stats/my-stats` | Yes | L·∫•y stats c·ªßa user hi·ªán t·∫°i |
| POST | `/:gameId/stats/submit` | Yes | Submit k·∫øt qu·∫£ game (c√≥ validation) |

**Request/Response Examples:**

```typescript
// POST /api/games/caro/stats/submit
Request: {
  result: 'win' | 'loss' | 'draw';
  score?: number; // Optional, server calculates if not provided
  gameData?: {
    roomId: string;
    roomCode: string;
    boardSize: number;
    // ... other game-specific data
  };
  timestamp: number; // Unix timestamp
  nonce: string; // UUID for replay attack prevention
}

Response: {
  success: boolean;
  stats: {
    wins: number;
    losses: number;
    draws: number;
    totalScore: number;
  };
  sessionId?: string; // GameSession ID if created
}
```

**Validation Middleware:**
- `validateScore`: Ki·ªÉm tra nonce, timestamp, rate limit, score reasonableness
- `scoreSubmissionLimiter`: Rate limiting (10 requests/minute)

### 3.3 Leaderboard APIs

**Base Path:** `/api/leaderboard`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| GET | `/:gameId` | No | L·∫•y leaderboard (daily/weekly/all-time) |
| GET | `/:gameId/rank/:userId` | No | L·∫•y rank c·ªßa user |
| GET | `/:gameId/around/:userId` | No | L·∫•y players xung quanh user rank |
| GET | `/top` | No | Legacy endpoint (backward compatible) |

**Query Parameters:**
- `period`: `'daily' | 'weekly' | 'all-time'` (default: `'all-time'`)
- `limit`: number (default: 50)
- `offset`: number (default: 0)
- `range`: number (for `/around/:userId`, default: 5)

**Response Example:**

```typescript
// GET /api/leaderboard/caro?period=daily&limit=10
Response: {
  gameId: 'caro';
  period: 'daily';
  rankings: [
    {
      rank: 1;
      userId: string;
      username: string;
      score: number;
      wins: number;
    }
  ];
  limit: 10;
  offset: 0;
  total: number;
}
```

### 3.4 Game APIs (Existing)

**Base Path:** `/api/games`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| POST | `/create` | No | T·∫°o game m·ªõi |
| GET | `/:roomId` | No | L·∫•y game state |
| POST | `/:roomId/join` | No | Join game |
| POST | `/:roomId/leave` | No | Leave game |
| GET | `/user/:userId` | No | L·∫•y games c·ªßa user |
| GET | `/waiting` | No | L·∫•y danh s√°ch games ƒëang ch·ªù |

### 3.5 User APIs

**Base Path:** `/api/users`

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| GET | `/:userId` | No | L·∫•y user profile |
| GET | `/:userId/games` | No | L·∫•y t·∫•t c·∫£ game stats c·ªßa user |
| PUT | `/:userId` | Yes | Update profile (ch·ªâ user hi·ªán t·∫°i) |

---

## 4. Authentication & Authorization

### 4.1 JWT Token Structure

```typescript
interface TokenPayload {
  userId: string;
  username: string;
}

// Token ƒë∆∞·ª£c t·∫°o v·ªõi:
jwt.sign(payload, JWT_SECRET, {
  expiresIn: '7d' // 7 days
});
```

### 4.2 Middleware

**authMiddleware:**
- Ki·ªÉm tra `Authorization: Bearer <token>` header
- Verify token v·ªõi `JWT_SECRET`
- Attach `user` object v√†o `req.user`

```typescript
interface AuthRequest extends Request {
  user?: {
    userId: string;
    username: string;
  };
}
```

### 4.3 API Protection

**Protected Endpoints:**
- T·∫•t c·∫£ endpoints c√≥ `authMiddleware` y√™u c·∫ßu valid JWT token
- Token h·∫øt h·∫°n ‚Üí 401 Unauthorized
- Kh√¥ng c√≥ token ‚Üí 401 Unauthorized

**Public Endpoints:**
- Game creation, joining
- Leaderboard viewing
- User profile viewing (public info only)

---

## 5. Game Stats & Leaderboard System

### 5.1 Stats Calculation

**Score Calculation (Server-side):**
```typescript
// Default scoring (c√≥ th·ªÉ customize per game)
if (result === 'win') {
  score = 10;
} else if (result === 'loss') {
  score = 0;
} else if (result === 'draw') {
  score = 5;
}

// Custom scoring c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong GameType
```

**Stats Update:**
- Khi game k·∫øt th√∫c, frontend g·ªçi `POST /api/games/:gameId/stats/submit`
- Server validate submission
- Update `GameStats` document
- T·∫°o `GameSession` record cho audit trail

### 5.2 Leaderboard Strategy

**Caching:**
- **Daily**: Cache trong `Leaderboard` collection, refresh m·ªói 1 gi·ªù
- **Weekly**: Cache trong `Leaderboard` collection, refresh m·ªói 6 gi·ªù
- **All-time**: Query tr·ª±c ti·∫øp t·ª´ `GameStats` (kh√¥ng cache)

**Cache Rebuild:**
- T·ª± ƒë·ªông rebuild khi cache expired
- Query top 1000 players t·ª´ `GameStats`
- Sort by `totalScore` desc, `wins` desc
- L∆∞u v√†o `Leaderboard` collection

**Performance:**
- Indexes ƒë∆∞·ª£c t·ªëi ∆∞u cho leaderboard queries
- Pagination support (limit/offset)
- Efficient queries v·ªõi compound indexes

### 5.3 User Rank Calculation

**All-time:**
```typescript
rank = countDocuments({
  gameId,
  $or: [
    { totalScore: { $gt: userStats.totalScore } },
    { totalScore: userStats.totalScore, wins: { $gt: userStats.wins } }
  ]
}) + 1;
```

**Daily/Weekly:**
- L·∫•y t·ª´ cached `Leaderboard.rankings`
- T√¨m user trong rankings array

---

## 6. Anti-cheat & Security

### 6.1 Anti-cheat Service

**Validation Steps:**
1. **Nonce Check**: Prevent replay attacks
   - Nonce ph·∫£i l√† UUID unique
   - Nonce kh√¥ng ƒë∆∞·ª£c reuse trong 5 ph√∫t
   - In-memory cache (production: Redis)

2. **Timestamp Check**: Prevent old submissions
   - Timestamp kh√¥ng ƒë∆∞·ª£c qu√° 5 ph√∫t so v·ªõi server time
   - Timestamp kh√¥ng ƒë∆∞·ª£c trong t∆∞∆°ng lai

3. **Rate Limiting**: Prevent spam
   - Max 10 submissions/minute per user/guest
   - S·ª≠ d·ª•ng `express-rate-limit`

4. **Score Validation**: Prevent fake scores
   - Score ph·∫£i h·ª£p l√Ω v·ªõi result type
   - Win: score > 0
   - Loss: score = 0
   - Draw: score >= 0
   - Score kh√¥ng ƒë∆∞·ª£c qu√° cao (suspicious threshold)

5. **Suspicious Pattern Detection:**
   - Win rate > 95% v·ªõi > 20 games ‚Üí Flag suspicious
   - > 5 games finished trong 1 ph√∫t ‚Üí Flag suspicious

### 6.2 Game Session Audit Trail

M·ªói game submission t·∫°o m·ªôt `GameSession` record:
- `sessionId`: UUID unique
- `players`: Array of player results
- `gameData`: Game-specific data (roomId, roomCode, etc.)
- `isValid`: Flag cho suspicious submissions
- `duration`: T·ª± ƒë·ªông t√≠nh t·ª´ `startedAt` v√† `finishedAt`

### 6.3 Security Measures

**Password:**
- Hashed v·ªõi bcryptjs (salt rounds: 10)
- Kh√¥ng l∆∞u plain text

**JWT:**
- Secret key t·ª´ environment variable
- Token kh√¥ng ch·ª©a sensitive data
- Expiry: 7 days

**Rate Limiting:**
- Score submission: 10 req/min
- Auth endpoints: 5 req/min
- General API: 100 req/min

**Input Validation:**
- Mongoose schema validation
- Express validator middleware
- TypeScript type checking

---

## 7. Frontend Architecture

### 7.1 Component Structure

```
frontend/src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ GameBoard/        # Game board UI
‚îÇ   ‚îú‚îÄ‚îÄ GameControls/     # Game controls (undo, surrender, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ GameInfo/         # Game information display
‚îÇ   ‚îú‚îÄ‚îÄ PlayerCard/       # Player card component
‚îÇ   ‚îú‚îÄ‚îÄ RoomCodeDisplay/   # Room code display
‚îÇ   ‚îî‚îÄ‚îÄ RuleSelector/      # Rule selection UI
‚îú‚îÄ‚îÄ contexts/
‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.tsx   # Authentication state
‚îÇ   ‚îú‚îÄ‚îÄ GameContext.tsx   # Game state management
‚îÇ   ‚îî‚îÄ‚îÄ SocketContext.tsx # Socket.io connection
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ HomePage.tsx       # Home page v·ªõi sidebar
‚îÇ   ‚îú‚îÄ‚îÄ GameRoomPage.tsx   # Game room page
‚îÇ   ‚îú‚îÄ‚îÄ JoinGamePage.tsx   # Join game page
‚îÇ   ‚îú‚îÄ‚îÄ LeaderboardPage.tsx # Leaderboard page
‚îÇ   ‚îú‚îÄ‚îÄ ProfilePage.tsx    # User profile page
‚îÇ   ‚îî‚îÄ‚îÄ LoginPage.tsx      # Login/Register page
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ api.ts            # REST API client
‚îÇ   ‚îî‚îÄ‚îÄ socketService.ts  # Socket.io client
‚îî‚îÄ‚îÄ types/
    ‚îú‚îÄ‚îÄ game.types.ts     # Game-related types
    ‚îú‚îÄ‚îÄ socket.types.ts   # Socket event types
    ‚îî‚îÄ‚îÄ user.types.ts     # User-related types
```

### 7.2 State Management

**Context API:**
- `AuthContext`: User authentication state
- `GameContext`: Current game state, game actions
- `SocketContext`: Socket connection management

**State Flow:**
```
User Action ‚Üí Context Method ‚Üí API/Socket Call ‚Üí State Update ‚Üí UI Re-render
```

### 7.3 Routing

**React Router v7 (Data Router):**
```typescript
const router = createBrowserRouter([
  {
    path: '/',
    element: <HomePage />,
  },
  {
    path: '/game/:roomId',
    element: <GameRoomPage />,
  },
  {
    path: '/join',
    element: <JoinGamePage />,
  },
  {
    path: '/leaderboard',
    element: <LeaderboardPage />,
  },
  {
    path: '/profile',
    element: <ProfilePage />,
  },
  {
    path: '/login',
    element: <LoginPage />,
  },
]);
```

**Navigation Protection:**
- `useBlocker` cho game room (prevent accidental navigation)
- `beforeunload` event cho tab close warning

### 7.4 Real-time Communication

**Socket.io Events:**

**Client ‚Üí Server:**
- `join-room`: Join game room
- `leave-room`: Leave game room
- `make-move`: Make a move
- `request-undo`: Request undo
- `approve-undo`: Approve undo
- `reject-undo`: Reject undo
- `surrender`: Surrender game
- `new-game`: Start new game in same room

**Server ‚Üí Client:**
- `room-joined`: Confirmed room join
- `player-joined`: Another player joined
- `player-left`: A player left
- `move-made`: A move was made
- `game-finished`: Game ended
- `score-updated`: Score updated
- `undo-requested`: Undo request received
- `undo-approved`: Undo was approved
- `undo-rejected`: Undo was rejected
- `game-error`: Game error occurred

---

## 8. Deployment

### 8.1 Frontend (Vercel)

**Build Command:**
```bash
cd frontend && npm run build
```

**Output Directory:**
```
frontend/build
```

**Environment Variables:**
```
REACT_APP_API_BASE_URL=https://your-backend-url.com/api
REACT_APP_SOCKET_URL=https://your-backend-url.com
```

### 8.2 Backend (Railway/Render)

**Build Command:**
```bash
cd backend && npm install && npm run build
```

**Start Command:**
```bash
npm start
```

**Environment Variables:**
```
PORT=5000
MONGODB_URI=mongodb+srv://...
JWT_SECRET=your-secret-key
NODE_ENV=production
FRONTEND_URL=https://your-frontend-url.vercel.app
```

### 8.3 Database (MongoDB Atlas)

**Connection:**
- Connection string t·ª´ MongoDB Atlas
- Whitelist IP addresses (ho·∫∑c 0.0.0.0/0 cho development)

**Indexes:**
- T·∫•t c·∫£ indexes ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong models
- T·ª± ƒë·ªông t·∫°o khi model ƒë∆∞·ª£c load l·∫ßn ƒë·∫ßu

---

## 9. Future Extensibility

### 9.1 Adding New Games

**Steps:**
1. Add game type to `backend/src/scripts/initGameTypes.ts`:
```typescript
await GameType.create({
  gameId: 'new-game',
  name: 'New Game',
  description: 'Description of new game',
  isActive: true,
});
```

2. Run initialization script:
```bash
npm run init:gametypes
```

3. Create game-specific logic (optional):
```
backend/src/games/new-game/
‚îú‚îÄ‚îÄ gameEngine.ts
‚îú‚îÄ‚îÄ ruleEngine.ts
‚îî‚îÄ‚îÄ winChecker.ts
```

4. Add frontend components:
```
frontend/src/components/NewGame/
‚îú‚îÄ‚îÄ NewGameBoard.tsx
‚îî‚îÄ‚îÄ NewGameControls.tsx
```

5. Update `HomePage.tsx` sidebar ƒë·ªÉ include new game

**Game-specific Features:**
- `customStats` trong `GameStats` cho game-specific data
- `gameData` trong `GameSession` cho game-specific session data
- Custom scoring logic trong `gameStatsController.ts`

### 9.2 Cross-game Features (Future)

**Achievements:**
- T·∫°o `Achievement` model
- Track achievements across games
- Display in user profile

**Events:**
- T·∫°o `Event` model
- Time-limited events
- Special rewards

**Social Features:**
- Friends system
- Private matches
- Chat system

### 9.3 Scaling Considerations

**Current:**
- Monolith architecture
- Single database instance
- In-memory nonce cache

**Future Scaling:**
- **Redis**: For nonce cache, rate limiting, session storage
- **Database Sharding**: By gameId or userId
- **Read Replicas**: For leaderboard queries
- **CDN**: For static assets
- **Load Balancer**: Multiple backend instances
- **Microservices**: Split by domain (auth, games, stats, leaderboard)

---

## 10. Migration & Scripts

### 10.1 Initialization Scripts

**Initialize Game Types:**
```bash
cd backend
npm run init:gametypes
```

**Migrate User Stats:**
```bash
cd backend
npm run migrate:stats
```

### 10.2 Database Migrations

**Manual Migrations:**
- Game types: Run `initGameTypes.ts`
- User stats: Run `migrateUserStats.ts`
- Indexes: Auto-created on model load

**Rollback:**
- Legacy fields (`User.wins/losses/draws/totalScore`) kept for compatibility
- Old API endpoints still work
- New collections can be dropped if needed

---

## 11. Error Handling

### 11.1 Backend Error Handling

**Error Middleware:**
```typescript
// backend/src/middleware/errorHandler.ts
export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log error
  console.error(err);
  
  // Return appropriate status code
  res.status(err.statusCode || 500).json({
    message: err.message || 'Internal server error',
  });
};
```

**Error Types:**
- 400: Bad Request (validation errors)
- 401: Unauthorized (auth errors)
- 404: Not Found (resource not found)
- 500: Internal Server Error (server errors)

### 11.2 Frontend Error Handling

**API Error Handling:**
```typescript
// services/api.ts
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Token expired, redirect to login
      authContext.logout();
    }
    return Promise.reject(error);
  }
);
```

**Socket Error Handling:**
```typescript
// Socket error events
socket.on('game-error', (error) => {
  // Display error to user
  setError(error.message);
});
```

---

## 12. Testing Considerations

### 12.1 Backend Testing

**Unit Tests:**
- Service functions
- Utility functions
- Model methods

**Integration Tests:**
- API endpoints
- Database operations
- Socket events

### 12.2 Frontend Testing

**Component Tests:**
- React components
- Context providers
- Custom hooks

**E2E Tests:**
- User flows
- Game flows
- Authentication flows

---

## 13. Performance Optimization

### 13.1 Database Optimization

**Indexes:**
- Compound indexes cho common queries
- Unique indexes cho unique fields
- Sparse indexes cho optional fields

**Query Optimization:**
- Use `select()` ƒë·ªÉ ch·ªâ l·∫•y fields c·∫ßn thi·∫øt
- Use `populate()` efficiently
- Pagination cho large datasets

### 13.2 Frontend Optimization

**Code Splitting:**
- React.lazy() cho route components
- Dynamic imports cho heavy components

**Caching:**
- API response caching (n·∫øu c·∫ßn)
- LocalStorage cho user preferences

**Bundle Optimization:**
- Tree shaking
- Minification
- Compression

---

## 14. Monitoring & Logging

### 14.1 Logging

**Backend:**
- Console logging cho development
- Structured logging cho production (Winston, Pino)

**Frontend:**
- Console logging cho development
- Error tracking (Sentry, LogRocket)

### 14.2 Monitoring

**Metrics to Track:**
- API response times
- Database query times
- Socket connection count
- Error rates
- User activity

**Tools:**
- Application Performance Monitoring (APM)
- Database monitoring
- Uptime monitoring

---

## 15. Security Checklist

- [x] Password hashing (bcryptjs)
- [x] JWT token authentication
- [x] Input validation
- [x] Rate limiting
- [x] Nonce-based replay attack prevention
- [x] Timestamp validation
- [x] Score validation
- [x] Suspicious pattern detection
- [x] CORS configuration
- [x] Environment variables for secrets
- [ ] HTTPS enforcement (production)
- [ ] SQL injection prevention (N/A, using NoSQL)
- [ ] XSS prevention (React auto-escapes)
- [ ] CSRF protection (JWT in header, not cookie)

---

## 16. API Documentation

### 16.1 OpenAPI/Swagger (Future)

C√≥ th·ªÉ th√™m Swagger/OpenAPI documentation:
```bash
npm install swagger-jsdoc swagger-ui-express
```

### 16.2 Postman Collection (Future)

T·∫°o Postman collection cho API testing v√† documentation.

---

## 17. Changelog

### Version 2.0.0 (Current)
- ‚úÖ Multi-game support v·ªõi GameType model
- ‚úÖ Per-game statistics v·ªõi GameStats model
- ‚úÖ Leaderboard system v·ªõi caching
- ‚úÖ Anti-cheat system v·ªõi validation
- ‚úÖ Game session audit trail
- ‚úÖ Simplified JWT (single access token, no refresh)
- ‚úÖ Improved error handling
- ‚úÖ TypeScript strict mode

### Version 1.0.0 (Legacy)
- Single game (Caro only)
- User stats in User model
- Basic leaderboard
- JWT authentication

---

## 18. Contact & Support

**Documentation:**
- README.md: Setup v√† basic usage
- MIGRATION_GUIDE.md: Migration t·ª´ v1.0.0
- SYSTEM_ARCHITECTURE.md: This document

**Issues:**
- Report bugs v√† feature requests qua GitHub Issues

---

**Last Updated:** 2025-01-XX
**Version:** 2.0.0
**Status:** Production Ready
</file>

<file path="backend/src/controllers/leaderboardController.ts">
import { Request, Response } from 'express';
import GameStats from '../models/GameStats';
import GameType from '../models/GameType';
import Leaderboard from '../models/Leaderboard';
import User from '../models/User';
import { IRanking } from '../models/Leaderboard';

/**
 * Get leaderboard for a specific game
 * Supports daily, weekly, and all-time periods
 */
export const getLeaderboard = async (req: Request, res: Response): Promise<void> => {
  try {
    const { gameId } = req.params;
    const period = (req.query.period as string) || 'all-time';
    const limit = parseInt(req.query.limit as string) || 50;
    const offset = parseInt(req.query.offset as string) || 0;

    if (!['daily', 'weekly', 'all-time'].includes(period)) {
      res.status(400).json({ message: 'Invalid period. Must be daily, weekly, or all-time' });
      return;
    }

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    let leaderboardData;

    if (period === 'all-time') {
      // Query directly from GameStats for all-time
      const stats = await GameStats.find({ gameId })
        .populate('userId', 'username')
        .sort({ totalScore: -1, wins: -1 })
        .limit(limit)
        .skip(offset);

      leaderboardData = stats.map((stat, index) => ({
        rank: offset + index + 1,
        userId: stat.userId,
        username: (stat.userId as any)?.username || 'Unknown',
        score: stat.totalScore,
        wins: stat.wins,
        losses: stat.losses,
        draws: stat.draws,
      }));
    } else {
      // For daily/weekly, try to get from cache first
      const periodStart = getPeriodStart(period);
      let leaderboard = await Leaderboard.findOne({
        gameId,
        period,
        periodStart,
      });

      if (!leaderboard || isPeriodExpired(period, leaderboard.updatedAt)) {
        // Rebuild leaderboard cache
        leaderboard = await rebuildLeaderboardCache(gameId, period, periodStart);
      }

      if (!leaderboard) {
        res.status(500).json({ message: 'Failed to load leaderboard' });
        return;
      }

      leaderboardData = leaderboard.rankings
        .slice(offset, offset + limit)
        .map((ranking) => ({
          rank: ranking.rank,
          userId: ranking.userId,
          score: ranking.score,
          wins: ranking.wins,
        }));

      // Populate usernames
      const userIds = leaderboardData.map((item) => item.userId);
      const users = await User.find({ _id: { $in: userIds } }).select('username');
      const userMap = new Map(users.map((u) => [u._id.toString(), u.username]));

      leaderboardData = leaderboardData.map((item) => ({
        ...item,
        username: userMap.get(item.userId.toString()) || 'Unknown',
      }));
    }

    res.json({
      gameId,
      period,
      rankings: leaderboardData,
      limit,
      offset,
      total: leaderboardData.length,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get user's rank for a specific game
 */
export const getUserRank = async (req: Request, res: Response): Promise<void> => {
  try {
    const { gameId, userId } = req.params;
    const period = (req.query.period as string) || 'all-time';

    if (!['daily', 'weekly', 'all-time'].includes(period)) {
      res.status(400).json({ message: 'Invalid period. Must be daily, weekly, or all-time' });
      return;
    }

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    const userStats = await GameStats.findOne({ userId, gameId });
    if (!userStats) {
      res.json({
        rank: null,
        totalPlayers: 0,
        userStats: null,
      });
      return;
    }

    let rank: number | null;
    let totalPlayers: number;

    if (period === 'all-time') {
      // Count users with better stats
      rank = await GameStats.countDocuments({
        gameId,
        $or: [
          { totalScore: { $gt: userStats.totalScore } },
          { totalScore: userStats.totalScore, wins: { $gt: userStats.wins } },
        ],
      }) + 1;

      totalPlayers = await GameStats.countDocuments({ gameId });
    } else {
      // Get from cached leaderboard
      const periodStart = getPeriodStart(period);
      const leaderboard = await Leaderboard.findOne({
        gameId,
        period,
        periodStart,
      });

      if (!leaderboard) {
        // Rebuild cache
        const rebuiltLeaderboard = await rebuildLeaderboardCache(gameId, period, periodStart);
        if (!rebuiltLeaderboard) {
          res.status(500).json({ message: 'Failed to load leaderboard' });
          return;
        }
        const ranking = rebuiltLeaderboard.rankings.find(
          (r: IRanking) => r.userId.toString() === userId.toString()
        );
        rank = ranking?.rank || null;
        totalPlayers = rebuiltLeaderboard.rankings.length;
      } else {
        const ranking = leaderboard.rankings.find(
          (r: IRanking) => r.userId.toString() === userId.toString()
        );
        rank = ranking?.rank || null;
        totalPlayers = leaderboard.rankings.length;
      }
    }

    res.json({
      rank,
      totalPlayers,
      userStats: {
        wins: userStats.wins,
        losses: userStats.losses,
        draws: userStats.draws,
        totalScore: userStats.totalScore,
      },
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get players around a user's rank (+-5 players)
 */
export const getRankAroundUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { gameId, userId } = req.params;
    const period = (req.query.period as string) || 'all-time';
    const range = parseInt(req.query.range as string) || 5;

    if (!['daily', 'weekly', 'all-time'].includes(period)) {
      res.status(400).json({ message: 'Invalid period. Must be daily, weekly, or all-time' });
      return;
    }

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    const userStats = await GameStats.findOne({ userId, gameId });
    if (!userStats) {
      res.json({
        rankings: [],
        userRank: null,
      });
      return;
    }

    let rankings: any[];
    let userRank: number | null = null;

    if (period === 'all-time') {
      // Find user's rank
      userRank = await GameStats.countDocuments({
        gameId,
        $or: [
          { totalScore: { $gt: userStats.totalScore } },
          { totalScore: userStats.totalScore, wins: { $gt: userStats.wins } },
        ],
      }) + 1;

      // Get players around user's rank
      const startRank = Math.max(1, userRank - range);
      const endRank = userRank + range;

      const stats = await GameStats.find({ gameId })
        .populate('userId', 'username')
        .sort({ totalScore: -1, wins: -1 })
        .skip(startRank - 1)
        .limit(endRank - startRank + 1);

      rankings = stats.map((stat, index) => ({
        rank: startRank + index,
        userId: stat.userId,
        username: (stat.userId as any)?.username || 'Unknown',
        score: stat.totalScore,
        wins: stat.wins,
        isCurrentUser: stat.userId.toString() === userId,
      }));
    } else {
      // Get from cached leaderboard
      const periodStart = getPeriodStart(period);
      let leaderboard = await Leaderboard.findOne({
        gameId,
        period,
        periodStart,
      });

      if (!leaderboard || isPeriodExpired(period, leaderboard.updatedAt)) {
        leaderboard = await rebuildLeaderboardCache(gameId, period, periodStart);
      }

      if (!leaderboard) {
        res.status(500).json({ message: 'Failed to load leaderboard' });
        return;
      }

      const userRanking = leaderboard.rankings.find(
        (r: IRanking) => r.userId.toString() === userId.toString()
      );
      userRank = userRanking?.rank || null;

      if (userRank) {
        const startRank = Math.max(1, userRank - range);
        const endRank = Math.min(leaderboard.rankings.length, userRank + range);

        rankings = leaderboard.rankings
          .slice(startRank - 1, endRank)
          .map((ranking) => ({
            rank: ranking.rank,
            userId: ranking.userId,
            score: ranking.score,
            wins: ranking.wins,
            isCurrentUser: ranking.userId.toString() === userId,
          }));

        // Populate usernames
        const userIds = rankings.map((item) => item.userId);
        const users = await User.find({ _id: { $in: userIds } }).select('username');
        const userMap = new Map(users.map((u) => [u._id.toString(), u.username]));

        rankings = rankings.map((item) => ({
          ...item,
          username: userMap.get(item.userId.toString()) || 'Unknown',
        }));
      } else {
        rankings = [];
      }
    }

    res.json({
      rankings,
      userRank,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

// Helper functions

/**
 * Get period start date
 */
function getPeriodStart(period: string): Date {
  const now = new Date();
  now.setHours(0, 0, 0, 0);

  if (period === 'daily') {
    return now;
  } else if (period === 'weekly') {
    // Start of week (Monday)
    const day = now.getDay();
    const diff = now.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
    return new Date(now.setDate(diff));
  } else {
    // All-time: use a very old date
    return new Date(0);
  }
}

/**
 * Check if period has expired and needs refresh
 */
function isPeriodExpired(period: string, lastUpdated: Date): boolean {
  const now = new Date();
  const hoursSinceUpdate = (now.getTime() - lastUpdated.getTime()) / (1000 * 60 * 60);

  if (period === 'daily') {
    return hoursSinceUpdate > 1; // Refresh if older than 1 hour
  } else if (period === 'weekly') {
    return hoursSinceUpdate > 6; // Refresh if older than 6 hours
  }
  return false;
}

/**
 * Rebuild leaderboard cache for a period
 */
async function rebuildLeaderboardCache(
  gameId: string,
  period: string,
  periodStart: Date
): Promise<any> {
  let query: any = { gameId };

  // Filter by period if not all-time
  if (period === 'daily') {
    const periodEnd = new Date(periodStart);
    periodEnd.setDate(periodEnd.getDate() + 1);
    query.lastPlayed = { $gte: periodStart, $lt: periodEnd };
  } else if (period === 'weekly') {
    const periodEnd = new Date(periodStart);
    periodEnd.setDate(periodEnd.getDate() + 7);
    query.lastPlayed = { $gte: periodStart, $lt: periodEnd };
  }

  const stats = await GameStats.find(query)
    .sort({ totalScore: -1, wins: -1 })
    .limit(1000); // Limit to top 1000

  const rankings = stats.map((stat, index) => ({
    userId: stat.userId,
    rank: index + 1,
    score: stat.totalScore,
    wins: stat.wins,
    updatedAt: new Date(),
  }));

  const periodEnd = period === 'all-time' ? null : getPeriodEnd(period, periodStart);

  // Update or create leaderboard
  const leaderboard = await Leaderboard.findOneAndUpdate(
    { gameId, period, periodStart },
    {
      gameId,
      period,
      periodStart,
      periodEnd,
      rankings,
      updatedAt: new Date(),
    },
    { upsert: true, new: true }
  );

  return leaderboard;
}

/**
 * Get period end date
 */
function getPeriodEnd(period: string, periodStart: Date): Date {
  const end = new Date(periodStart);
  if (period === 'daily') {
    end.setDate(end.getDate() + 1);
  } else if (period === 'weekly') {
    end.setDate(end.getDate() + 7);
  }
  return end;
}

// Legacy function for backward compatibility
export const getTopPlayers = async (req: Request, res: Response): Promise<void> => {
  try {
    const limit = parseInt(req.query.limit as string) || 10;
    const gameId = (req.query.gameId as string) || 'caro';

    const stats = await GameStats.find({ gameId })
      .populate('userId', 'username')
      .sort({ totalScore: -1, wins: -1 })
      .limit(limit);

    const players = stats.map((stat) => ({
      _id: (stat.userId as any)?._id,
      username: (stat.userId as any)?.username,
      wins: stat.wins,
      losses: stat.losses,
      draws: stat.draws,
      totalScore: stat.totalScore,
    }));

    res.json(players);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="backend/src/controllers/userController.ts">
import { Request, Response } from 'express';
import User from '../models/User';
import GameStats from '../models/GameStats';
import GameType from '../models/GameType';
import { AuthRequest } from '../middleware/authMiddleware';

/**
 * Get user profile
 */
export const getUserProfile = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId } = req.params;
    const user = await User.findById(userId).select('-password');

    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }

    res.json({
      _id: user._id,
      username: user.username,
      email: user.email,
      createdAt: user.createdAt,
      lastLogin: user.lastLogin,
      // Legacy fields for backward compatibility
      wins: user.wins,
      losses: user.losses,
      draws: user.draws,
      totalScore: user.totalScore,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get all game stats for a user
 */
export const getUserGames = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId } = req.params;

    const stats = await GameStats.find({ userId })
      .populate('userId', 'username')
      .sort({ lastPlayed: -1 });

    // Get game type info
    const gameIds = [...new Set(stats.map((s) => s.gameId))];
    const gameTypes = await GameType.find({ gameId: { $in: gameIds } });

    const gameMap = new Map(gameTypes.map((gt) => [gt.gameId, gt]));

    const gameStats = stats.map((stat) => ({
      _id: stat._id,
      gameId: stat.gameId,
      gameName: gameMap.get(stat.gameId)?.name || stat.gameId,
      wins: stat.wins,
      losses: stat.losses,
      draws: stat.draws,
      totalScore: stat.totalScore,
      customStats: Object.fromEntries(stat.customStats || new Map()),
      lastPlayed: stat.lastPlayed,
      createdAt: stat.createdAt,
      updatedAt: stat.updatedAt,
    }));

    res.json({
      userId,
      games: gameStats,
      totalGames: gameStats.length,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get user stats for a specific game
 */
export const getUserGameStats = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId, gameId } = req.params;

    // Verify game exists
    const gameType = await GameType.findOne({ gameId, isActive: true });
    if (!gameType) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    const stats = await GameStats.findOne({ userId, gameId });

    if (!stats) {
      res.json({
        userId,
        gameId,
        gameName: gameType.name,
        wins: 0,
        losses: 0,
        draws: 0,
        totalScore: 0,
        customStats: {},
        lastPlayed: null,
      });
      return;
    }

    res.json({
      _id: stats._id,
      userId: stats.userId,
      gameId: stats.gameId,
      gameName: gameType.name,
      wins: stats.wins,
      losses: stats.losses,
      draws: stats.draws,
      totalScore: stats.totalScore,
      customStats: Object.fromEntries(stats.customStats || new Map()),
      lastPlayed: stats.lastPlayed,
      createdAt: stats.createdAt,
      updatedAt: stats.updatedAt,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get current user's profile
 */
export const getMyProfile = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.userId;

    if (!userId) {
      res.status(401).json({ message: 'Unauthorized' });
      return;
    }

    const user = await User.findById(userId).select('-password');

    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }

    res.json({
      _id: user._id,
      username: user.username,
      email: user.email,
      createdAt: user.createdAt,
      lastLogin: user.lastLogin,
      // Legacy fields for backward compatibility
      wins: user.wins,
      losses: user.losses,
      draws: user.draws,
      totalScore: user.totalScore,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="backend/src/middleware/authMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt';

export interface AuthRequest extends Request {
  user?: {
    userId: string;
    username: string;
  };
}

export const authMiddleware = (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): void => {
  try {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      res.status(401).json({ message: 'No token provided' });
      return;
    }

    const decoded = verifyToken(token);
    req.user = {
      userId: decoded.userId,
      username: decoded.username,
    };
    next();
  } catch (error) {
    res.status(401).json({ message: 'Invalid token' });
  }
};
</file>

<file path="backend/src/models/Game.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IGameRules {
  blockTwoEnds: boolean;
  allowUndo: boolean;
  maxUndoPerGame: number;
  timeLimit: number | null;
}

export interface IGameScore {
  player1: number;
  player2: number;
}

export interface IGame extends Document {
  roomId: string;
  roomCode: string;
  gameType: string; // 'caro', 'wheel', etc.
  player1: mongoose.Types.ObjectId | null;
  player2: mongoose.Types.ObjectId | null;
  player1GuestId: string | null;
  player2GuestId: string | null;
  boardSize: number;
  board: number[][];
  currentPlayer: 1 | 2;
  gameStatus: 'waiting' | 'playing' | 'finished' | 'abandoned';
  winner: 1 | 2 | null | 'draw';
  winningLine?: Array<{ row: number; col: number }>;
  rules: IGameRules;
  score: IGameScore;
  moves: mongoose.Types.ObjectId[];
  createdAt: Date;
  updatedAt: Date;
  finishedAt: Date | null;
}

const GameRulesSchema: Schema = new Schema({
  blockTwoEnds: {
    type: Boolean,
    default: false,
  },
  allowUndo: {
    type: Boolean,
    default: true,
  },
  maxUndoPerGame: {
    type: Number,
    default: 3,
  },
  timeLimit: {
    type: Number,
    default: null,
  },
});

const GameScoreSchema: Schema = new Schema({
  player1: {
    type: Number,
    default: 0,
  },
  player2: {
    type: Number,
    default: 0,
  },
});

const GameSchema: Schema = new Schema({
  roomId: {
    type: String,
    required: true,
    unique: true,
  },
  roomCode: {
    type: String,
    required: true,
    unique: true,
    uppercase: true,
    minlength: 6,
    maxlength: 6,
  },
  gameType: {
    type: String,
    required: true,
    default: 'caro',
    trim: true,
    lowercase: true,
  },
  player1: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  player2: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  player1GuestId: {
    type: String,
    default: null,
  },
  player2GuestId: {
    type: String,
    default: null,
  },
  boardSize: {
    type: Number,
    required: true,
    default: 15,
  },
  board: {
    type: [[Number]],
    required: true,
  },
  currentPlayer: {
    type: Number,
    enum: [1, 2],
    default: 1,
  },
  gameStatus: {
    type: String,
    enum: ['waiting', 'playing', 'finished', 'abandoned'],
    default: 'waiting',
  },
  winner: {
    type: Schema.Types.Mixed,
    default: null,
  },
  winningLine: {
    type: [{
      row: { type: Number, required: true },
      col: { type: Number, required: true },
    }],
    default: undefined,
  },
  rules: {
    type: GameRulesSchema,
    required: true,
  },
  score: {
    type: GameScoreSchema,
    default: { player1: 0, player2: 0 },
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  updatedAt: {
    type: Date,
    default: Date.now,
  },
  finishedAt: {
    type: Date,
    default: null,
  },
});

GameSchema.virtual('moves', {
  ref: 'GameMove',
  localField: '_id',
  foreignField: 'gameId',
});

GameSchema.pre('save', function (next) {
  this.updatedAt = new Date();
  next();
});

export default mongoose.model<IGame>('Game', GameSchema);
</file>

<file path="backend/src/models/User.ts">
import mongoose, { Document, Schema } from 'mongoose';

export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  // Legacy fields - kept for backward compatibility, will be deprecated
  wins?: number;
  losses?: number;
  draws?: number;
  totalScore?: number;
  createdAt: Date;
  lastLogin: Date;
}

const UserSchema: Schema = new Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    minlength: 3,
    maxlength: 20,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true,
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
  },
  // Legacy fields - kept for backward compatibility during migration
  wins: {
    type: Number,
    default: 0,
  },
  losses: {
    type: Number,
    default: 0,
  },
  draws: {
    type: Number,
    default: 0,
  },
  totalScore: {
    type: Number,
    default: 0,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  lastLogin: {
    type: Date,
    default: Date.now,
  },
});

export default mongoose.model<IUser>('User', UserSchema);
</file>

<file path="backend/src/routes/leaderboardRoutes.ts">
import { Router } from 'express';
import {
  getLeaderboard,
  getUserRank,
  getRankAroundUser,
  getTopPlayers, // Legacy endpoint
} from '../controllers/leaderboardController';

const router = Router();

// New endpoints with gameId support
router.get('/:gameId', getLeaderboard);
router.get('/:gameId/rank/:userId', getUserRank);
router.get('/:gameId/around/:userId', getRankAroundUser);

// Legacy endpoint for backward compatibility
router.get('/top', getTopPlayers);

export default router;
</file>

<file path="backend/src/routes/userRoutes.ts">
import { Router } from 'express';
import {
  getUserProfile,
  getUserGames,
  getUserGameStats,
  getMyProfile,
} from '../controllers/userController';
import { authMiddleware } from '../middleware/authMiddleware';

const router = Router();

// Get user profile
router.get('/:userId/profile', getUserProfile);

// Get all game stats for a user
router.get('/:userId/games', getUserGames);

// Get user stats for a specific game
router.get('/:userId/games/:gameId', getUserGameStats);

// Get current user's profile (protected)
router.get('/me/profile', authMiddleware, getMyProfile);

export default router;
</file>

<file path="backend/src/services/ruleEngine.ts">
import { IGame, IGameRules } from '../models/Game';
import { PlayerNumber } from '../types/game.types';

export const validateMove = (
  game: IGame,
  row: number,
  col: number,
  player: PlayerNumber
): { valid: boolean; message?: string } => {
  // Check if it's player's turn
  if (game.currentPlayer !== player) {
    return { valid: false, message: 'Not your turn' };
  }

  // Check if game is in playing status
  if (game.gameStatus !== 'playing') {
    return { valid: false, message: 'Game is not in playing status' };
  }

  // Check bounds
  if (row < 0 || row >= game.boardSize || col < 0 || col >= game.boardSize) {
    return { valid: false, message: 'Move out of bounds' };
  }

  // Check if cell is empty
  if (game.board[row][col] !== 0) {
    return { valid: false, message: 'Cell already occupied' };
  }

  // Check block two ends rule
  if (game.rules.blockTwoEnds) {
    const blockResult = checkBlockTwoEnds(game, row, col, player);
    if (!blockResult.valid) {
      return blockResult;
    }
  }

  return { valid: true };
};

const checkBlockTwoEnds = (
  game: IGame,
  row: number,
  col: number,
  player: PlayerNumber
): { valid: boolean; message?: string } => {
  const opponent = player === 1 ? 2 : 1;
  const directions = [
    [0, 1],   // horizontal
    [1, 0],   // vertical
    [1, 1],   // diagonal \
    [1, -1],  // diagonal /
  ];

  // Check each direction to see if this move would block both ends of opponent's open 4
  for (const [dx, dy] of directions) {
    // Check if there's a sequence of 4 consecutive opponent pieces in this direction
    // that has both ends open, and this move would block both ends
    
    // Scan for sequences of 4 opponent pieces
    for (let startRow = 0; startRow < game.boardSize; startRow++) {
      for (let startCol = 0; startCol < game.boardSize; startCol++) {
        // Check if there's a sequence of 4 opponent pieces starting here
        let sequenceCount = 0;
        let end1Row = startRow - dx;
        let end1Col = startCol - dy;
        let end2Row = startRow + dx * 4;
        let end2Col = startCol + dy * 4;
        
        // Count consecutive opponent pieces
        for (let i = 0; i < 4; i++) {
          const checkRow = startRow + dx * i;
          const checkCol = startCol + dy * i;
      if (
            checkRow >= 0 &&
            checkRow < game.boardSize &&
            checkCol >= 0 &&
            checkCol < game.boardSize &&
            game.board[checkRow][checkCol] === opponent
          ) {
            sequenceCount++;
      } else {
        break;
      }
    }

        // If we have exactly 4 consecutive opponent pieces
        if (sequenceCount === 4) {
          // Check if both ends are open (empty cells)
          let end1Open = false;
          let end2Open = false;
          
          // Check end 1 (negative direction)
          if (
            end1Row >= 0 &&
            end1Row < game.boardSize &&
            end1Col >= 0 &&
            end1Col < game.boardSize &&
            game.board[end1Row][end1Col] === 0
          ) {
            end1Open = true;
          }
          
          // Check end 2 (positive direction)
          if (
            end2Row >= 0 &&
            end2Row < game.boardSize &&
            end2Col >= 0 &&
            end2Col < game.boardSize &&
            game.board[end2Row][end2Col] === 0
          ) {
            end2Open = true;
          }
          
          // If both ends are open, check if this move would block both ends
          if (end1Open && end2Open) {
            // Check if the placed piece is at one of the ends
            const isAtEnd1 = (row === end1Row && col === end1Col);
            const isAtEnd2 = (row === end2Row && col === end2Col);
            
            if (isAtEnd1 || isAtEnd2) {
              // Check if the other end is already blocked by player's piece
              const otherEndRow = isAtEnd1 ? end2Row : end1Row;
              const otherEndCol = isAtEnd1 ? end2Col : end1Col;
              
              // Check if other end is blocked (by player's piece or boundary)
              const otherEndBlocked = 
                otherEndRow < 0 ||
                otherEndRow >= game.boardSize ||
                otherEndCol < 0 ||
                otherEndCol >= game.boardSize ||
                game.board[otherEndRow][otherEndCol] === player;
              
              if (otherEndBlocked) {
      return {
        valid: false,
                  message: 'This move would block both ends of opponent\'s open 4 (block two ends rule)',
      };
              }
            }
          }
        }
      }
    }
  }

  return { valid: true };
};
</file>

<file path="backend/src/services/winChecker.ts">
import { PlayerNumber } from '../types/game.types';

export interface WinningLine {
  row: number;
  col: number;
}

export interface WinResult {
  isWin: boolean;
  winningLine?: WinningLine[];
}

export const checkWin = (
  board: number[][],
  row: number,
  col: number,
  player: PlayerNumber,
  boardSize: number,
  blockTwoEnds: boolean = false
): WinResult => {
  const directions = [
    [0, 1],   // horizontal
    [1, 0],   // vertical
    [1, 1],   // diagonal \
    [1, -1],  // diagonal /
  ];

  const opponent = player === 1 ? 2 : 1;
  
  // Determine win condition based on board size
  // 3x3 board needs 3-in-a-row, larger boards need 5-in-a-row
  const winCount = boardSize === 3 ? 3 : 5;
  const maxCheck = winCount - 1; // Maximum cells to check in each direction

  for (const [dx, dy] of directions) {
    let count = 1; // Count the current move
    let posEndRow = row;
    let posEndCol = col;
    let negEndRow = row;
    let negEndCol = col;

    // Check in positive direction
    for (let i = 1; i <= maxCheck; i++) {
      const newRow = row + dx * i;
      const newCol = col + dy * i;
      if (
        newRow >= 0 &&
        newRow < boardSize &&
        newCol >= 0 &&
        newCol < boardSize &&
        board[newRow][newCol] === player
      ) {
        count++;
        posEndRow = newRow;
        posEndCol = newCol;
      } else {
        break;
      }
    }

    // Check in negative direction
    for (let i = 1; i <= maxCheck; i++) {
      const newRow = row - dx * i;
      const newCol = col - dy * i;
      if (
        newRow >= 0 &&
        newRow < boardSize &&
        newCol >= 0 &&
        newCol < boardSize &&
        board[newRow][newCol] === player
      ) {
        count++;
        negEndRow = newRow;
        negEndCol = newCol;
      } else {
        break;
      }
    }

    // If we have enough consecutive pieces to win
    if (count >= winCount) {
      // If blockTwoEnds rule is enabled, check if both ends are blocked
      if (blockTwoEnds) {
        // Check the cell immediately after the positive end (right/down/right-down/right-up)
        const posEndCheckRow = posEndRow + dx;
        const posEndCheckCol = posEndCol + dy;
        const posEndBlocked = 
          posEndCheckRow < 0 ||
          posEndCheckRow >= boardSize ||
          posEndCheckCol < 0 ||
          posEndCheckCol >= boardSize ||
          board[posEndCheckRow][posEndCheckCol] === opponent;

        // Check the cell immediately before the negative end (left/up/left-up/left-down)
        const negEndCheckRow = negEndRow - dx;
        const negEndCheckCol = negEndCol - dy;
        const negEndBlocked = 
          negEndCheckRow < 0 ||
          negEndCheckRow >= boardSize ||
          negEndCheckCol < 0 ||
          negEndCheckCol >= boardSize ||
          board[negEndCheckRow][negEndCheckCol] === opponent;

        // If both ends are blocked, this is not a win (x o o o o o x pattern)
        if (posEndBlocked && negEndBlocked) {
          continue; // Check next direction
    }
  }

      // If we reach here, it's a valid win
      // Build winning line array from negEnd to posEnd
      const winningLine: WinningLine[] = [];
      const startRow = negEndRow;
      const startCol = negEndCol;
      const endRow = posEndRow;
      const endCol = posEndCol;
      
      // Calculate direction
      const dirRow = endRow > startRow ? 1 : endRow < startRow ? -1 : 0;
      const dirCol = endCol > startCol ? 1 : endCol < startCol ? -1 : 0;
      
      // Add all cells in the winning line
      let currentRow = startRow;
      let currentCol = startCol;
      while (true) {
        winningLine.push({ row: currentRow, col: currentCol });
        if (currentRow === endRow && currentCol === endCol) {
          break;
        }
        currentRow += dirRow;
        currentCol += dirCol;
      }
      
      return { isWin: true, winningLine };
    }
  }

  return { isWin: false };
};
</file>

<file path="backend/src/utils/jwt.ts">
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

export interface TokenPayload {
  userId: string;
  username: string;
}

/**
 * Generate token
 */
export const generateToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
};

/**
 * Verify token
 */
export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET) as TokenPayload;
  } catch (error) {
    throw new Error('Invalid or expired token');
  }
};
</file>

<file path="backend/.gitignore">
node_modules/
dist/
.env
*.log
.DS_Store
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "C·ªù Caro Game Backend",
  "main": "dist/server.js",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "test": "echo \"Error: no test specified\" && exit 1",
    "migrate:stats": "ts-node src/scripts/migrateUserStats.ts",
    "init:gametypes": "ts-node src/scripts/initGameTypes.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.3",
    "socket.io": "^4.7.2",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20.10.5",
    "@types/uuid": "^10.0.0",
    "nodemon": "^3.0.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="frontend/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="frontend/src/contexts/AuthContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { User } from '../types/user.types';
import { authApi } from '../services/api';
import { logger } from '../utils/logger';

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (username: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      refreshUser().catch(() => {
        localStorage.removeItem('token');
        setIsLoading(false);
      });
    } else {
      setIsLoading(false);
    }
  }, []);

  const refreshUser = async (): Promise<void> => {
    try {
      const userData = await authApi.getMe();
      setUser(userData);
    } catch (error) {
      logger.error('Failed to refresh user:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string): Promise<void> => {
    const response = await authApi.login(email, password);
    localStorage.setItem('token', response.token);
    setUser(response.user);
  };

  const register = async (username: string, email: string, password: string): Promise<void> => {
    const response = await authApi.register(username, email, password);
    localStorage.setItem('token', response.token);
    setUser(response.user);
  };

  const logout = (): void => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        register,
        logout,
        refreshUser,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="frontend/src/contexts/SocketContext.tsx">
import React, { createContext, useContext, useEffect, ReactNode } from 'react';
import { socketService } from '../services/socketService';
import { useAuth } from './AuthContext';
import { logger } from '../utils/logger';

interface SocketContextType {
  isConnected: boolean;
}

const SocketContext = createContext<SocketContextType | undefined>(undefined);

export const SocketProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const [isConnected, setIsConnected] = React.useState(false);

  useEffect(() => {
    // Only reconnect if authentication status changed
    // Get token and reconnect
    const token = localStorage.getItem('token');

    // Check if we need to reconnect (socket doesn't exist or token changed)
    const socket = socketService.getSocket();
    const needsReconnect = !socket || !socket.connected;
    
    if (needsReconnect) {
      // Disconnect existing socket first (if any)
      socketService.disconnect();
      socketService.connect(token || undefined);
    }

    const currentSocket = socketService.getSocket();
    if (!currentSocket) return;

    const handleConnect = () => {
      logger.log('Socket connected with token:', token ? 'Yes' : 'No');
      setIsConnected(true);
    };

    const handleDisconnect = () => {
      setIsConnected(false);
    };

    // Only add listeners if socket is new or not already listening
    // Check if listeners already exist to avoid duplicates
    currentSocket.on('connect', handleConnect);
    currentSocket.on('disconnect', handleDisconnect);

    return () => {
      // Cleanup: remove listeners
      if (currentSocket) {
        currentSocket.off('connect', handleConnect);
        currentSocket.off('disconnect', handleDisconnect);
      }
      // Don't disconnect on unmount - keep connection alive
      // socketService.disconnect();
    };
  }, [isAuthenticated]);

  return (
    <SocketContext.Provider value={{ isConnected }}>
      {children}
    </SocketContext.Provider>
  );
};

export const useSocket = (): SocketContextType => {
  const context = useContext(SocketContext);
  if (context === undefined) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
};
</file>

<file path="frontend/src/services/socketService.ts">
import { io, Socket } from 'socket.io-client';
import { SOCKET_URL } from '../utils/constants';
import { ClientToServerEvents, ServerToClientEvents } from '../types/socket.types';
import { logger } from '../utils/logger';

class SocketService {
  private socket: Socket<ServerToClientEvents, ClientToServerEvents> | null = null;

  connect(token?: string): void {
    // If socket already exists and is connected, don't reconnect
    if (this.socket?.connected) {
      return;
    }

    // If socket exists but not connected, disconnect and remove listeners first
    if (this.socket) {
      this.socket.removeAllListeners();
      this.socket.disconnect();
      this.socket = null;
    }

    this.socket = io(SOCKET_URL, {
      auth: {
        token: token || null,
      },
      transports: ['websocket'],
    });

    // Add listeners only once
    this.socket.on('connect', () => {
      logger.log('Socket connected:', this.socket?.id);
    });

    this.socket.on('disconnect', () => {
      logger.log('Socket disconnected');
    });

    this.socket.on('connect_error', (error) => {
      logger.error('Socket connection error:', error);
    });
  }

  disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }

  getSocket(): Socket<ServerToClientEvents, ClientToServerEvents> | null {
    return this.socket;
  }

  isConnected(): boolean {
    return this.socket?.connected || false;
  }
}

export const socketService = new SocketService();
</file>

<file path="frontend/src/types/game.types.ts">
export type GameStatus = 'waiting' | 'playing' | 'finished' | 'abandoned';
export type PlayerNumber = 1 | 2;
export type Winner = PlayerNumber | null | 'draw';

export interface GameRules {
  blockTwoEnds: boolean;
  allowUndo: boolean;
  maxUndoPerGame: number;
  timeLimit: number | null;
}

export interface GameScore {
  player1: number;
  player2: number;
}

export interface Game {
  _id: string;
  roomId: string;
  roomCode: string;
  player1: string | null;
  player2: string | null;
  player1GuestId: string | null;
  player2GuestId: string | null;
  boardSize: number;
  board: number[][];
  currentPlayer: PlayerNumber;
  gameStatus: GameStatus;
  winner: Winner;
  winningLine?: Array<{ row: number; col: number }>;
  rules: GameRules;
  score: GameScore;
  createdAt: string;
  updatedAt: string;
  finishedAt: string | null;
}

export interface GameMove {
  _id: string;
  gameId: string;
  player: PlayerNumber;
  row: number;
  col: number;
  moveNumber: number;
  timestamp: string;
  isUndone: boolean;
}

export interface PlayerInfo {
  id: string;
  username: string;
  isGuest: boolean;
  playerNumber: PlayerNumber;
}

export interface GameHistory {
  _id: string;
  roomId: string;
  roomCode: string;
  boardSize: number;
  board: number[][];
  winner: Winner;
  winningLine?: Array<{ row: number; col: number }>;
  result: 'win' | 'loss' | 'draw';
  opponentUsername: string;
  finishedAt: string | null;
  createdAt: string;
  score: GameScore;
}
</file>

<file path="frontend/src/utils/winChecker.ts">
import { PlayerNumber } from '../types/game.types';

export interface WinningLine {
  row: number;
  col: number;
}

export interface WinResult {
  isWin: boolean;
  winningLine?: WinningLine[];
}

export const checkWin = (
  board: number[][],
  row: number,
  col: number,
  player: PlayerNumber,
  boardSize: number,
  blockTwoEnds: boolean = false
): WinResult => {
  const directions = [
    [0, 1],   // horizontal
    [1, 0],   // vertical
    [1, 1],   // diagonal \
    [1, -1],  // diagonal /
  ];

  const opponent = player === 1 ? 2 : 1;
  
  // Determine win condition based on board size
  // 3x3 board needs 3-in-a-row, larger boards need 5-in-a-row
  const winCount = boardSize === 3 ? 3 : 5;
  const maxCheck = winCount - 1; // Maximum cells to check in each direction

  for (const [dx, dy] of directions) {
    let count = 1; // Count the current move
    let posEndRow = row;
    let posEndCol = col;
    let negEndRow = row;
    let negEndCol = col;

    // Check in positive direction
    for (let i = 1; i <= maxCheck; i++) {
      const newRow = row + dx * i;
      const newCol = col + dy * i;
      if (
        newRow >= 0 &&
        newRow < boardSize &&
        newCol >= 0 &&
        newCol < boardSize &&
        board[newRow][newCol] === player
      ) {
        count++;
        posEndRow = newRow;
        posEndCol = newCol;
      } else {
        break;
      }
    }

    // Check in negative direction
    for (let i = 1; i <= maxCheck; i++) {
      const newRow = row - dx * i;
      const newCol = col - dy * i;
      if (
        newRow >= 0 &&
        newRow < boardSize &&
        newCol >= 0 &&
        newCol < boardSize &&
        board[newRow][newCol] === player
      ) {
        count++;
        negEndRow = newRow;
        negEndCol = newCol;
      } else {
        break;
      }
    }

    // If we have enough consecutive pieces to win
    if (count >= winCount) {
      // If blockTwoEnds rule is enabled, check if both ends are blocked
      if (blockTwoEnds) {
        // Check if positive end is blocked
        const posEndCheckRow = posEndRow + dx;
        const posEndCheckCol = posEndCol + dy;
        const posEndBlocked = 
          posEndCheckRow < 0 ||
          posEndCheckRow >= boardSize ||
          posEndCheckCol < 0 ||
          posEndCheckCol >= boardSize ||
          board[posEndCheckRow][posEndCheckCol] === opponent;

        // Check if negative end is blocked
        const negEndCheckRow = negEndRow - dx;
        const negEndCheckCol = negEndCol - dy;
        const negEndBlocked = 
          negEndCheckRow < 0 ||
          negEndCheckRow >= boardSize ||
          negEndCheckCol < 0 ||
          negEndCheckCol >= boardSize ||
          board[negEndCheckRow][negEndCheckCol] === opponent;

        // If both ends are blocked, this is not a win
        if (posEndBlocked && negEndBlocked) {
          continue; // Check next direction
        }
      }

      // If we reach here, it's a valid win
      // Build winning line array from negEnd to posEnd
      const winningLine: WinningLine[] = [];
      const startRow = negEndRow;
      const startCol = negEndCol;
      const endRow = posEndRow;
      const endCol = posEndCol;
      
      // Calculate direction
      const dirRow = endRow > startRow ? 1 : endRow < startRow ? -1 : 0;
      const dirCol = endCol > startCol ? 1 : endCol < startCol ? -1 : 0;
      
      // Add all cells in the winning line
      let currentRow = startRow;
      let currentCol = startCol;
      while (true) {
        winningLine.push({ row: currentRow, col: currentCol });
        if (currentRow === endRow && currentCol === endCol) {
          break;
        }
        currentRow += dirRow;
        currentCol += dirCol;
      }
      
      return { isWin: true, winningLine };
    }
  }

  return { isWin: false };
};
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^7.3.6",
    "@mui/material": "^7.3.6",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.126",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "axios": "^1.13.2",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-router-dom": "^7.10.1",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.8.1",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="frontend/README.md">
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can‚Äôt go back!**

If you aren‚Äôt satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you‚Äôre on your own.

You don‚Äôt have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn‚Äôt feel obligated to use this feature. However we understand that this tool wouldn‚Äôt be useful if you couldn‚Äôt customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).
</file>

<file path="backend/src/controllers/gameController.ts">
import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import mongoose from 'mongoose';
import Game from '../models/Game';
import GameHistory from '../models/GameHistory';
import { initializeBoard, generateRoomCode } from '../services/gameEngine';
import { AuthRequest } from '../middleware/authMiddleware';
import { io } from '../server';
import User from '../models/User';

export const createGame = async (req: Request, res: Response): Promise<void> => {
  try {
    console.log('[createGame] Request received:', { 
      body: req.body, 
      hasAuth: !!req.headers.authorization,
      boardSize: req.body?.boardSize,
      guestId: req.body?.guestId 
    });
    
    const { boardSize = 15, rules = {}, guestId } = req.body;
    const authReq = req as AuthRequest;
    
    // Try to get user from token (optional auth - allow both authenticated and guest)
    let userId: string | null = null;
    try {
      const token = req.headers.authorization?.split(' ')[1];
      if (token) {
        const { verifyToken } = await import('../utils/jwt');
        const decoded = verifyToken(token);
        userId = decoded.userId;
        console.log('[createGame] Authenticated user:', userId);
      }
    } catch (error) {
      // Token invalid or not provided - continue as guest
      console.log('[createGame] No valid token provided, creating game as guest');
    }
    
    // Use userId from token or from authReq.user (fallback)
    const finalUserId = userId || authReq.user?.userId || null;

    console.log('[createGame] Creating game with:', { 
      boardSize, 
      finalUserId, 
      guestId, 
      rules 
    });

    const roomId = uuidv4();
    const roomCode = await generateRoomCode();
    const board = initializeBoard(boardSize);

    console.log('[createGame] Generated roomId:', roomId, 'roomCode:', roomCode);

    const game = new Game({
      roomId,
      roomCode,
      gameType: 'caro', // Set game type
      player1: finalUserId ? (finalUserId as any) : null,
      player1GuestId: finalUserId ? null : guestId || null,
      boardSize,
      board,
      rules: {
        blockTwoEnds: rules.blockTwoEnds || false,
        allowUndo: rules.allowUndo !== undefined ? rules.allowUndo : true,
        maxUndoPerGame: rules.maxUndoPerGame || 3,
        timeLimit: rules.timeLimit || null,
      },
      gameStatus: 'waiting',
    });

    console.log('[createGame] Saving game to database...');
    await game.save();
    console.log('[createGame] Game saved successfully:', game.roomId);

    // Emit socket event to notify all users in lobby about new game
    // Get player1 username for the event
    let player1Username: string | null = null;
    if (finalUserId) {
      const user1 = await User.findById(finalUserId).select('username').lean();
      player1Username = user1?.username || 'Player 1';
    } else if (guestId) {
      player1Username = `Guest ${guestId.slice(-6)}`;
    }

    io.emit('game-created', {
      roomId: game.roomId,
      roomCode: game.roomCode,
      boardSize: game.boardSize,
      gameStatus: game.gameStatus,
      player1Username,
      createdAt: game.createdAt.toISOString(),
    });

    res.status(201).json({
      _id: game._id.toString(),
      roomId: game.roomId,
      roomCode: game.roomCode,
      player1: game.player1?.toString() || null,
      player2: game.player2?.toString() || null,
      player1GuestId: game.player1GuestId,
      player2GuestId: game.player2GuestId,
      boardSize: game.boardSize,
      board: game.board,
      currentPlayer: game.currentPlayer,
      gameStatus: game.gameStatus,
      winner: game.winner,
      rules: game.rules,
      score: game.score,
      createdAt: game.createdAt.toISOString(),
      updatedAt: game.updatedAt.toISOString(),
      finishedAt: game.finishedAt?.toISOString() || null,
    });
    
    console.log('[createGame] Response sent successfully');
  } catch (error: any) {
    console.error('[createGame] Error creating game:', error);
    console.error('[createGame] Error stack:', error.stack);
    res.status(500).json({ 
      message: error.message || 'Failed to create game',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

export const getGame = async (req: Request, res: Response): Promise<void> => {
  try {
    const { roomId } = req.params;
    const game = await Game.findOne({ roomId })
      .populate('player1', 'username')
      .populate('player2', 'username');

    if (!game) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    res.json({
      _id: game._id.toString(),
      roomId: game.roomId,
      roomCode: game.roomCode,
      player1: game.player1?.toString() || null,
      player2: game.player2?.toString() || null,
      player1GuestId: game.player1GuestId,
      player2GuestId: game.player2GuestId,
      boardSize: game.boardSize,
      board: game.board,
      currentPlayer: game.currentPlayer,
      gameStatus: game.gameStatus,
      winner: game.winner,
      rules: game.rules,
      score: game.score,
      createdAt: game.createdAt.toISOString(),
      updatedAt: game.updatedAt.toISOString(),
      finishedAt: game.finishedAt?.toISOString() || null,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const getGameByCode = async (req: Request, res: Response): Promise<void> => {
  try {
    const { roomCode } = req.params;
    const game = await Game.findOne({ roomCode: roomCode.toUpperCase() })
      .populate('player1', 'username')
      .populate('player2', 'username');

    if (!game) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    res.json({
      _id: game._id.toString(),
      roomId: game.roomId,
      roomCode: game.roomCode,
      player1: game.player1?.toString() || null,
      player2: game.player2?.toString() || null,
      player1GuestId: game.player1GuestId,
      player2GuestId: game.player2GuestId,
      boardSize: game.boardSize,
      board: game.board,
      currentPlayer: game.currentPlayer,
      gameStatus: game.gameStatus,
      winner: game.winner,
      rules: game.rules,
      score: game.score,
      createdAt: game.createdAt.toISOString(),
      updatedAt: game.updatedAt.toISOString(),
      finishedAt: game.finishedAt?.toISOString() || null,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const joinGame = async (req: Request, res: Response): Promise<void> => {
  try {
    const { roomId } = req.params;
    const { guestId } = req.body;
    const authReq = req as AuthRequest;
    
    // Try to get user from token (optional auth - allow both authenticated and guest)
    let userId: string | null = null;
    try {
      const token = req.headers.authorization?.split(' ')[1];
      if (token) {
        const { verifyToken } = await import('../utils/jwt');
        const decoded = verifyToken(token);
        userId = decoded.userId;
      }
    } catch (error) {
      // Token invalid or not provided - continue as guest
      console.log('No valid token provided, joining game as guest');
    }
    
    // Use userId from token or from authReq.user (fallback)
    const finalUserId = userId || authReq.user?.userId || null;

    const game = await Game.findOne({ roomId });

    if (!game) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    // Check if game is playing - cannot join
    if (game.gameStatus === 'playing') {
      res.status(400).json({ message: 'Game is already in progress and cannot be joined' });
      return;
    }

    if (game.gameStatus !== 'waiting') {
      res.status(400).json({ message: 'Game is not available for joining' });
      return;
    }

    // Check if user is already in the game
    const userIdToCheck = finalUserId;
    const isPlayer1 = userIdToCheck 
      ? game.player1 && game.player1.toString() === userIdToCheck.toString()
      : game.player1GuestId === guestId;
    const isPlayer2 = userIdToCheck
      ? game.player2 && game.player2.toString() === userIdToCheck.toString()
      : game.player2GuestId === guestId;

    if (isPlayer1 || isPlayer2) {
      res.json({
        _id: game._id.toString(),
        roomId: game.roomId,
        roomCode: game.roomCode,
        player1: game.player1?.toString() || null,
        player2: game.player2?.toString() || null,
        player1GuestId: game.player1GuestId,
        player2GuestId: game.player2GuestId,
        boardSize: game.boardSize,
        board: game.board,
        currentPlayer: game.currentPlayer,
        gameStatus: game.gameStatus,
        winner: game.winner,
        rules: game.rules,
        score: game.score,
        createdAt: game.createdAt.toISOString(),
        updatedAt: game.updatedAt.toISOString(),
        finishedAt: game.finishedAt?.toISOString() || null,
      });
      return;
    }
    
    // Check if game is full (has both players) - cannot join
    const hasPlayer1 = !!(game.player1 || game.player1GuestId);
    const hasPlayer2 = !!(game.player2 || game.player2GuestId);
    
    if (hasPlayer1 && hasPlayer2) {
      res.status(400).json({ message: 'Game is full (2/2 players). Please wait for the game to start or find another game.' });
      return;
    }

    // Join as player2
    if (!game.player2 && !game.player2GuestId) {
      if (userIdToCheck) {
        game.player2 = userIdToCheck as any;
        game.player2GuestId = null; // Clear guestId if joining as authenticated user
    } else {
        game.player2GuestId = guestId || null;
      }
    }

    await game.save();

    // Emit socket event to room
    const user2 = userIdToCheck ? await User.findById(userIdToCheck).select('username').lean() : null;
    io.to(roomId).emit('player-joined', {
      player: {
        id: userIdToCheck || guestId || '',
        username: userIdToCheck ? (user2?.username || 'Player 2') : `Guest ${guestId?.slice(-6) || ''}`,
        isGuest: !userIdToCheck,
        playerNumber: 2,
      },
    });

    // Emit socket event to lobby about game status update
    // Recalculate after save (game state may have changed)
    const hasPlayer1After = !!(game.player1 || game.player1GuestId);
    const hasPlayer2After = !!(game.player2 || game.player2GuestId);
    const playerCount = (hasPlayer1After ? 1 : 0) + (hasPlayer2After ? 1 : 0);
    const isFull = hasPlayer1After && hasPlayer2After;
    
    // After join, gameStatus is still 'waiting' (game hasn't started yet)
    // But check it anyway for type safety
    const currentGameStatus = game.gameStatus as string;
    let displayStatus: 'waiting' | 'ready' | 'playing';
    if (currentGameStatus === 'playing') {
      displayStatus = 'playing';
    } else if (isFull) {
      displayStatus = 'ready';
    } else {
      displayStatus = 'waiting';
    }

    io.emit('game-status-updated', {
      roomId: game.roomId,
      roomCode: game.roomCode,
      gameStatus: game.gameStatus,
      displayStatus,
      playerCount,
      isFull,
    });
    
    res.json({
      _id: game._id.toString(),
      roomId: game.roomId,
      roomCode: game.roomCode,
      player1: game.player1?.toString() || null,
      player2: game.player2?.toString() || null,
      player1GuestId: game.player1GuestId,
      player2GuestId: game.player2GuestId,
      boardSize: game.boardSize,
      board: game.board,
      currentPlayer: game.currentPlayer,
      gameStatus: game.gameStatus,
      winner: game.winner,
      rules: game.rules,
      score: game.score,
      createdAt: game.createdAt.toISOString(),
      updatedAt: game.updatedAt.toISOString(),
      finishedAt: game.finishedAt?.toISOString() || null,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const getUserGames = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId } = req.params;
    const games = await Game.find({
      $or: [
        { player1: userId },
        { player2: userId },
      ],
    })
      .sort({ createdAt: -1 })
      .limit(50)
      .select('roomId roomCode boardSize gameStatus createdAt');

    res.json(games);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const getWaitingGames = async (req: Request, res: Response): Promise<void> => {
  try {
    // Get all active games (waiting with 1 player, waiting with 2 players, and playing)
    // Exclude finished and abandoned games
    const games = await Game.find({
      gameStatus: { $in: ['waiting', 'playing'] },
      $or: [
        { player1: { $ne: null } },
        { player1GuestId: { $ne: null } },
      ],
    })
      .sort({ createdAt: -1 })
      .limit(50)
      .select('roomId roomCode boardSize gameStatus player1 player2 player1GuestId player2GuestId createdAt')
      .populate('player1', 'username')
      .populate('player2', 'username');

    // Format response with display status
    const formattedGames = games.map(game => {
      const hasPlayer1 = !!(game.player1 || game.player1GuestId);
      const hasPlayer2 = !!(game.player2 || game.player2GuestId);
      const playerCount = (hasPlayer1 ? 1 : 0) + (hasPlayer2 ? 1 : 0);
      const isFull = hasPlayer1 && hasPlayer2;
      
      // Determine display status
      let displayStatus: 'waiting' | 'ready' | 'playing';
      let statusLabel: string;
      let canJoin: boolean;
      
      if (game.gameStatus === 'playing') {
        displayStatus = 'playing';
        statusLabel = 'Playing';
        canJoin = false;
      } else if (isFull) {
        displayStatus = 'ready';
        statusLabel = 'Ready (2/2)';
        canJoin = false;
      } else {
        displayStatus = 'waiting';
        statusLabel = `Waiting (${playerCount}/2)`;
        canJoin = true;
      }

      // Get player1 username
      let player1Username: string | null = null;
      if (game.player1 && typeof game.player1 === 'object' && 'username' in game.player1) {
        player1Username = (game.player1 as any).username || 'Player 1';
      } else if (game.player1GuestId) {
        player1Username = `Guest ${game.player1GuestId.slice(-6)}`;
      }

      return {
      _id: game._id.toString(),
      roomId: game.roomId,
      roomCode: game.roomCode,
      boardSize: game.boardSize,
      gameStatus: game.gameStatus,
        displayStatus, // 'waiting' | 'ready' | 'playing'
        statusLabel, // Display text
        canJoin, // Whether others can join
        hasPlayer1,
        hasPlayer2,
        playerCount,
        player1Username,
      createdAt: game.createdAt.toISOString(),
      };
    });

    res.json(formattedGames);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

export const leaveGame = async (req: Request, res: Response): Promise<void> => {
  try {
    const { roomId } = req.params;
    const { guestId } = req.body;
    const authReq = req as AuthRequest;
    
    const game = await Game.findOne({ roomId });

    if (!game) {
      res.status(404).json({ message: 'Game not found' });
      return;
    }

    // Determine which player is leaving
    let isPlayer1 = false;
    let isPlayer2 = false;
    
    // Check if authenticated user is player1 or player2
    if (authReq.user?.userId) {
      isPlayer1 = !!(game.player1 && game.player1.toString() === authReq.user.userId.toString());
      isPlayer2 = !!(game.player2 && game.player2.toString() === authReq.user.userId.toString());
    }
    
    // Also check if guestId matches player1GuestId or player2GuestId
    if (guestId) {
      if (game.player1GuestId && game.player1GuestId === guestId) {
        isPlayer1 = true;
      }
      if (game.player2GuestId && game.player2GuestId === guestId) {
        isPlayer2 = true;
      }
    }

    // If player is not in the game, return success (they're already not in it)
    if (!isPlayer1 && !isPlayer2) {
      res.json({ message: 'Player not in game', gameDeleted: false });
      return;
    }

    // Check if game was finished before player left
    const wasFinished = game.gameStatus === 'finished';
    
    // Capture player data BEFORE removing (for history saving)
    const player1Before = game.player1;
    const player2Before = game.player2;
    const player1GuestIdBefore = game.player1GuestId;
    const player2GuestIdBefore = game.player2GuestId;
    
    // Save history for authenticated user BEFORE removing player (if game finished)
    // This ensures history is saved even if only 1 player leaves
    // Also check if history already exists to avoid duplicates
    if (wasFinished && game.finishedAt) {
      const existingHistory = await GameHistory.findOne({ roomId: game.roomId });
      
      if (!existingHistory) {
        // History not saved yet - save it now
        const leavingPlayerIsAuthenticated = isPlayer1 
          ? !!(player1Before && !player1GuestIdBefore)
          : !!(player2Before && !player2GuestIdBefore);
        
        if (leavingPlayerIsAuthenticated) {
          // Save history for the leaving authenticated player
          const leavingPlayerId = isPlayer1 ? player1Before : player2Before;
          
          if (leavingPlayerId) {
            const historyRecord = new GameHistory({
              originalGameId: game._id.toString(),
              roomId: game.roomId,
              roomCode: game.roomCode,
              gameType: game.gameType,
              player1: player1Before, // Use captured data before removal
              player2: player2Before, // Use captured data before removal
              player1GuestId: null, // Don't save guest IDs to database
              player2GuestId: null,
              boardSize: game.boardSize,
              board: game.board,
              winner: game.winner,
              winningLine: (game as any).winningLine,
              score: game.score,
              rules: game.rules,
              finishedAt: game.finishedAt,
              createdAt: game.createdAt,
              savedAt: new Date(),
            });
            await historyRecord.save();
            console.log(`[leaveGame] Saved history for authenticated player ${leavingPlayerId} before leaving`);
            
            // Clean up old history for this player
            await cleanupOldHistory(
              isPlayer1 ? player1Before : null,
              null,
              isPlayer2 ? player2Before : null,
              null
            );
          }
        }
      } else {
        // History already saved by first player - just cleanup
        console.log(`[leaveGame] History already saved for game ${game.roomId}, skipping duplicate save`);
        await cleanupOldHistory(player1Before, null, player2Before, null);
      }
    }

    // Check players BEFORE removing (to determine if we need host transfer)
    const hasPlayer1Before = !!(game.player1 || game.player1GuestId);
    const hasPlayer2Before = !!(game.player2 || game.player2GuestId);

    // Remove the player from the game
    if (isPlayer1) {
      game.player1 = null;
      game.player1GuestId = null;
    } else if (isPlayer2) {
      game.player2 = null;
      game.player2GuestId = null;
    }

    // Check players AFTER removing (to determine final state)
    const hasPlayer1After = !!(game.player1 || game.player1GuestId);
    const hasPlayer2After = !!(game.player2 || game.player2GuestId);
    const hasNoPlayers = !hasPlayer1After && !hasPlayer2After;

    if (hasNoPlayers) {
      // Case 1: Game finished + c·∫£ 2 player r·ªùi ‚Üí l∆∞u v√†o history v√† x√≥a game
      if (game.gameStatus === 'finished' && game.finishedAt) {
        // Check if history was already saved by the first player who left
        // (history is saved before removing player, so we need to check if it exists)
        const existingHistory = await GameHistory.findOne({ roomId: game.roomId });
        
        if (!existingHistory) {
          // History not saved yet - save it now (for the second player leaving)
          // Only save to database if at least one player is authenticated
          // Guest history should be saved to localStorage on frontend, not database
          const hasAuthenticatedPlayer = !!(game.player1 || game.player2);
          
          if (hasAuthenticatedPlayer) {
            // Save to history before deleting (only for authenticated users)
            // Note: game.player1 and game.player2 are already null at this point,
            // so we need to use the original player data from before removal
            // We'll use the game data that was captured before player removal
            const historyRecord = new GameHistory({
              originalGameId: game._id.toString(),
              roomId: game.roomId,
              roomCode: game.roomCode,
              gameType: game.gameType,
              player1: game.player1, // This will be null if player1 already left
              player2: game.player2, // This will be null if player2 already left
              player1GuestId: null, // Don't save guest IDs to database
              player2GuestId: null, // Guest history is handled on frontend
              boardSize: game.boardSize,
              board: game.board,
              winner: game.winner,
              winningLine: (game as any).winningLine,
              score: game.score,
              rules: game.rules,
              finishedAt: game.finishedAt,
              createdAt: game.createdAt,
              savedAt: new Date(),
            });
            await historyRecord.save();
            
            // Clean up old history (keep only last 50 for each authenticated player)
            // Note: No cleanup for guests since they're not saved to DB
            await cleanupOldHistory(game.player1, null, game.player2, null);
          } else {
            // Both players are guests - don't save to database
            // Frontend will handle saving to localStorage
            console.log(`[leaveGame] Game ${roomId} finished with only guest players - not saving to database`);
          }
        } else {
          // History already saved by first player - just cleanup
          console.log(`[leaveGame] History already saved for game ${roomId}, skipping duplicate save`);
          await cleanupOldHistory(game.player1, null, game.player2, null);
        }
        
        // Delete the game to save space
        await Game.deleteOne({ roomId });
        
        console.log(`[leaveGame] Game ${roomId} finished, saved to history and deleted`);
        
        // Emit socket event to notify other clients (if any)
        io.to(roomId).emit('game-deleted', { roomId });
        
        res.json({ 
          message: 'Game finished - saved to history and deleted', 
          gameDeleted: true 
        });
        return;
      } else {
        // Case 3: Game ch∆∞a finished + c·∫£ 2 player r·ªùi ‚Üí x√≥a game
      await Game.deleteOne({ roomId });
      
      // Emit socket event to notify all clients in lobby (not just in room)
      io.emit('game-deleted', { roomId });
      
      res.json({ 
        message: 'Game deleted - no players remaining', 
        gameDeleted: true 
      });
        return;
      }
    } else {
      let gameReset = false;
      let hostTransferred = false;
      
      // If player1 (host) left and player2 still exists AFTER removal, transfer host to player2
      if (isPlayer1 && hasPlayer2After) {
        // Transfer player2 to player1 (host transfer)
        game.player1 = game.player2;
        game.player1GuestId = game.player2GuestId;
        game.player2 = null;
        game.player2GuestId = null;
        hostTransferred = true;
        console.log(`[leaveGame] Host transferred: Player2 (${game.player1 || game.player1GuestId}) is now Player1`);
        
        // Case 2: Game finished + 1 player r·ªùi ‚Üí reset v·ªÅ waiting
        if (wasFinished) {
          game.gameStatus = 'waiting';
          game.winner = null;
          game.finishedAt = null;
          // Reset board for new game
          game.board = Array(game.boardSize)
            .fill(null)
            .map(() => Array(game.boardSize).fill(0));
          game.currentPlayer = 1;
          gameReset = true;
        } else if (game.gameStatus === 'playing') {
          // Case 4: Game playing + 1 player r·ªùi ‚Üí reset v·ªÅ waiting
          game.gameStatus = 'waiting';
          game.winner = null;
          game.finishedAt = null;
          // Reset board for new game
          game.board = Array(game.boardSize)
            .fill(null)
            .map(() => Array(game.boardSize).fill(0));
          game.currentPlayer = 1;
          gameReset = true;
        } else if (game.gameStatus === 'waiting') {
          // Keep as waiting so it shows in lobby
          game.gameStatus = 'waiting';
        }
      } else if (isPlayer2 && hasPlayer1After) {
        // Player2 left, player1 still there - just remove player2 (no host transfer needed)
        // Case 2: Game finished + 1 player r·ªùi ‚Üí reset v·ªÅ waiting
        if (wasFinished) {
          game.gameStatus = 'waiting';
          game.winner = null;
          game.finishedAt = null;
          // Reset board for new game
          game.board = Array(game.boardSize)
            .fill(null)
            .map(() => Array(game.boardSize).fill(0));
          game.currentPlayer = 1;
          gameReset = true;
        } else if (game.gameStatus === 'playing') {
          // Case 4: Game playing + 1 player r·ªùi ‚Üí reset v·ªÅ waiting
          game.gameStatus = 'waiting';
          game.winner = null;
          game.finishedAt = null;
          // Reset board for new game
          game.board = Array(game.boardSize)
            .fill(null)
            .map(() => Array(game.boardSize).fill(0));
          game.currentPlayer = 1;
          gameReset = true;
        } else if (game.gameStatus === 'waiting') {
          // Explicitly set to waiting to ensure it shows in lobby
          game.gameStatus = 'waiting';
        }
      }
      
      await game.save();
      
      console.log(`[leaveGame] Player left - isPlayer1: ${isPlayer1}, isPlayer2: ${isPlayer2}, hostTransferred: ${hostTransferred}, hasPlayer1After: ${hasPlayer1After}, hasPlayer2After: ${hasPlayer2After}`);
      console.log(`[leaveGame] Game state after leave - player1: ${game.player1 || game.player1GuestId || 'null'}, player2: ${game.player2 || game.player2GuestId || 'null'}, gameStatus: ${game.gameStatus}`);
      
      // Emit socket event to notify other players in room
      io.to(roomId).emit('player-left', { 
        playerNumber: isPlayer1 ? 1 : 2,
        roomId,
        hostTransferred: hostTransferred, // Notify if host was transferred
        gameReset: gameReset, // Notify if game was reset from finished to waiting
      });

      // Emit socket event to lobby about game status update
      const playerCount = (hasPlayer1After ? 1 : 0) + (hasPlayer2After ? 1 : 0);
      const isFull = hasPlayer1After && hasPlayer2After;
      
      let displayStatus: 'waiting' | 'ready' | 'playing';
      if (game.gameStatus === 'playing') {
        displayStatus = 'playing';
      } else if (isFull) {
        displayStatus = 'ready';
      } else {
        displayStatus = 'waiting';
      }

      io.emit('game-status-updated', {
        roomId: game.roomId,
        roomCode: game.roomCode,
        gameStatus: game.gameStatus,
        displayStatus,
        playerCount,
        isFull,
      });
      
      res.json({ 
        message: 'Player left game', 
        gameDeleted: false,
        hostTransferred: hostTransferred,
      });
    }
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get game history for current user (last 20 finished games)
 */
/**
 * Clean up old history records - keep only last 20 for each player
 */
const cleanupOldHistory = async (
  player1: mongoose.Types.ObjectId | null,
  player1GuestId: string | null,
  player2: mongoose.Types.ObjectId | null,
  player2GuestId: string | null
): Promise<void> => {
  try {
    // Only cleanup for authenticated users (not guests)
    // Guest history is handled on frontend with localStorage
    
    // Clean up for player1 (authenticated only)
    if (player1) {
      const player1History = await GameHistory.find({ player1 })
        .sort({ finishedAt: -1 })
        .select('_id')
        .lean();
      // Keep last 50 games for authenticated users (more than guest's 20)
      if (player1History.length > 50) {
        const idsToDelete = player1History.slice(50).map(h => h._id);
        await GameHistory.deleteMany({ _id: { $in: idsToDelete } });
        console.log(`[cleanupOldHistory] Deleted ${idsToDelete.length} old history records for player1`);
      }
    }
    // Note: No cleanup for player1GuestId - guest history is not saved to DB
    
    // Clean up for player2 (authenticated only)
    if (player2) {
      const player2History = await GameHistory.find({ player2 })
        .sort({ finishedAt: -1 })
        .select('_id')
        .lean();
      // Keep last 50 games for authenticated users (more than guest's 20)
      if (player2History.length > 50) {
        const idsToDelete = player2History.slice(50).map(h => h._id);
        await GameHistory.deleteMany({ _id: { $in: idsToDelete } });
        console.log(`[cleanupOldHistory] Deleted ${idsToDelete.length} old history records for player2`);
      }
    }
    // Note: No cleanup for player2GuestId - guest history is not saved to DB
  } catch (error: any) {
    console.error('[cleanupOldHistory] Error cleaning up old history:', error);
    // Don't throw - this is cleanup, shouldn't block the main operation
  }
};

export const getGameHistory = async (req: Request, res: Response): Promise<void> => {
  try {
    const authReq = req as AuthRequest;
    const userId = authReq.user?.userId;
    const { guestId } = req.body;
    
    console.log(`[getGameHistory] Request received - userId: ${userId}, guestId: ${guestId}`);
    
    // Only return history for authenticated users
    // Guest history should be retrieved from localStorage on frontend
    if (!userId) {
      // Guest user - return empty history (frontend will use localStorage)
      console.log(`[getGameHistory] Guest user - returning empty history (should use localStorage)`);
      res.json({ history: [], total: 0 });
      return;
    }

    // Build query to find finished games in history where authenticated user participated
    const query: any = {
      $or: [
        { player1: userId },
        { player2: userId },
      ],
    };

    // Get last 50 finished games from history (more than guest's 20)
    console.log(`[getGameHistory] Query:`, JSON.stringify(query, null, 2));
    const games = await GameHistory.find(query)
      .sort({ finishedAt: -1 })
      .limit(50)
      .select('roomId roomCode boardSize board winner winningLine finishedAt createdAt player1 player2 score')
      .populate('player1', 'username')
      .populate('player2', 'username')
      .lean();
    
    console.log(`[getGameHistory] Found ${games.length} finished games in history`);

    // Format response with result for current user
    const history = games.map(game => {
      // Determine if current user is player1 or player2 (only authenticated users at this point)
      const isPlayer1 = game.player1 && (game.player1 as any)._id?.toString() === userId.toString();
      const isPlayer2 = game.player2 && (game.player2 as any)._id?.toString() === userId.toString();

      // Determine result
      let result: 'win' | 'loss' | 'draw' = 'draw';
      if (game.winner === 'draw' || game.winner === null) {
        result = 'draw';
      } else if (isPlayer1 && game.winner === 1) {
        result = 'win';
      } else if (isPlayer2 && game.winner === 2) {
        result = 'win';
      } else {
        result = 'loss';
      }

      // Get opponent info
      let opponentUsername = 'Unknown';
      if (isPlayer1 && game.player2) {
        opponentUsername = (game.player2 as any).username || 'Guest';
      } else if (isPlayer2 && game.player1) {
        opponentUsername = (game.player1 as any).username || 'Guest';
      }

      return {
        _id: game._id.toString(),
        roomId: game.roomId,
        roomCode: game.roomCode,
        boardSize: game.boardSize,
        board: game.board,
        winner: game.winner,
        winningLine: game.winningLine,
        result, // 'win' | 'loss' | 'draw'
        opponentUsername,
        finishedAt: game.finishedAt?.toISOString() || null,
        createdAt: game.createdAt.toISOString(),
        score: game.score,
      };
    });

    res.json({ history, total: history.length });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="backend/src/routes/gameRoutes.ts">
import { Router } from 'express';
import { createGame, getGame, getGameByCode, joinGame, getUserGames, leaveGame, getWaitingGames, getGameHistory } from '../controllers/gameController';
import { authMiddleware } from '../middleware/authMiddleware';

const router = Router();

router.post('/create', createGame);
router.get('/waiting', getWaitingGames);
router.get('/code/:roomCode', getGameByCode);
router.post('/history', getGameHistory);
router.get('/:roomId', getGame);
router.post('/:roomId/join', joinGame);
router.post('/:roomId/leave', leaveGame);
router.get('/user/:userId', authMiddleware, getUserGames);

export default router;
</file>

<file path="backend/src/services/gameEngine.ts">
import Game, { IGame } from '../models/Game';
import GameMove from '../models/GameMove';
import { checkWin } from './winChecker';
import { validateMove } from './ruleEngine';
import { PlayerNumber } from '../types/game.types';

export const initializeBoard = (boardSize: number): number[][] => {
  return Array(boardSize)
    .fill(null)
    .map(() => Array(boardSize).fill(0));
};

export const generateRoomCode = async (): Promise<string> => {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let roomCode: string;
  let isUnique = false;

  while (!isUnique) {
    roomCode = '';
    for (let i = 0; i < 6; i++) {
      roomCode += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    
    const existingGame = await Game.findOne({ roomCode });
    if (!existingGame) {
      isUnique = true;
    }
  }

  return roomCode!;
};

export const makeMove = async (
  game: IGame,
  row: number,
  col: number,
  player: PlayerNumber
): Promise<{ success: boolean; message?: string; game?: IGame }> => {
  // Validate move
  const validation = validateMove(game, row, col, player);
  if (!validation.valid) {
    return { success: false, message: validation.message };
  }

  // Make the move
  game.board[row][col] = player;
  game.currentPlayer = player === 1 ? 2 : 1;

  // Save move to history
  const moveCount = await GameMove.countDocuments({ gameId: game._id, isUndone: false });
  const moveNumber = moveCount + 1;
  const move = new GameMove({
    gameId: game._id,
    player,
    row,
    col,
    moveNumber,
    timestamp: new Date(),
    isUndone: false,
  });
  await move.save();

  // Check for win (with block two ends rule if enabled)
  const winResult = checkWin(game.board, row, col, player, game.boardSize, game.rules.blockTwoEnds);
  if (winResult.isWin) {
    game.gameStatus = 'finished';
    game.winner = player;
    game.finishedAt = new Date();
    
    // Save winning line
    if (winResult.winningLine) {
      (game as any).winningLine = winResult.winningLine;
    }
    
    // Update scores
    if (player === 1) {
      game.score.player1++;
    } else {
      game.score.player2++;
    }
    
    console.log(`[GameEngine] Game ${game.roomId} finished - Winner: Player ${player}, finishedAt: ${game.finishedAt}, winningLine:`, winResult.winningLine);
  }

  // Check for draw (board full)
  const isBoardFull = game.board.every(row => row.every(cell => cell !== 0));
  if (isBoardFull && !winResult.isWin) {
    game.gameStatus = 'finished';
    game.winner = 'draw';
    game.finishedAt = new Date();
    console.log(`[GameEngine] Game ${game.roomId} finished - Draw, finishedAt: ${game.finishedAt}`);
  }

  await game.save();
  console.log(`[GameEngine] Game ${game.roomId} saved with status: ${game.gameStatus}, finishedAt: ${game.finishedAt}`);

  return { success: true, game };
};

export const undoMove = async (
  game: IGame,
  moveNumber: number
): Promise<{ success: boolean; message?: string; game?: IGame }> => {
  if (!game.rules.allowUndo) {
    return { success: false, message: 'Undo is not allowed in this game' };
  }

  // Find the move
  const move = await GameMove.findOne({
    gameId: game._id,
    moveNumber,
    isUndone: false,
  });

  if (!move) {
    return { success: false, message: 'Move not found' };
  }

  // Check undo count
  const undoneMoves = await GameMove.countDocuments({
    gameId: game._id,
    isUndone: true,
  });

  if (undoneMoves >= game.rules.maxUndoPerGame) {
    return { success: false, message: 'Maximum undo limit reached' };
  }

  // Undo the move
  game.board[move.row][move.col] = 0;
  move.isUndone = true;
  await move.save();

  // Revert current player
  game.currentPlayer = move.player;
  game.gameStatus = 'playing';

  await game.save();

  return { success: true, game };
};
</file>

<file path="backend/src/services/socketService.ts">
import { Server as SocketIOServer } from 'socket.io';
import { Server as HTTPServer } from 'http';
import mongoose from 'mongoose';
import Game from '../models/Game';
import GameMove from '../models/GameMove';
import User from '../models/User';
import { makeMove, undoMove } from './gameEngine';
import { checkWin } from './winChecker';
import { PlayerNumber } from '../types/game.types';

interface SocketData {
  userId?: string;
  username?: string;
  isGuest?: boolean;
  playerId?: string;
  currentRoomId?: string;
}

export const setupSocketHandlers = (io: SocketIOServer): void => {
  io.on('connection', (socket) => {
    const socketData: SocketData = socket.data;

    // Join room
    socket.on('join-room', async (data: { roomId: string; playerId: string; isGuest: boolean }) => {
      try {
        const { roomId, playerId, isGuest } = data;
        socketData.currentRoomId = roomId;
        socketData.playerId = playerId;
        socketData.isGuest = isGuest;
        socket.join(roomId);

        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        // Socket should NOT assign player2 - only API joinGame should do that
        // Socket only handles joining the socket room for real-time communication
        // Player assignment is handled by the REST API joinGame endpoint

        // Emit current game state - only include players that actually exist and are set
        const players: any[] = [];
        
        // Add player1 if exists - populate username from User model
        if (game.player1) {
          const user1 = await User.findById(game.player1).select('username').lean();
          players.push({
            id: game.player1.toString(),
            username: user1?.username || 'Player 1',
            isGuest: false,
            playerNumber: 1,
          });
        } else if (game.player1GuestId) {
          players.push({
            id: game.player1GuestId,
            username: `Guest ${game.player1GuestId.slice(-6)}`,
            isGuest: true,
            playerNumber: 1,
          });
        }
        
        // Only add player2 if they actually exist (not null/undefined) - populate username from User model
        if (game.player2) {
          const user2 = await User.findById(game.player2).select('username').lean();
          players.push({
            id: game.player2.toString(),
            username: user2?.username || 'Player 2',
            isGuest: false,
            playerNumber: 2,
          });
        } else if (game.player2GuestId) {
          players.push({
            id: game.player2GuestId,
            username: `Guest ${game.player2GuestId.slice(-6)}`,
            isGuest: true,
            playerNumber: 2,
          });
        }

        // Emit room-joined with current game state
        socket.emit('room-joined', { 
          roomId, 
          players,
          gameStatus: game.gameStatus,
          currentPlayer: game.currentPlayer,
        });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Make move
    socket.on('make-move', async (data: { roomId: string; row: number; col: number }) => {
      try {
        const { roomId, row, col } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        console.log('Make move received:', { roomId, row, col, socketData });
        console.log('Game state:', {
          player1: game.player1?.toString(),
          player1GuestId: game.player1GuestId,
          player2: game.player2?.toString(),
          player2GuestId: game.player2GuestId,
          currentPlayer: game.currentPlayer,
          gameStatus: game.gameStatus,
        });

        // Determine player number - check both authenticated and guest
        let player: PlayerNumber = 1;
        let playerDetermined = false;
        
        console.log('Determining player - socketData:', {
          userId: socketData.userId,
          playerId: socketData.playerId,
          isGuest: socketData.isGuest,
        });
        
        // First check authenticated user
        if (socketData.userId) {
          if (game.player1?.toString() === socketData.userId) {
            player = 1;
            playerDetermined = true;
            console.log('Matched by authenticated userId as player1');
          } else if (game.player2?.toString() === socketData.userId) {
            player = 2;
            playerDetermined = true;
            console.log('Matched by authenticated userId as player2');
          }
        }
        
        // Check guest ID - this is the most common case for guest players
        // Check playerId first (most reliable)
        if (!playerDetermined && socketData.playerId) {
          if (game.player1GuestId && game.player1GuestId === socketData.playerId) {
            player = 1;
            playerDetermined = true;
            console.log('Matched by playerId as player1 (guest):', socketData.playerId);
          } else if (game.player2GuestId && game.player2GuestId === socketData.playerId) {
            player = 2;
            playerDetermined = true;
            console.log('Matched by playerId as player2 (guest):', socketData.playerId);
          } else {
            console.log('playerId did not match:', {
              socketPlayerId: socketData.playerId,
              gamePlayer1GuestId: game.player1GuestId,
              gamePlayer2GuestId: game.player2GuestId,
            });
          }
        }
        
        // Also check if authenticated user matches guest IDs (edge case)
        if (!playerDetermined && socketData.userId) {
          if (game.player1GuestId && game.player1GuestId === socketData.userId.toString()) {
            player = 1;
            playerDetermined = true;
            console.log('Matched by userId as guest player1');
          } else if (game.player2GuestId && game.player2GuestId === socketData.userId.toString()) {
            player = 2;
            playerDetermined = true;
            console.log('Matched by userId as guest player2');
          }
        }
        
        if (!playerDetermined) {
          console.error('Could not determine player - socketData:', JSON.stringify(socketData, null, 2), 'game:', {
            player1: game.player1?.toString(),
            player1GuestId: game.player1GuestId,
            player2: game.player2?.toString(),
            player2GuestId: game.player2GuestId,
          });
          socket.emit('game-error', { message: 'Could not determine player number. Please rejoin the room.' });
          return;
        }
        
        console.log('Player determined successfully:', player);

        console.log('Attempting move:', { row, col, player, currentPlayer: game.currentPlayer, gameStatus: game.gameStatus });

        const result = await makeMove(game, row, col, player);
        if (!result.success) {
          console.log('Move failed:', result.message);
          socket.emit('move-validated', { valid: false, message: result.message });
          return;
        }

        console.log('Move successful, reloading game to get latest state');

        // Reload game to get the latest state after makeMove
        const updatedGame = await Game.findOne({ roomId });
        if (!updatedGame) {
          socket.emit('game-error', { message: 'Game not found after move' });
          return;
        }

        // Get the move that was just made
        const move = await GameMove.findOne({
          gameId: updatedGame._id,
          row,
          col,
          player,
        }).sort({ timestamp: -1 });

        console.log('Emitting move-made to room:', {
          move: move ? { row: move.row, col: move.col, player: move.player } : null,
          currentPlayer: updatedGame.currentPlayer,
          gameStatus: updatedGame.gameStatus,
        });

        // Emit to all in room
        io.to(roomId).emit('move-made', {
          move: move ? {
            _id: move._id.toString(),
            gameId: move.gameId.toString(),
            player: move.player,
            row: move.row,
            col: move.col,
            moveNumber: move.moveNumber,
            timestamp: move.timestamp.toISOString(),
            isUndone: move.isUndone,
          } : null,
          board: updatedGame.board,
          currentPlayer: updatedGame.currentPlayer,
        });

        if (updatedGame.gameStatus === 'finished') {
          console.log('Game finished, emitting game-finished event');
          io.to(roomId).emit('game-finished', {
            winner: updatedGame.winner,
            reason: updatedGame.winner === 'draw' ? 'Draw' : `Player ${updatedGame.winner} wins!`,
          });
          io.to(roomId).emit('score-updated', { score: updatedGame.score });
        }
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Request undo
    socket.on('request-undo', async (data: { roomId: string; moveNumber: number }) => {
      try {
        const { roomId, moveNumber } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        const move = await GameMove.findOne({
          gameId: game._id,
          moveNumber,
        });

        if (!move) {
          socket.emit('game-error', { message: 'Move not found' });
          return;
        }

        // Emit to opponent
        socket.to(roomId).emit('undo-requested', {
          moveNumber,
          requestedBy: move.player,
        });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Approve undo
    socket.on('approve-undo', async (data: { roomId: string; moveNumber: number }) => {
      try {
        const { roomId, moveNumber } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        const result = await undoMove(game, moveNumber);
        if (!result.success) {
          socket.emit('game-error', { message: result.message });
          return;
        }

        io.to(roomId).emit('undo-approved', {
          moveNumber,
          board: game.board,
        });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Reject undo
    socket.on('reject-undo', (data: { roomId: string }) => {
      socket.to(data.roomId).emit('undo-rejected', { moveNumber: 0 });
    });

    // Start game
    socket.on('start-game', async (data: { roomId: string }) => {
      try {
        const { roomId } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        // Only allow starting if game is waiting and has 2 players
        if (game.gameStatus !== 'waiting') {
          socket.emit('game-error', { message: 'Game is not in waiting status' });
          return;
        }

        if (!game.player2 && !game.player2GuestId) {
          socket.emit('game-error', { message: 'Not enough players to start' });
          return;
        }

        // Determine which player is starting the game (whoever clicks start goes first)
        let startingPlayer: PlayerNumber = 1;
        let playerDetermined = false;

        // Check authenticated user ID first
        if (!playerDetermined && socketData.userId) {
          if (game.player1 && game.player1.toString() === socketData.userId.toString()) {
            startingPlayer = 1;
            playerDetermined = true;
          } else if (game.player2 && game.player2.toString() === socketData.userId.toString()) {
            startingPlayer = 2;
            playerDetermined = true;
          }
        }

        // Check guest ID - this is the most common case for guest players
        if (!playerDetermined && socketData.playerId) {
          if (game.player1GuestId && game.player1GuestId === socketData.playerId) {
            startingPlayer = 1;
            playerDetermined = true;
          } else if (game.player2GuestId && game.player2GuestId === socketData.playerId) {
            startingPlayer = 2;
            playerDetermined = true;
          }
        }

        // If still not determined, default to player1 (host)
        if (!playerDetermined) {
          startingPlayer = 1;
        }

        // Start the game with the player who clicked start going first
        game.gameStatus = 'playing';
        game.currentPlayer = startingPlayer;
        await game.save();

        // Emit to lobby about game status change
        io.emit('game-status-updated', {
          roomId: game.roomId,
          roomCode: game.roomCode,
          gameStatus: 'playing',
          displayStatus: 'playing',
          playerCount: 2,
          isFull: true,
        });

        io.to(roomId).emit('game-started', {
          currentPlayer: game.currentPlayer,
        });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Surrender
    socket.on('surrender', async (data: { roomId: string }) => {
      try {
        const { roomId } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        // Determine winner (opponent)
        let winner: PlayerNumber = 1;
        if (socketData.userId) {
          // Authenticated user
          if (game.player1?.toString() === socketData.userId) {
            winner = 2;
          }
        } else if (socketData.isGuest && socketData.playerId) {
          // Guest user
          if (game.player1GuestId === socketData.playerId) {
            winner = 2;
          } else if (game.player2GuestId === socketData.playerId) {
            winner = 1;
          }
        }

        game.gameStatus = 'finished';
        game.winner = winner;
        game.finishedAt = new Date();

        if (winner === 1) {
          game.score.player1++;
        } else {
          game.score.player2++;
        }

        await game.save();

        io.to(roomId).emit('game-finished', {
          winner,
          reason: 'Opponent surrendered',
        });
        io.to(roomId).emit('score-updated', { score: game.score });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // New game
    socket.on('new-game', async (data: { roomId: string }) => {
      try {
        const { roomId } = data;
        const game = await Game.findOne({ roomId });
        if (!game) {
          socket.emit('game-error', { message: 'Game not found' });
          return;
        }

        // Reset game but keep score
        game.board = Array(game.boardSize)
          .fill(null)
          .map(() => Array(game.boardSize).fill(0));
        game.currentPlayer = 1;
        game.gameStatus = 'playing';
        game.winner = null;
        game.finishedAt = null;

        await game.save();

        io.to(roomId).emit('move-made', {
          move: null,
          board: game.board,
          currentPlayer: game.currentPlayer,
        });
      } catch (error: any) {
        socket.emit('game-error', { message: error.message });
      }
    });

    // Leave room
    // Note: This is called AFTER the API leaveGame has been called
    // So we only need to leave the socket room, not update game state
    socket.on('leave-room', async (data: { roomId: string }) => {
      socket.leave(data.roomId);
      // The API leaveGame already emitted player-left event with proper data
      // We don't need to emit again here to avoid duplicate events
      socketData.currentRoomId = undefined;
    });

    // Disconnect
    // When socket disconnects (browser closed, network issue, etc.)
    // We need to handle player leave through API if they were in a game
    socket.on('disconnect', async () => {
      if (socketData.currentRoomId) {
        const roomId = socketData.currentRoomId;
        const playerId = socketData.userId || socketData.playerId;
        const isGuest = socketData.isGuest || !socketData.userId;
        
        try {
          // Find the game to determine which player is leaving
          const game = await Game.findOne({ roomId });
          if (!game) {
            // Game doesn't exist, nothing to do
            return;
          }

          // Determine which player is leaving
          let isPlayer1 = false;
          let isPlayer2 = false;
          
          if (playerId) {
            // Check if authenticated user is player1 or player2
            if (socketData.userId) {
              isPlayer1 = !!(game.player1 && game.player1.toString() === socketData.userId.toString());
              isPlayer2 = !!(game.player2 && game.player2.toString() === socketData.userId.toString());
            }
            
            // Also check if playerId matches guest IDs
            if (isGuest && playerId) {
              if (game.player1GuestId && game.player1GuestId === playerId) {
                isPlayer1 = true;
              }
              if (game.player2GuestId && game.player2GuestId === playerId) {
                isPlayer2 = true;
              }
            }
          }

          // Only process if player is actually in the game
          if (isPlayer1 || isPlayer2) {
            // Check players BEFORE removing
            const hasPlayer1Before = !!(game.player1 || game.player1GuestId);
            const hasPlayer2Before = !!(game.player2 || game.player2GuestId);
            const wasFinished = game.gameStatus === 'finished';
            
            // Capture player data BEFORE removing (for history saving)
            const player1Before = game.player1;
            const player2Before = game.player2;
            const player1GuestIdBefore = game.player1GuestId;
            const player2GuestIdBefore = game.player2GuestId;
            
            // Save history for authenticated user BEFORE removing player (if game finished)
            // This ensures history is saved even if only 1 player leaves
            // Also check if history already exists to avoid duplicates
            if (wasFinished && game.finishedAt) {
              const GameHistory = (await import('../models/GameHistory')).default;
              const existingHistory = await GameHistory.findOne({ roomId });
              
              if (!existingHistory) {
                // History not saved yet - save it now
                const leavingPlayerIsAuthenticated = isPlayer1 
                  ? !!(player1Before && !player1GuestIdBefore)
                  : !!(player2Before && !player2GuestIdBefore);
                
                if (leavingPlayerIsAuthenticated) {
                  const leavingPlayerId = isPlayer1 ? player1Before : player2Before;
                  
                  if (leavingPlayerId) {
                    const historyRecord = new GameHistory({
                      originalGameId: game._id.toString(),
                      roomId: game.roomId,
                      roomCode: game.roomCode,
                      gameType: game.gameType,
                      player1: player1Before, // Use captured data before removal
                      player2: player2Before, // Use captured data before removal
                      player1GuestId: null, // Don't save guest IDs to database
                      player2GuestId: null,
                      boardSize: game.boardSize,
                      board: game.board,
                      winner: game.winner,
                      winningLine: (game as any).winningLine, // Add winningLine
                      score: game.score,
                      rules: game.rules,
                      finishedAt: game.finishedAt,
                      createdAt: game.createdAt,
                      savedAt: new Date(),
                    });
                    await historyRecord.save();
                    console.log(`[socket disconnect] Saved history for authenticated player ${leavingPlayerId} before leaving`);
                  }
                }
              } else {
                console.log(`[socket disconnect] History already saved for game ${roomId}, skipping duplicate save`);
              }
            }

            // Remove the player from the game
            if (isPlayer1) {
              game.player1 = null;
              game.player1GuestId = null;
            } else if (isPlayer2) {
              game.player2 = null;
              game.player2GuestId = null;
            }

            // Check players AFTER removing
            const hasPlayer1After = !!(game.player1 || game.player1GuestId);
            const hasPlayer2After = !!(game.player2 || game.player2GuestId);
            const hasNoPlayers = !hasPlayer1After && !hasPlayer2After;

            let gameReset = false;
            let hostTransferred = false;

            if (hasNoPlayers) {
              // Case 1: Game finished + c·∫£ 2 player r·ªùi ‚Üí l∆∞u v√†o history v√† x√≥a game
              if (game.gameStatus === 'finished' && game.finishedAt) {
                const GameHistory = (await import('../models/GameHistory')).default;
                // Check if history was already saved by the first player who left
                const existingHistory = await GameHistory.findOne({ roomId });
                
                if (!existingHistory) {
                  // History not saved yet - save it now (for the second player leaving)
                  // Only save to database if at least one player is authenticated
                  const hasAuthenticatedPlayer = !!(player1Before || player2Before);
                  
                  if (hasAuthenticatedPlayer) {
                    // Use captured data before removal
                    const historyRecord = new GameHistory({
                      originalGameId: game._id.toString(),
                      roomId: game.roomId,
                      roomCode: game.roomCode,
                      gameType: game.gameType,
                      player1: player1Before, // Use captured data before removal
                      player2: player2Before, // Use captured data before removal
                      player1GuestId: null, // Don't save guest IDs to database
                      player2GuestId: null, // Guest history is handled on frontend
                      boardSize: game.boardSize,
                      board: game.board,
                      winner: game.winner,
                      winningLine: (game as any).winningLine, // Add winningLine
                      score: game.score,
                      rules: game.rules,
                      finishedAt: game.finishedAt,
                      createdAt: game.createdAt,
                      savedAt: new Date(),
                    });
                    await historyRecord.save();
                    
                    // Clean up old history - simplified version for socket disconnect
                    // Full cleanup logic is in gameController.leaveGame
                    // For disconnect, we just delete the game
                  }
                } else {
                  console.log(`[socket disconnect] History already saved for game ${roomId}, skipping duplicate save`);
                }
                
                await Game.deleteOne({ roomId });
                io.to(roomId).emit('game-deleted', { roomId });
                return;
              } else {
                // Case 3: Game ch∆∞a finished + c·∫£ 2 player r·ªùi ‚Üí x√≥a game
                await Game.deleteOne({ roomId });
                io.to(roomId).emit('game-deleted', { roomId });
                return;
              }
            } else {
              // If player1 (host) left and player2 still exists AFTER removal, transfer host to player2
              if (isPlayer1 && hasPlayer2After) {
                // Transfer player2 to player1 (host transfer)
                game.player1 = game.player2;
                game.player1GuestId = game.player2GuestId;
                game.player2 = null;
                game.player2GuestId = null;
                hostTransferred = true;
                console.log(`[socket disconnect] Host transferred: Player2 is now Player1`);
              }

              // Reset game if needed
              if (wasFinished || game.gameStatus === 'playing') {
                game.gameStatus = 'waiting';
                game.winner = null;
                game.finishedAt = null;
                game.board = Array(game.boardSize)
                  .fill(null)
                  .map(() => Array(game.boardSize).fill(0));
                game.currentPlayer = 1;
                gameReset = true;
              }

              await game.save();

              // Emit player-left event with proper data
              io.to(roomId).emit('player-left', {
                playerNumber: isPlayer1 ? 1 : 2,
                roomId,
                hostTransferred: hostTransferred,
                gameReset: gameReset,
              });
            }
          }
        } catch (error: any) {
          console.error('[socket disconnect] Error handling player leave:', error);
          // Still emit player-left event so frontend can reload
          io.to(roomId).emit('player-left', {
            playerId: playerId || 'guest',
            roomId,
          });
        }
      }
    });
  });
};
</file>

<file path="backend/src/server.ts">
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { createServer } from 'http';
import { connectDatabase } from './config/database';
import { setupSocketIO } from './config/socket.io';
import { errorHandler } from './middleware/errorHandler';
import { setupSocketHandlers } from './services/socketService';
import authRoutes from './routes/authRoutes';
import gameRoutes from './routes/gameRoutes';
import gameStatsRoutes from './routes/gameStatsRoutes';
import leaderboardRoutes from './routes/leaderboardRoutes';
import userRoutes from './routes/userRoutes';
import { authLimiter } from './middleware/rateLimiter';

// Load environment variables
dotenv.config();

const app = express();
const httpServer = createServer(app);
const io = setupSocketIO(httpServer);

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Apply rate limiting to auth routes
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/games', gameRoutes);
app.use('/api/games', gameStatsRoutes);
app.use('/api/leaderboard', leaderboardRoutes);
app.use('/api/users', userRoutes);

app.get('/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// Setup socket handlers
setupSocketHandlers(io);

// Error handler
app.use(errorHandler);

// Start server
const PORT = process.env.PORT || 5001;

const startServer = async () => {
  try {
    await connectDatabase();
    httpServer.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

export { io };
</file>

<file path="frontend/src/components/GameBoard/GameCell.tsx">
import React, { memo } from 'react';
import { Box } from '@mui/material';

interface GameCellProps {
  value: number; // 0 = empty, 1 = player1, 2 = player2
  row: number;
  col: number;
  onClick: (row: number, col: number) => void;
  disabled: boolean;
  boardSize: number;
  cellSize: number;
  isLastMove?: boolean;
  isWinningCell?: boolean;
}

const GameCell: React.FC<GameCellProps> = ({
  value,
  row,
  col,
  onClick,
  disabled,
  cellSize,
  isLastMove = false,
  isWinningCell = false,
}) => {
  const getCellContent = () => {
    if (value === 1) {
      return '‚úï'; // Player 1 - X symbol
    } else if (value === 2) {
      return '‚óã'; // Player 2 - O symbol
    }
    return '';
  };

  const getCellColor = () => {
    if (value === 1) return '#5ba8c7'; // Sky blue for Player 1
    if (value === 2) return '#88d6b7'; // Mint green for Player 2
    return 'transparent';
  };

  const handleClick = (): void => {
    if (!disabled && value === 0) {
      onClick(row, col);
    }
  };

  return (
    <Box
      onClick={handleClick}
      sx={{
        width: `${cellSize}px`,
        height: `${cellSize}px`,
        minWidth: `${cellSize}px`,
        minHeight: `${cellSize}px`,
        border: isWinningCell
          ? '3px solid #ff6b6b'
          : isLastMove 
          ? '2px solid rgba(126, 200, 227, 0.8)'
          : '1px solid rgba(126, 200, 227, 0.3)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        cursor: disabled || value !== 0 ? 'default' : 'pointer',
        backgroundColor: value === 0 ? '#ffffff' : '#ffffff',
        background: isWinningCell && value !== 0
          ? `linear-gradient(135deg, ${value === 1 ? 'rgba(255, 107, 107, 0.25)' : 'rgba(255, 107, 107, 0.25)'} 0%, ${value === 1 ? 'rgba(255, 107, 107, 0.35)' : 'rgba(255, 107, 107, 0.35)'} 100%)`
          : isLastMove && value !== 0
          ? `linear-gradient(135deg, ${value === 1 ? 'rgba(126, 200, 227, 0.15)' : 'rgba(168, 230, 207, 0.15)'} 0%, ${value === 1 ? 'rgba(126, 200, 227, 0.22)' : 'rgba(168, 230, 207, 0.22)'} 100%)`
          : value === 0 
          ? '#ffffff'
          : '#ffffff',
        transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        position: 'relative',
        boxShadow: isWinningCell
          ? '0 0 12px rgba(255, 107, 107, 0.5), inset 0 0 6px rgba(255, 107, 107, 0.2)'
          : isLastMove 
          ? '0 0 8px rgba(126, 200, 227, 0.35), inset 0 0 4px rgba(126, 200, 227, 0.15)'
          : 'none',
        '&:hover': {
          background: value === 0 && !disabled 
            ? 'linear-gradient(135deg, rgba(126, 200, 227, 0.1) 0%, rgba(168, 230, 207, 0.1) 100%)'
            : undefined,
          boxShadow: value === 0 && !disabled ? 'inset 0 0 0 2px rgba(126, 200, 227, 0.4)' : undefined,
          transform: value === 0 && !disabled ? 'scale(1.02)' : undefined,
          zIndex: value === 0 && !disabled ? 1 : undefined,
        },
        fontSize: `${cellSize * 0.65}px`,
        fontWeight: 800,
        color: getCellColor(),
        textShadow: value !== 0 ? '0 2px 4px rgba(0,0,0,0.1)' : 'none',
        '&::before': value !== 0 ? {
          content: '""',
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          animation: 'fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        } : {},
        '@keyframes fadeIn': {
          from: { 
            opacity: 0,
            transform: 'scale(0.8)',
          },
          to: { 
            opacity: 1,
            transform: 'scale(1)',
          },
        },
      }}
    >
      {getCellContent()}
    </Box>
  );
};

const MemoizedGameCell = memo(GameCell);
MemoizedGameCell.displayName = 'GameCell';

export default MemoizedGameCell;
</file>

<file path="frontend/src/contexts/GameContext.tsx">
import React, { createContext, useContext, useState, useEffect, useCallback, useRef, useMemo, ReactNode } from 'react';
import { Game, GameMove, PlayerInfo, PlayerNumber, Winner } from '../types/game.types';
import { socketService } from '../services/socketService';
import { getGuestId } from '../utils/guestId';
import { useAuth } from './AuthContext';
import { gameApi, gameStatsApi } from '../services/api';
import { saveGuestHistory } from '../utils/guestHistory';
import { logger } from '../utils/logger';

interface GameContextType {
  game: Game | null;
  players: PlayerInfo[];
  currentPlayer: PlayerNumber;
  isMyTurn: boolean;
  myPlayerNumber: PlayerNumber | null;
  roomId: string | null;
  pendingUndoMove: number | null;
  undoRequestSent: boolean;
  lastMove: { row: number; col: number } | null;
  setGame: (game: Game | null) => void;
  joinRoom: (roomId: string) => void;
  makeMove: (row: number, col: number) => void;
  requestUndo: (moveNumber: number) => void;
  approveUndo: (moveNumber: number) => void;
  rejectUndo: () => void;
  surrender: () => void;
  startGame: () => void;
  newGame: () => void;
  leaveRoom: () => Promise<void>;
  clearPendingUndo: () => void;
}

const GameContext = createContext<GameContextType | undefined>(undefined);

// Helper function to convert game data to players array
// Note: This is a fallback - real usernames come from socket events
const gameToPlayers = (game: Game): PlayerInfo[] => {
  const players: PlayerInfo[] = [];
  
  if (game.player1) {
    players.push({
      id: game.player1,
      username: 'Player 1', // Will be updated from socket event with real username
      isGuest: false,
      playerNumber: 1,
    });
  } else if (game.player1GuestId) {
    players.push({
      id: game.player1GuestId,
      username: `Guest ${game.player1GuestId.slice(-6)}`,
      isGuest: true,
      playerNumber: 1,
    });
  }
  
  if (game.player2) {
    players.push({
      id: game.player2,
      username: 'Player 2', // Will be updated from socket event with real username
      isGuest: false,
      playerNumber: 2,
    });
  } else if (game.player2GuestId) {
    players.push({
      id: game.player2GuestId,
      username: `Guest ${game.player2GuestId.slice(-6)}`,
      isGuest: true,
      playerNumber: 2,
    });
  }
  
  return players;
};

export const GameProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { user, isAuthenticated } = useAuth();
  const [game, setGame] = useState<Game | null>(null);
  const [players, setPlayers] = useState<PlayerInfo[]>([]);
  const [roomId, setRoomId] = useState<string | null>(null);
  const [myPlayerNumber, setMyPlayerNumber] = useState<PlayerNumber | null>(null);
  const [pendingUndoMove, setPendingUndoMove] = useState<number | null>(null);
  const [undoRequestSent, setUndoRequestSent] = useState<boolean>(false);
  const [lastMove, setLastMove] = useState<{ row: number; col: number } | null>(null);
  
  // Ref to track RAF IDs for cleanup
  const rafIdRef = useRef<number | null>(null);
  
  // Update players when game changes (only if players array is empty or doesn't match)
  // This ensures we have initial players, but socket events take precedence for real-time updates
  useEffect(() => {
    if (game) {
      const gamePlayers = gameToPlayers(game);
      
      // Use functional update to avoid dependency on players array
      setPlayers(prevPlayers => {
        // Only update if players array is empty or significantly different
        // This prevents overriding socket updates
        if (prevPlayers.length === 0 || 
            (gamePlayers.length > prevPlayers.length && 
             !gamePlayers.every(p => prevPlayers.some(ep => ep.id === p.id)))) {
          
          // Update my player number
          // Need to check both authenticated user ID and guest ID
          // because user might have created game as guest, then logged in
          const guestId = getGuestId();
          const authenticatedUserId = isAuthenticated ? user?._id : null;
          
          // Try to find player by matching either authenticated user ID or guest ID
          const myPlayer = gamePlayers.find(p => {
            // Check if this player matches authenticated user ID
            if (authenticatedUserId && p.id === authenticatedUserId && !p.isGuest) {
              return true;
            }
            // Check if this player matches guest ID
            if (guestId && p.id === guestId && p.isGuest) {
              return true;
            }
            // Also check if game data has our IDs (for edge cases)
            if (authenticatedUserId && game.player1 === authenticatedUserId && p.playerNumber === 1 && !p.isGuest) {
              return true;
            }
            if (guestId && game.player1GuestId === guestId && p.playerNumber === 1 && p.isGuest) {
              return true;
            }
            if (authenticatedUserId && game.player2 === authenticatedUserId && p.playerNumber === 2 && !p.isGuest) {
              return true;
            }
            if (guestId && game.player2GuestId === guestId && p.playerNumber === 2 && p.isGuest) {
              return true;
            }
            return false;
          });
          
          if (myPlayer) {
            // Update my player number - will be set after state update completes
            const playerNumber = myPlayer.playerNumber;
            // Cleanup previous RAF if exists
            if (rafIdRef.current !== null) {
              cancelAnimationFrame(rafIdRef.current);
            }
            // Use requestAnimationFrame to avoid state update during render
            rafIdRef.current = requestAnimationFrame(() => {
              setMyPlayerNumber(playerNumber);
              rafIdRef.current = null;
            });
          }
          
          return gamePlayers;
        }
        return prevPlayers;
      });
    }
    
    // Cleanup RAF on unmount or dependency change
    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [game, isAuthenticated, user?._id]);

  useEffect(() => {
    const socket = socketService.getSocket();
    if (!socket) return;

    // Track if component is mounted to prevent state updates after unmount
    let isMounted = true;
    const pendingTimeouts: NodeJS.Timeout[] = [];

    const handleRoomJoined = (data: { roomId: string; players: PlayerInfo[]; gameStatus?: string; currentPlayer?: PlayerNumber }) => {
      setRoomId(data.roomId);
      // Update players from socket - this ensures real-time sync
      setPlayers(data.players);
      
      // Determine my player number
      // Need to check both authenticated user ID and guest ID
      const guestId = getGuestId();
      const authenticatedUserId = isAuthenticated ? user?._id : null;
      
      logger.log('Room-joined: Trying to match my player - authenticatedUserId:', authenticatedUserId, 'isAuthenticated:', isAuthenticated, 'guestId:', guestId);
      logger.log('Room-joined: Available players:', data.players);
      
      // Try to find player by matching either authenticated user ID or guest ID
      const myPlayer = data.players.find(p => {
        // Check if this player matches authenticated user ID
        if (authenticatedUserId && p.id === authenticatedUserId && !p.isGuest) {
          logger.log('Room-joined: Matched by authenticated user ID:', p);
          return true;
        }
        // Check if this player matches guest ID
        if (guestId && p.id === guestId && p.isGuest) {
          logger.log('Room-joined: Matched by guest ID:', p);
          return true;
        }
        return false;
      });
      
      if (myPlayer) {
        setMyPlayerNumber(myPlayer.playerNumber);
        logger.log('Player number set from room-joined:', myPlayer.playerNumber, 'for player:', myPlayer);
      } else {
        logger.warn('Could not find my player in players list:', data.players, 'authenticatedUserId:', authenticatedUserId, 'guestId:', guestId, 'isGuest:', !isAuthenticated);
        setMyPlayerNumber(null);
      }
      
      // Update game state with information from socket - use functional update to avoid dependency issues
      setGame(prevGame => {
        if (!prevGame) return prevGame;
        return {
          ...prevGame,
          gameStatus: (data.gameStatus as any) || prevGame.gameStatus,
          currentPlayer: data.currentPlayer || prevGame.currentPlayer,
        };
      });
    };

    const handlePlayerJoined = async (data: { player: PlayerInfo }) => {
      if (!isMounted) return;
      
      // Update players list
      setPlayers(prev => {
        // Check if player already exists
        const exists = prev.some(p => p.id === data.player.id);
        if (exists) {
          return prev;
        }
        
        const updated = [...prev, data.player];
        // Update my player number if this is me joining
        const guestId = getGuestId();
        const myId = isAuthenticated ? user?._id : guestId;
        if (data.player.id === myId && 
            ((isAuthenticated && !data.player.isGuest) || (!isAuthenticated && data.player.isGuest))) {
          setMyPlayerNumber(data.player.playerNumber);
        }
        return updated;
      });
      
      // Only reload game state if we don't have complete game data
      // Socket events should provide most updates, reducing API calls
      if (roomId && isMounted && (!game || !game.player2)) {
        try {
          const updatedGame = await gameApi.getGame(roomId);
          if (isMounted) {
            setGame(updatedGame);
            // Game state reloaded successfully
          }
        } catch (error) {
          logger.error('Failed to reload game state after player joined:', error);
        }
      }
      
      // Don't auto-update game status - wait for start button
    };

    const handlePlayerLeft = async (data: { playerId?: string; playerNumber?: number; roomId?: string; hostTransferred?: boolean; gameReset?: boolean }) => {
      if (!isMounted) return;
      
      // Check if this event is for our current room
      const isForCurrentRoom = !data.roomId || data.roomId === roomId;
      const hasRelevantData = data.hostTransferred || data.playerNumber !== undefined || data.playerId || data.gameReset;
      
      // Update players list immediately from socket data if available
      if (data.playerNumber) {
        setPlayers(prev => prev.filter(p => p.playerNumber !== data.playerNumber));
      }
      
      // Only reload game state if we have roomId and this event is relevant
      // Throttle API calls - only reload if game status might have changed significantly
      if (roomId && (isForCurrentRoom || hasRelevantData) && isMounted) {
        try {
          const updatedGame = await gameApi.getGame(roomId);
          if (!isMounted) return;
          
          setGame(updatedGame);
          
          // Update players list from game data
          const gamePlayers = gameToPlayers(updatedGame);
          setPlayers(gamePlayers);
          
          // Update my player number
          const guestId = getGuestId();
          const authenticatedUserId = isAuthenticated ? user?._id : null;
          
          const myPlayer = gamePlayers.find(p => {
            if (authenticatedUserId && p.id === authenticatedUserId && !p.isGuest) return true;
            if (guestId && p.id === guestId && p.isGuest) return true;
            return false;
          });
          
          if (myPlayer) {
            setMyPlayerNumber(myPlayer.playerNumber);
          }
        } catch (error: any) {
          logger.error('Failed to reload game state after player left:', error);
          // If game was deleted (404), clear state immediately
          if (error.response?.status === 404) {
            logger.log('Game was deleted (404) - clearing state immediately');
            setRoomId(null);
            setGame(null);
            setPlayers([]);
            setMyPlayerNumber(null);
            return;
          }
          // Fallback: manually update players list if reload fails
          if (data.playerNumber) {
            setPlayers(prev => {
              const filtered = prev.filter(p => p.playerNumber !== data.playerNumber);
              // If no players left, clear game state
              if (filtered.length === 0) {
                setGame(null);
                setRoomId(null);
                setMyPlayerNumber(null);
              }
              return filtered;
            });
          } else if (data.playerId) {
            setPlayers(prev => {
              const filtered = prev.filter(p => p.id !== data.playerId);
              // If no players left, clear game state
              if (filtered.length === 0) {
                setGame(null);
                setRoomId(null);
                setMyPlayerNumber(null);
              }
              return filtered;
            });
          }
        }
        return;
      }
      
      // If we don't have roomId but received player-left event, try to reload if we have game
      if (!roomId && game && game.roomId) {
        logger.log('No roomId in state, but have game.roomId, reloading...');
        try {
          const updatedGame = await gameApi.getGame(game.roomId);
          if (isMounted) {
            setGame(updatedGame);
            const gamePlayers = gameToPlayers(updatedGame);
            setPlayers(gamePlayers);
            logger.log('Game state reloaded using game.roomId');
          }
        } catch (error) {
          logger.error('Failed to reload game state:', error);
        }
        return;
      }
      
      // If game is deleted, clear everything
      if (data.roomId && data.roomId === roomId) {
        setGame(prevGame => {
          if (!prevGame) return prevGame;
          return {
            ...prevGame,
            gameStatus: 'abandoned' as any,
          };
        });
      }
    };

    const handleGameDeleted = (data: { roomId: string }) => {
      // If this is our game, clear everything immediately
      if (data.roomId === roomId) {
        setRoomId(null);
        setGame(null);
        setPlayers([]);
        setMyPlayerNumber(null);
        // Note: Navigation will be handled by GameRoomPage useEffect that watches for game === null
      }
    };

    const handleMoveMade = (data: { move: GameMove | null; board: number[][]; currentPlayer: PlayerNumber }) => {
      setGame(prevGame => {
        if (!prevGame) {
          logger.warn('Received move-made but no game state');
          return prevGame;
        }
        // Removed verbose logging to improve performance
        return {
          ...prevGame,
          board: data.board,
          currentPlayer: data.currentPlayer,
          gameStatus: 'playing', // Ensure game status is playing
        };
      });
      // Update last move for highlighting (keep it permanently)
      if (data.move) {
        setLastMove({ row: data.move.row, col: data.move.col });
      }
      // Reset undo request sent when a new move is made
      setUndoRequestSent(false);
    };

    const handleGameFinished = async (data: { winner: Winner; reason: string }) => {
      // Capture game data before updating state to avoid stale closure
      let finishedGameData: { 
        roomId: string; 
        roomCode: string; 
        boardSize: number;
        board: number[][];
        winner: Winner;
        winningLine?: Array<{ row: number; col: number }>;
        score: { player1: number; player2: number };
        createdAt: string;
        finishedAt: string | null;
      } | null = null;
      
      setGame(prevGame => {
        if (!prevGame) return prevGame;
        // Capture game data before state update
        finishedGameData = {
          roomId: prevGame.roomId,
          roomCode: prevGame.roomCode,
          boardSize: prevGame.boardSize,
          board: prevGame.board,
          winner: data.winner,
          winningLine: prevGame.winningLine,
          score: prevGame.score,
          createdAt: prevGame.createdAt,
          finishedAt: prevGame.finishedAt,
        };
        return {
          ...prevGame,
          gameStatus: 'finished',
          winner: data.winner,
        };
      });

      // Submit game result to stats API if user is authenticated
      // Use setTimeout to ensure state is updated
      // Note: This timeout is inside a socket handler, cleanup handled by socket cleanup
      // Capture values from closure to avoid stale values
      const currentIsAuthenticated = isAuthenticated;
      const currentUser = user;
      const currentMyPlayerNumber = myPlayerNumber;
      const currentPlayers = players;
      
      const timeoutId = setTimeout(async () => {
        if (!isMounted) return;
        
        // Save guest history to localStorage if user is guest
        if (!currentIsAuthenticated && finishedGameData && currentMyPlayerNumber) {
          try {
            // Find opponent username
            const opponent = currentPlayers.find(p => p.playerNumber !== currentMyPlayerNumber);
            const opponentUsername = opponent?.username || 'Unknown';
            
            // Determine result
            let myResult: 'win' | 'loss' | 'draw';
            const winner = finishedGameData.winner;
            if (winner === 'draw' || winner === null) {
              myResult = 'draw';
            } else if (currentMyPlayerNumber === winner) {
              myResult = 'win';
            } else {
              myResult = 'loss';
            }
            
            // Save to localStorage
            saveGuestHistory({
              roomId: finishedGameData.roomId,
              roomCode: finishedGameData.roomCode,
              boardSize: finishedGameData.boardSize,
              board: finishedGameData.board,
              winner: finishedGameData.winner,
              winningLine: finishedGameData.winningLine,
              score: finishedGameData.score,
              finishedAt: finishedGameData.finishedAt,
              createdAt: finishedGameData.createdAt,
              myPlayerNumber: currentMyPlayerNumber,
              opponentUsername,
              result: myResult,
            });
            
            logger.log('[GameContext] Saved guest history to localStorage');
          } catch (error) {
            logger.error('[GameContext] Failed to save guest history:', error);
            // Don't block UI if localStorage save fails
          }
        }
        
        // Submit to stats API if authenticated
        if (currentIsAuthenticated && currentUser && finishedGameData && currentMyPlayerNumber) {
          try {
            // Determine result: winner can be 1, 2, 'draw', or null
            let myResult: 'win' | 'loss' | 'draw';
            const winner = finishedGameData.winner;
            if (winner === 'draw' || winner === null) {
              myResult = 'draw';
            } else if (currentMyPlayerNumber === winner) {
              myResult = 'win';
            } else {
              myResult = 'loss';
            }
            
            await gameStatsApi.submitGameResult(
              'caro', // gameId
              myResult,
              undefined, // score will be calculated on server
              undefined, // customStats
              {
                roomId: finishedGameData.roomId,
                roomCode: finishedGameData.roomCode,
                boardSize: finishedGameData.boardSize,
              }
            );
          } catch (error) {
            logger.error('Failed to submit game result:', error);
            // Don't block UI if stats submission fails
          }
        }
      }, 100);
      pendingTimeouts.push(timeoutId);
    };

    const handleScoreUpdated = (data: { score: { player1: number; player2: number } }) => {
      setGame(prevGame => {
        if (!prevGame) return prevGame;
        return {
          ...prevGame,
          score: data.score,
        };
      });
    };

    const handleUndoRequested = (data: { moveNumber: number; requestedBy: PlayerNumber }) => {
      // Only show dialog if it's not my move (opponent wants to undo)
      // Use current myPlayerNumber from closure
      const currentMyPlayerNumber = myPlayerNumber;
      if (data.requestedBy !== currentMyPlayerNumber) {
        setPendingUndoMove(data.moveNumber);
      }
    };

    const handleUndoApproved = (data: { moveNumber: number; board: number[][] }) => {
      setGame(prevGame => {
        if (!prevGame) return prevGame;
        return {
          ...prevGame,
          board: data.board,
        };
      });
      setPendingUndoMove(null);
      setUndoRequestSent(false);
      setLastMove(null); // Clear last move highlight when undo
    };

    const handleUndoRejected = (data: { moveNumber: number }) => {
      // When opponent rejects our undo request
      setUndoRequestSent(false);
    };

    const handleGameStarted = (data: { currentPlayer: PlayerNumber }) => {
      setGame(prevGame => {
        if (!prevGame) return prevGame;
        return {
          ...prevGame,
          gameStatus: 'playing',
          currentPlayer: data.currentPlayer,
        };
      });
      setLastMove(null); // Clear last move when game starts
    };

    const handleGameError = (data: { message: string }) => {
      logger.error('Game error received:', data.message);
      alert(`Game Error: ${data.message}`);
    };

    const handleMoveValidated = (data: { valid: boolean; message?: string }) => {
      logger.log('Move validated event received:', data);
      if (!data.valid) {
        logger.warn('Move was invalid:', data.message);
        alert(`Invalid move: ${data.message}`);
      }
    };

    socket.on('room-joined', handleRoomJoined);
    socket.on('player-joined', handlePlayerJoined);
    socket.on('player-left', handlePlayerLeft);
    socket.on('game-deleted', handleGameDeleted);
    socket.on('move-made', handleMoveMade);
    socket.on('move-validated', handleMoveValidated);
    socket.on('game-finished', handleGameFinished);
    socket.on('score-updated', handleScoreUpdated);
    socket.on('undo-requested', handleUndoRequested);
    socket.on('undo-approved', handleUndoApproved);
    socket.on('undo-rejected', handleUndoRejected);
    socket.on('game-started', handleGameStarted);
    socket.on('game-error', handleGameError);

    return () => {
      // Mark as unmounted to prevent state updates
      isMounted = false;
      
      // Clear all pending timeouts
      pendingTimeouts.forEach((timeoutId: NodeJS.Timeout) => clearTimeout(timeoutId));
      pendingTimeouts.length = 0;
      
      // Remove all socket listeners
      socket.off('room-joined', handleRoomJoined);
      socket.off('player-joined', handlePlayerJoined);
      socket.off('player-left', handlePlayerLeft);
      socket.off('game-deleted', handleGameDeleted);
      socket.off('move-made', handleMoveMade);
      socket.off('move-validated', handleMoveValidated);
      socket.off('game-finished', handleGameFinished);
      socket.off('score-updated', handleScoreUpdated);
      socket.off('undo-requested', handleUndoRequested);
      socket.off('undo-approved', handleUndoApproved);
      socket.off('undo-rejected', handleUndoRejected);
      socket.off('game-started', handleGameStarted);
      socket.off('game-error', handleGameError);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAuthenticated, user, myPlayerNumber, roomId]);

  const joinRoom = useCallback((newRoomId: string): void => {
    const socket = socketService.getSocket();
    if (!socket) return;

    // Don't join if already in this room
    if (newRoomId === roomId) {
      return;
    }

    const guestId = getGuestId();
    
    // Determine playerId based on game data
    // If game has guestId for this player, use guestId; otherwise use userId
    let playerId: string;
    let isGuest: boolean;
    
    if (game) {
      // Check if this player is in the game as guest or authenticated
      const myId = isAuthenticated ? user?._id : guestId;
      const isPlayer1Guest = game.player1GuestId && game.player1GuestId === guestId;
      const isPlayer2Guest = game.player2GuestId && game.player2GuestId === guestId;
      const isPlayer1Auth = game.player1 && game.player1 === myId;
      const isPlayer2Auth = game.player2 && game.player2 === myId;
      
      if (isPlayer1Guest || isPlayer2Guest) {
        // Player is in game as guest, use guestId
        playerId = guestId;
        isGuest = true;
      } else if (isPlayer1Auth || isPlayer2Auth) {
        // Player is in game as authenticated, use userId
        playerId = user?._id || '';
        isGuest = false;
      } else {
        // Not yet in game, use guestId if not authenticated, userId if authenticated
        playerId = isAuthenticated ? user?._id || '' : guestId;
        isGuest = !isAuthenticated;
      }
    } else {
      // No game data yet, use default logic
      playerId = isAuthenticated ? user?._id || '' : guestId;
      isGuest = !isAuthenticated;
    }

    // Removed verbose logging to improve performance
    socket.emit('join-room', { roomId: newRoomId, playerId, isGuest });
    setRoomId(newRoomId);
  }, [isAuthenticated, user?._id, roomId, game]);

  const makeMove = useCallback((row: number, col: number): void => {
    if (!roomId) {
      logger.error('Cannot make move: no roomId');
      return;
    }
    const socket = socketService.getSocket();
    if (!socket) {
      logger.error('Cannot make move: socket not connected');
      return;
    }

    socket.emit('make-move', { roomId, row, col });
  }, [roomId]);

  const requestUndo = useCallback((moveNumber: number): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    setUndoRequestSent(true);
    socket.emit('request-undo', { roomId, moveNumber });
  }, [roomId]);

  const approveUndo = useCallback((moveNumber: number): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    socket.emit('approve-undo', { roomId, moveNumber });
  }, [roomId]);

  const rejectUndo = useCallback((): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    socket.emit('reject-undo', { roomId });
    setPendingUndoMove(null);
  }, [roomId]);

  const clearPendingUndo = useCallback((): void => {
    setPendingUndoMove(null);
  }, []);

  const surrender = useCallback((): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    socket.emit('surrender', { roomId });
  }, [roomId]);

  const startGame = useCallback((): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    socket.emit('start-game', { roomId });
  }, [roomId]);

  const newGame = useCallback((): void => {
    if (!roomId) return;
    const socket = socketService.getSocket();
    if (!socket) return;

    socket.emit('new-game', { roomId });
  }, [roomId]);

  const leaveRoom = useCallback(async (): Promise<void> => {
    if (!roomId) return;
    
    try {
      // Call API to leave game (this will remove player and delete game if no players remain)
      await gameApi.leaveGame(roomId);
      
      // Emit socket event to leave the room
      const socket = socketService.getSocket();
      if (socket) {
        socket.emit('leave-room', { roomId });
      }
      
      // Clear local state
      setRoomId(null);
      setGame(null);
      setPlayers([]);
      setMyPlayerNumber(null);
    } catch (error) {
      logger.error('Failed to leave game:', error);
      // Still clear local state even if API call fails
      setRoomId(null);
      setGame(null);
      setPlayers([]);
      setMyPlayerNumber(null);
      throw error;
    }
  }, [roomId]);

  const currentPlayer = game?.currentPlayer || 1;
  const isMyTurn = myPlayerNumber !== null && currentPlayer === myPlayerNumber;

  // Memoize context value to prevent unnecessary re-renders
  const contextValue = useMemo(() => ({
    game,
    players,
    currentPlayer,
    isMyTurn,
    myPlayerNumber,
    roomId,
    pendingUndoMove,
    undoRequestSent,
    lastMove,
    setGame,
    joinRoom,
    makeMove,
    requestUndo,
    approveUndo,
    rejectUndo,
    surrender,
    startGame,
    newGame,
    leaveRoom,
    clearPendingUndo,
  }), [
    game,
    players,
    currentPlayer,
    isMyTurn,
    myPlayerNumber,
    roomId,
    pendingUndoMove,
    undoRequestSent,
    lastMove,
    joinRoom,
    makeMove,
    requestUndo,
    approveUndo,
    rejectUndo,
    surrender,
    startGame,
    newGame,
    leaveRoom,
    clearPendingUndo,
  ]);

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
};

export const useGame = (): GameContextType => {
  const context = useContext(GameContext);
  if (context === undefined) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};
</file>

<file path="frontend/src/pages/JoinGamePage.tsx">
import React, { useState } from 'react';
import { Box, Container, Paper, TextField, Button, Typography, CircularProgress } from '@mui/material';
import { useNavigate, Link } from 'react-router-dom';
import { gameApi } from '../services/api';
import { validateRoomCode, formatRoomCode } from '../utils/roomCode';

const JoinGamePage: React.FC = () => {
  const navigate = useNavigate();
  const [roomCode, setRoomCode] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleJoin = async (): Promise<void> => {
    setError('');
    
    const formattedCode = formatRoomCode(roomCode);
    if (!validateRoomCode(formattedCode)) {
      setError('Room code must be 6 characters (A-Z, 0-9)');
      return;
    }

    setLoading(true);
    try {
      const game = await gameApi.getGameByCode(formattedCode);
      
      // Allow joining if game is waiting OR if it's playing but not full
      const canJoin = game.gameStatus === 'waiting' || 
                     (game.gameStatus === 'playing' && (!game.player2 && !game.player2GuestId));

      if (!canJoin && game.gameStatus !== 'waiting') {
        setError('This game is already full or finished');
        setLoading(false);
        return;
      }

      // Join the game
      await gameApi.joinGame(game.roomId);
      navigate(`/game/${game.roomId}`);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Game not found. Please check the room code.');
      setLoading(false);
    }
  };

  const handleCodeChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
    setRoomCode(value);
    setError('');
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        background: 'linear-gradient(135deg, #f8fbff 0%, #ffffff 50%, #f0f9ff 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        py: { xs: 4, md: 6 },
      }}
    >
      <Container maxWidth="sm">
        <Box sx={{ textAlign: 'center', mb: 5 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1.5, mb: 2 }}>
            <Typography
              component="span"
              sx={{
                fontSize: { xs: '2rem', md: '3rem' },
                lineHeight: 1,
              }}
            >
              üéØ
            </Typography>
            <Typography 
              variant="h3" 
              sx={{
                background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                backgroundClip: 'text',
                fontWeight: 700,
                fontSize: { xs: '2rem', md: '3rem' },
                m: 0,
              }}
            >
              Join Game
            </Typography>
          </Box>
          <Typography 
            variant="h6" 
            sx={{ 
              color: '#5a6a7a', 
              fontWeight: 400,
              fontSize: { xs: '1rem', md: '1.1rem' },
            }}
          >
            Enter the room code to join a game
          </Typography>
        </Box>

        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, md: 5 },
            background: '#ffffff',
            border: '2px solid transparent',
            borderRadius: 4,
            backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'padding-box, border-box',
            boxShadow: '0 12px 40px rgba(168, 230, 207, 0.15)',
            transition: 'all 0.3s ease',
            '&:hover': {
              boxShadow: '0 16px 48px rgba(168, 230, 207, 0.2)',
            },
          }}
        >
          <TextField
            fullWidth
            label="Room Code"
            value={roomCode}
            onChange={handleCodeChange}
            placeholder="ABC123"
            inputProps={{
              maxLength: 6,
              style: {
                textAlign: 'center',
                fontSize: '28px',
                fontFamily: 'monospace',
                letterSpacing: 5,
                fontWeight: 'bold',
              },
            }}
            InputLabelProps={{
              shrink: true,
            }}
            sx={{ 
              mb: 3,
              '& .MuiOutlinedInput-root': {
                borderRadius: 2,
              },
              '& .MuiInputLabel-root': {
                transform: 'translate(14px, 20px) scale(1)',
                '&.MuiInputLabel-shrink': {
                  transform: 'translate(14px, -9px) scale(0.75)',
                },
              },
              '& .MuiOutlinedInput-input': {
                padding: '16.5px 14px',
              },
            }}
            autoFocus
          />

          {error && (
            <Box sx={{ 
              mb: 3, 
              p: 2, 
              borderRadius: 2, 
              bgcolor: 'rgba(255, 170, 165, 0.1)',
              border: '1px solid rgba(255, 170, 165, 0.3)',
            }}>
              <Typography color="error" variant="body2" sx={{ textAlign: 'center', fontWeight: 500 }}>
                {error}
              </Typography>
            </Box>
          )}

          <Button
            variant="contained"
            size="large"
            fullWidth
            onClick={handleJoin}
            disabled={loading || roomCode.length !== 6}
            sx={{ 
              mb: 2,
              py: 1.75,
              borderRadius: 2,
              textTransform: 'none',
              fontSize: '1rem',
              fontWeight: 700,
              boxShadow: '0 4px 14px rgba(168, 230, 207, 0.4)',
              background: 'linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
              '&:hover': {
                background: 'linear-gradient(135deg, #88d6b7 0%, #5ba8c7 100%)',
                boxShadow: '0 6px 20px rgba(168, 230, 207, 0.5)',
              },
              '&:disabled': {
                background: 'linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%)',
                color: '#9e9e9e',
                boxShadow: 'none',
                cursor: 'not-allowed',
                opacity: 0.6,
              },
            }}
            startIcon={loading ? <CircularProgress size={20} sx={{ color: '#ffffff' }} /> : null}
          >
            {loading ? 'Joining...' : 'üéÆ Join Game'}
          </Button>

          <Button 
            component={Link} 
            to="/" 
            fullWidth 
            variant="outlined"
            sx={{ 
              borderRadius: 2,
              textTransform: 'none',
              py: 1.25,
            }}
          >
            Back to Home
          </Button>
        </Paper>
        <Box sx={{ textAlign: 'center', mt: 3 }}>
          <Button 
            component={Link} 
            to="/" 
            variant="text"
            sx={{ 
              textTransform: 'none',
              color: '#7ec8e3',
              fontWeight: 600,
              '&:hover': {
                background: 'rgba(126, 200, 227, 0.08)',
              },
            }}
          >
            ‚Üê Back to Home
          </Button>
        </Box>
      </Container>
    </Box>
  );
};

export default JoinGamePage;
</file>

<file path="frontend/src/pages/LeaderboardPage.tsx">
import React, { useEffect, useState } from 'react';
import { Container, Box, Typography, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Tabs, Tab, CircularProgress } from '@mui/material';
import { leaderboardApi } from '../services/api';
import { useAuth } from '../contexts/AuthContext';
import { logger } from '../utils/logger';

interface LeaderboardEntry {
  rank: number;
  userId: string;
  username: string;
  score: number;
  wins: number;
  losses?: number;
  draws?: number;
}

interface LeaderboardData {
  gameId: string;
  period: string;
  rankings: LeaderboardEntry[];
  limit: number;
  offset: number;
  total: number;
}

const LeaderboardPage: React.FC = () => {
  const { user } = useAuth();
  const [gameId] = useState<string>('caro');
  const [period, setPeriod] = useState<'daily' | 'weekly' | 'all-time'>('all-time');
  const [leaderboard, setLeaderboard] = useState<LeaderboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [userRank, setUserRank] = useState<{ rank: number | null; totalPlayers: number; userStats: any } | null>(null);

  const loadLeaderboard = async (): Promise<void> => {
    try {
      setLoading(true);
      const data = await leaderboardApi.getLeaderboard(gameId, period, 50, 0);
      setLeaderboard(data);
    } catch (error) {
      logger.error('Failed to load leaderboard:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadUserRank = async (): Promise<void> => {
    if (!user) return;
    try {
      const rankData = await leaderboardApi.getUserRank(gameId, user._id, period);
      setUserRank(rankData);
    } catch (error) {
      logger.error('Failed to load user rank:', error);
    }
  };

  useEffect(() => {
    loadLeaderboard();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameId, period]);

  useEffect(() => {
    if (user) {
      loadUserRank();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user, gameId, period]);

  const handlePeriodChange = (_event: React.SyntheticEvent, newValue: number): void => {
    const periods: ('daily' | 'weekly' | 'all-time')[] = ['daily', 'weekly', 'all-time'];
    setPeriod(periods[newValue]);
  };

  if (loading) {
    return (
      <Container maxWidth="md" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
          <CircularProgress sx={{ color: '#7ec8e3' }} />
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ py: { xs: 4, md: 6 } }}>
      <Box sx={{ mb: 4, textAlign: 'center' }}>
        <Typography 
          variant="h3" 
          gutterBottom
          sx={{
            background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            backgroundClip: 'text',
            fontWeight: 700,
            fontSize: { xs: '2rem', md: '3rem' },
            mb: 2,
          }}
        >
          üèÜ Leaderboard
        </Typography>
        <Typography variant="body1" sx={{ color: '#5a6a7a', fontSize: '1.1rem', mb: 3 }}>
          Top players ranked by score - {gameId.toUpperCase()}
        </Typography>

        {/* Period Tabs */}
        <Box sx={{ display: 'flex', justifyContent: 'center', mb: 3 }}>
          <Tabs
            value={period === 'daily' ? 0 : period === 'weekly' ? 1 : 2}
            onChange={handlePeriodChange}
            sx={{
              '& .MuiTab-root': {
                textTransform: 'none',
                fontWeight: 600,
                fontSize: '0.95rem',
                minWidth: 100,
              },
              '& .Mui-selected': {
                color: '#7ec8e3',
              },
            }}
          >
            <Tab label="Daily" />
            <Tab label="Weekly" />
            <Tab label="All Time" />
          </Tabs>
        </Box>

        {/* User Rank Display */}
        {user && userRank && userRank.rank !== null && (
          <Paper
            elevation={0}
            sx={{
              p: 2,
              mb: 3,
              bgcolor: 'rgba(126, 200, 227, 0.1)',
              border: '1px solid rgba(126, 200, 227, 0.3)',
              borderRadius: 2,
              display: 'inline-block',
            }}
          >
            <Typography variant="body1" sx={{ color: '#2c3e50', fontWeight: 600 }}>
              Your Rank: <span style={{ color: '#7ec8e3', fontWeight: 700 }}>#{userRank.rank}</span> out of {userRank.totalPlayers} players
            </Typography>
          </Paper>
        )}
      </Box>

      <TableContainer 
        component={Paper}
        elevation={0}
        sx={{
          background: '#ffffff',
          border: '2px solid transparent',
          borderRadius: 4,
          backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
          backgroundOrigin: 'border-box',
          backgroundClip: 'padding-box, border-box',
          boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
          overflow: 'hidden',
        }}
      >
        <Table>
          <TableHead>
            <TableRow sx={{ bgcolor: 'rgba(126, 200, 227, 0.08)' }}>
              <TableCell sx={{ fontWeight: 700, color: '#2c3e50', fontSize: '0.95rem' }}>Rank</TableCell>
              <TableCell sx={{ fontWeight: 700, color: '#2c3e50', fontSize: '0.95rem' }}>Username</TableCell>
              <TableCell align="right" sx={{ fontWeight: 700, color: '#2c3e50', fontSize: '0.95rem' }}>Wins</TableCell>
              <TableCell align="right" sx={{ fontWeight: 700, color: '#2c3e50', fontSize: '0.95rem' }}>Score</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {leaderboard?.rankings.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} align="center" sx={{ py: 4 }}>
                  <Typography variant="body1" sx={{ color: '#5a6a7a' }}>
                    No players yet. Be the first!
                  </Typography>
                </TableCell>
              </TableRow>
            ) : (
              leaderboard?.rankings.map((entry, index) => (
                <TableRow 
                  key={entry.userId}
                  sx={{ 
                    '&:hover': { 
                      bgcolor: 'rgba(126, 200, 227, 0.05)',
                    },
                    transition: 'background-color 0.2s ease',
                    bgcolor: user && entry.userId === user._id ? 'rgba(126, 200, 227, 0.1)' : 'transparent',
                  }}
                >
                  <TableCell>
                    <Box sx={{ 
                      display: 'inline-flex', 
                      alignItems: 'center', 
                      justifyContent: 'center',
                      width: 32,
                      height: 32,
                      borderRadius: '50%',
                      bgcolor: index < 3 ? 'rgba(126, 200, 227, 0.15)' : 'rgba(0,0,0,0.05)',
                      fontWeight: 700,
                      color: '#2c3e50',
                    }}>
                      {entry.rank}
                    </Box>
                  </TableCell>
                  <TableCell sx={{ fontWeight: 600, color: '#2c3e50' }}>{entry.username}</TableCell>
                  <TableCell align="right" sx={{ color: '#a8e6cf', fontWeight: 600 }}>{entry.wins}</TableCell>
                  <TableCell align="right" sx={{ color: '#7ec8e3', fontWeight: 700, fontSize: '1.05rem' }}>{entry.score}</TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    </Container>
  );
};

export default LeaderboardPage;
</file>

<file path="frontend/src/pages/LoginPage.tsx">
import React, { useState } from 'react';
import { Box, Container, Paper, TextField, Button, Typography, Tabs, Tab } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

const LoginPage: React.FC = () => {
  const navigate = useNavigate();
  const { login, register } = useAuth();
  const [tab, setTab] = useState(0);
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleLogin = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await login(email, password);
      navigate('/');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  const handleRegister = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await register(username, email, password);
      navigate('/');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="sm">
      <Box sx={{ 
        marginTop: { xs: 4, md: 8 },
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: { xs: 'auto', md: '80vh' },
      }}>
        <Paper 
          elevation={0}
          sx={{ 
            padding: { xs: 3, md: 5 },
            background: '#ffffff',
            border: '2px solid transparent',
            borderRadius: 4,
            backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'padding-box, border-box',
            boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
            width: '100%',
            maxWidth: '480px',
          }}
        >
          <Box sx={{ textAlign: 'center', mb: 3 }}>
            <Typography 
              component="h1" 
              variant="h4" 
              gutterBottom
              sx={{
                background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                backgroundClip: 'text',
                fontWeight: 700,
                fontSize: { xs: '1.75rem', md: '2.25rem' },
                mb: 1,
              }}
            >
              {tab === 0 ? 'üîê Login' : '‚ú® Register'}
            </Typography>
            <Typography variant="body2" sx={{ color: '#5a6a7a', fontSize: '0.95rem' }}>
              {tab === 0 ? 'Welcome back!' : 'Create your account'}
            </Typography>
          </Box>

          <Tabs 
            value={tab} 
            onChange={(_, newValue) => setTab(newValue)} 
            sx={{ 
              mb: 3,
              '& .MuiTab-root': {
                textTransform: 'none',
                fontWeight: 600,
                fontSize: '1rem',
                minHeight: 48,
              },
            }}
          >
            <Tab label="Login" />
            <Tab label="Register" />
          </Tabs>

          {tab === 0 ? (
            <Box component="form" onSubmit={handleLogin}>
              <TextField
                margin="normal"
                required
                fullWidth
                label="Email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                autoFocus
                sx={{ 
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                label="Password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                sx={{ 
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              {error && (
                <Box sx={{ 
                  mb: 2, 
                  p: 1.5, 
                  borderRadius: 2, 
                  bgcolor: 'rgba(255, 170, 165, 0.1)',
                  border: '1px solid rgba(255, 170, 165, 0.3)',
                }}>
                  <Typography color="error" variant="body2" sx={{ textAlign: 'center', fontWeight: 500 }}>
                    {error}
                  </Typography>
                </Box>
              )}
              <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ 
                  mt: 2, 
                  mb: 2,
                  py: 1.5,
                  borderRadius: 2,
                  textTransform: 'none',
                  fontSize: '1rem',
                  fontWeight: 700,
                }}
                disabled={loading}
              >
                {loading ? 'Logging in...' : 'Login'}
              </Button>
            </Box>
          ) : (
            <Box component="form" onSubmit={handleRegister}>
              <TextField
                margin="normal"
                required
                fullWidth
                label="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                autoFocus
                sx={{ 
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                label="Email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                sx={{ 
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                label="Password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                sx={{ 
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                  },
                }}
              />
              {error && (
                <Box sx={{ 
                  mb: 2, 
                  p: 1.5, 
                  borderRadius: 2, 
                  bgcolor: 'rgba(255, 170, 165, 0.1)',
                  border: '1px solid rgba(255, 170, 165, 0.3)',
                }}>
                  <Typography color="error" variant="body2" sx={{ textAlign: 'center', fontWeight: 500 }}>
                    {error}
                  </Typography>
                </Box>
              )}
              <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ 
                  mt: 2, 
                  mb: 2,
                  py: 1.5,
                  borderRadius: 2,
                  textTransform: 'none',
                  fontSize: '1rem',
                  fontWeight: 700,
                }}
                disabled={loading}
              >
                {loading ? 'Registering...' : 'Register'}
              </Button>
            </Box>
          )}

          <Button 
            fullWidth 
            onClick={() => navigate('/')} 
            variant="outlined"
            sx={{ 
              mt: 1,
              py: 1.25,
              borderRadius: 2,
              textTransform: 'none',
            }}
          >
            Continue as Guest
          </Button>
        </Paper>
      </Box>
    </Container>
  );
};

export default LoginPage;
</file>

<file path="frontend/src/pages/ProfilePage.tsx">
import React, { useEffect, useState } from 'react';
import { Container, Box, Typography, Paper, Tabs, Tab, CircularProgress } from '@mui/material';
import { useAuth } from '../contexts/AuthContext';
import { userApi } from '../services/api';
import { User } from '../types/user.types';
import { logger } from '../utils/logger';

interface GameStats {
  _id: string;
  gameId: string;
  gameName: string;
  wins: number;
  losses: number;
  draws: number;
  totalScore: number;
  customStats: any;
  lastPlayed: string;
  createdAt: string;
  updatedAt: string;
}

interface UserGamesData {
  userId: string;
  games: GameStats[];
  totalGames: number;
}

const ProfilePage: React.FC = () => {
  const { user } = useAuth();
  const [profile, setProfile] = useState<User | null>(null);
  const [gameStats, setGameStats] = useState<UserGamesData | null>(null);
  const [selectedGame, setSelectedGame] = useState<string>('caro');
  const [loading, setLoading] = useState(true);
  const [statsLoading, setStatsLoading] = useState(true);

  useEffect(() => {
    if (user) {
      loadProfile();
      loadGameStats();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user]);

  const loadProfile = async (): Promise<void> => {
    if (!user) return;
    try {
      const userData = await userApi.getMyProfile();
      setProfile(userData);
    } catch (error) {
      logger.error('Failed to load profile:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadGameStats = async (): Promise<void> => {
    if (!user) return;
    try {
      setStatsLoading(true);
      const data = await userApi.getUserGames(user._id);
      setGameStats(data);
    } catch (error) {
      logger.error('Failed to load game stats:', error);
    } finally {
      setStatsLoading(false);
    }
  };

  const handleGameTabChange = (_event: React.SyntheticEvent, newValue: number): void => {
    if (gameStats && gameStats.games[newValue]) {
      setSelectedGame(gameStats.games[newValue].gameId);
    }
  };

  if (!user) {
    return (
      <Container maxWidth="md" sx={{ py: 8 }}>
        <Box sx={{ textAlign: 'center' }}>
          <Typography variant="h6" sx={{ color: '#5a6a7a' }}>Please login to view your profile</Typography>
        </Box>
      </Container>
    );
  }

  if (loading) {
    return (
      <Container maxWidth="md" sx={{ py: 8 }}>
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
          <CircularProgress sx={{ color: '#7ec8e3' }} />
        </Box>
      </Container>
    );
  }

  const currentGameStats = gameStats?.games.find(g => g.gameId === selectedGame) || null;

  return (
    <Container maxWidth="md" sx={{ py: { xs: 4, md: 6 } }}>
      <Box sx={{ mb: 4, textAlign: 'center' }}>
        <Typography 
          variant="h3" 
          gutterBottom
          sx={{
            background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            backgroundClip: 'text',
            fontWeight: 700,
            fontSize: { xs: '2rem', md: '3rem' },
            mb: 2,
          }}
        >
          üë§ Profile
        </Typography>
      </Box>

      {/* User Info */}
      <Paper 
        elevation={0}
        sx={{ 
          p: { xs: 3, md: 5 },
          mb: 3,
          background: '#ffffff',
          border: '2px solid transparent',
          borderRadius: 4,
          backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
          backgroundOrigin: 'border-box',
          backgroundClip: 'padding-box, border-box',
          boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
        }}
      >
        <Box sx={{ mb: 4, pb: 3, borderBottom: '2px solid rgba(126, 200, 227, 0.2)' }}>
          <Typography 
            variant="h4" 
            gutterBottom 
            sx={{ 
              color: '#2c3e50', 
              fontWeight: 700,
              fontSize: { xs: '1.75rem', md: '2.25rem' },
              mb: 1,
            }}
          >
            {profile?.username}
          </Typography>
          <Typography 
            variant="body1" 
            sx={{ 
              color: '#5a6a7a',
              fontSize: '1.05rem',
            }}
          >
            üìß {profile?.email}
          </Typography>
        </Box>
      </Paper>

      {/* Game Stats */}
      {statsLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
          <CircularProgress sx={{ color: '#7ec8e3' }} />
        </Box>
      ) : gameStats && gameStats.games.length > 0 ? (
        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, md: 4 },
            background: '#ffffff',
            border: '2px solid transparent',
            borderRadius: 4,
            backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'padding-box, border-box',
            boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
          }}
        >
          <Typography 
            variant="h5" 
            sx={{ 
              mb: 3,
              color: '#2c3e50',
              fontWeight: 700,
              fontSize: '1.5rem',
            }}
          >
            üìä Game Statistics
          </Typography>

          {/* Game Tabs */}
          {gameStats.games.length > 1 && (
            <Box sx={{ mb: 3, borderBottom: 1, borderColor: 'divider' }}>
              <Tabs
                value={gameStats.games.findIndex(g => g.gameId === selectedGame)}
                onChange={handleGameTabChange}
                sx={{
                  '& .MuiTab-root': {
                    textTransform: 'none',
                    fontWeight: 600,
                    fontSize: '0.95rem',
                  },
                  '& .Mui-selected': {
                    color: '#7ec8e3',
                  },
                }}
              >
                {gameStats.games.map((game) => (
                  <Tab key={game.gameId} label={game.gameName || game.gameId} />
                ))}
              </Tabs>
            </Box>
          )}

          {/* Current Game Stats */}
          {currentGameStats ? (
            <Box>
              <Typography 
                variant="h6" 
                sx={{ 
                  mb: 2,
                  color: '#2c3e50',
                  fontWeight: 600,
                  fontSize: '1.1rem',
                }}
              >
                {currentGameStats.gameName || currentGameStats.gameId.toUpperCase()}
              </Typography>
              <Box sx={{ 
                display: 'grid', 
                gridTemplateColumns: { xs: '1fr', sm: '1fr 1fr' }, 
                gap: 2.5,
              }}>
                <Box sx={{ 
                  p: 2.5, 
                  borderRadius: 3, 
                  bgcolor: 'rgba(168, 230, 207, 0.1)',
                  border: '1px solid rgba(168, 230, 207, 0.3)',
                }}>
                  <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 0.5, fontWeight: 600 }}>
                    Wins
                  </Typography>
                  <Typography variant="h4" sx={{ color: '#a8e6cf', fontWeight: 700 }}>
                    {currentGameStats.wins}
                  </Typography>
                </Box>
                <Box sx={{ 
                  p: 2.5, 
                  borderRadius: 3, 
                  bgcolor: 'rgba(255, 170, 165, 0.1)',
                  border: '1px solid rgba(255, 170, 165, 0.3)',
                }}>
                  <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 0.5, fontWeight: 600 }}>
                    Losses
                  </Typography>
                  <Typography variant="h4" sx={{ color: '#ffaaa5', fontWeight: 700 }}>
                    {currentGameStats.losses}
                  </Typography>
                </Box>
                <Box sx={{ 
                  p: 2.5, 
                  borderRadius: 3, 
                  bgcolor: 'rgba(255, 184, 140, 0.1)',
                  border: '1px solid rgba(255, 184, 140, 0.3)',
                }}>
                  <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 0.5, fontWeight: 600 }}>
                    Draws
                  </Typography>
                  <Typography variant="h4" sx={{ color: '#ffb88c', fontWeight: 700 }}>
                    {currentGameStats.draws}
                  </Typography>
                </Box>
                <Box sx={{ 
                  p: 2.5, 
                  borderRadius: 3, 
                  bgcolor: 'rgba(126, 200, 227, 0.1)',
                  border: '1px solid rgba(126, 200, 227, 0.3)',
                }}>
                  <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 0.5, fontWeight: 600 }}>
                    Total Score
                  </Typography>
                  <Typography variant="h4" sx={{ color: '#7ec8e3', fontWeight: 700 }}>
                    {currentGameStats.totalScore}
                  </Typography>
                </Box>
              </Box>
              {currentGameStats.lastPlayed && (
                <Typography variant="caption" sx={{ color: '#8a9ba8', mt: 2, display: 'block' }}>
                  Last played: {new Date(currentGameStats.lastPlayed).toLocaleDateString()}
                </Typography>
              )}
            </Box>
          ) : (
            <Box sx={{ textAlign: 'center', py: 4 }}>
              <Typography variant="body1" sx={{ color: '#5a6a7a' }}>
                No statistics available for this game yet.
              </Typography>
            </Box>
          )}
        </Paper>
      ) : (
        <Paper 
          elevation={0}
          sx={{ 
            p: { xs: 3, md: 4 },
            background: '#ffffff',
            border: '2px solid transparent',
            borderRadius: 4,
            backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'padding-box, border-box',
            boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
            textAlign: 'center',
          }}
        >
          <Typography variant="body1" sx={{ color: '#5a6a7a', py: 4 }}>
            No game statistics yet. Start playing to see your stats!
          </Typography>
        </Paper>
      )}
    </Container>
  );
};

export default ProfilePage;
</file>

<file path="frontend/src/types/socket.types.ts">
import { Game, GameMove, PlayerInfo, PlayerNumber, Winner } from './game.types';
import { GameRules, GameScore } from './game.types';

// Client ‚Üí Server Events
export interface ClientToServerEvents {
  'join-room': (data: { roomId: string; playerId: string; isGuest: boolean }) => void;
  'leave-room': (data: { roomId: string }) => void;
  'make-move': (data: { roomId: string; row: number; col: number }) => void;
  'request-undo': (data: { roomId: string; moveNumber: number }) => void;
  'approve-undo': (data: { roomId: string; moveNumber: number }) => void;
  'reject-undo': (data: { roomId: string }) => void;
  'surrender': (data: { roomId: string }) => void;
  'start-game': (data: { roomId: string }) => void;
  'new-game': (data: { roomId: string }) => void;
  'update-rules': (data: { roomId: string; rules: GameRules }) => void;
}

// Server ‚Üí Client Events
export interface ServerToClientEvents {
  'room-joined': (data: { roomId: string; players: PlayerInfo[]; gameStatus?: string; currentPlayer?: PlayerNumber }) => void;
  'player-joined': (data: { player: PlayerInfo }) => void;
  'player-left': (data: { playerId?: string; playerNumber?: number; roomId?: string; hostTransferred?: boolean; gameReset?: boolean }) => void;
  'game-deleted': (data: { roomId: string }) => void;
  'move-made': (data: { move: GameMove | null; board: number[][]; currentPlayer: PlayerNumber }) => void;
  'move-validated': (data: { valid: boolean; message?: string }) => void;
  'undo-requested': (data: { moveNumber: number; requestedBy: PlayerNumber }) => void;
  'undo-approved': (data: { moveNumber: number; board: number[][] }) => void;
  'undo-rejected': (data: { moveNumber: number }) => void;
  'game-finished': (data: { winner: Winner; reason: string }) => void;
  'game-started': (data: { currentPlayer: PlayerNumber }) => void;
  'game-error': (data: { message: string }) => void;
  'score-updated': (data: { score: GameScore }) => void;
  'game-created': (data: { roomId: string; roomCode: string; boardSize: number; gameStatus: string; player1Username: string | null; createdAt: string }) => void;
  'game-status-updated': (data: { roomId: string; roomCode: string; gameStatus: string; displayStatus: 'waiting' | 'ready' | 'playing'; playerCount: number; isFull: boolean }) => void;
}
</file>

<file path="frontend/src/utils/constants.ts">
export const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api';
export const SOCKET_URL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5001';

export const BOARD_SIZES = [3, 15, 20, 25] as const;
export const DEFAULT_BOARD_SIZE = 15;

export const GUEST_ID_KEY = 'caro_guest_id';
</file>

<file path="README.md">
# C·ªù Caro Game

A real-time multiplayer Tic-Tac-Toe (C·ªù Caro) game built with React and Node.js.

## Features

- **Guest Play**: Play without registration (temporary games)
- **User Accounts**: Register and track your statistics
- **Leaderboard**: See top players ranked by score
- **Real-time Multiplayer**: Play with others using WebSocket
- **Configurable Rules**: 
  - Block Two Ends rule (Ch·∫∑n 2 ƒë·∫ßu)
  - Configurable board size (15x15, 20x20, etc.)
  - Undo moves with opponent approval
- **Game Features**:
  - Surrender
  - Leave game
  - Request undo (with approval)
  - Score tracking across multiple games
  - New game in same room

## Tech Stack

### Frontend
- React 18 with TypeScript
- Material-UI (MUI)
- Socket.io-client
- React Router

### Backend
- Node.js with Express
- TypeScript
- MongoDB with Mongoose
- Socket.io
- JWT Authentication
- bcryptjs for password hashing

## Setup

### Prerequisites
- Node.js 16+
- MongoDB (local or cloud)
- npm or yarn

### Backend Setup

1. Navigate to backend directory:
```bash
cd backend
```

2. Install dependencies:
```bash
npm install
```

3. Create `.env` file:
```env
PORT=5000
MONGODB_URI=mongodb://localhost:27017/caro-game
JWT_SECRET=your-secret-key-change-in-production
NODE_ENV=development
FRONTEND_URL=http://localhost:3000
```

4. Start the server:
```bash
npm run dev
```

Backend will run on `http://localhost:5000`

### Frontend Setup

1. Navigate to frontend directory:
```bash
cd frontend
```

2. Install dependencies:
```bash
npm install
```

3. Create `.env` file:
```env
REACT_APP_API_BASE_URL=http://localhost:5000/api
REACT_APP_SOCKET_URL=http://localhost:5000
```

4. Start the development server:
```bash
npm start
```

Frontend will run on `http://localhost:3000`

## Project Structure

```
.
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/     # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contexts/       # Context providers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/          # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/       # API and socket services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/          # TypeScript types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/          # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/    # Route controllers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/       # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/         # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/         # Express routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/     # Express middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/         # Configuration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/          # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

## API Endpoints

### Authentication
- `POST /api/auth/register` - Register new user
- `POST /api/auth/login` - Login
- `GET /api/auth/me` - Get current user

### Games
- `POST /api/games/create` - Create new game
- `GET /api/games/:roomId` - Get game state
- `POST /api/games/:roomId/join` - Join game
- `GET /api/games/user/:userId` - Get user's games

### Leaderboard
- `GET /api/leaderboard` - Get top players
- `GET /api/leaderboard/user/:userId` - Get user rank

### Users
- `GET /api/users/:userId` - Get user profile
- `PUT /api/users/:userId` - Update profile

## WebSocket Events

### Client ‚Üí Server
- `join-room` - Join a game room
- `leave-room` - Leave a game room
- `make-move` - Make a move
- `request-undo` - Request to undo a move
- `approve-undo` - Approve undo request
- `reject-undo` - Reject undo request
- `surrender` - Surrender the game
- `new-game` - Start a new game in the same room

### Server ‚Üí Client
- `room-joined` - Confirmed room join
- `player-joined` - Another player joined
- `player-left` - A player left
- `move-made` - A move was made
- `game-finished` - Game ended
- `score-updated` - Score updated
- `undo-requested` - Undo request received
- `undo-approved` - Undo was approved
- `undo-rejected` - Undo was rejected
- `game-error` - Game error occurred

## Game Rules

### Win Condition
- 5 in a row (horizontal, vertical, or diagonal)

### Block Two Ends (Ch·∫∑n 2 ƒë·∫ßu)
- When enabled, prevents moves that would allow opponent to have open 4 at both ends
- This is a common rule in C·ªù Caro to prevent easy wins

### Undo
- Players can request to undo their last move
- Opponent must approve the undo
- Limited number of undos per game (default: 3)

## Development

### Backend
```bash
npm run dev    # Development with hot reload
npm run build  # Build for production
npm start      # Run production build
```

### Frontend
```bash
npm start      # Development server
npm run build  # Build for production
npm test       # Run tests
```

## License

ISC
</file>

<file path="frontend/src/components/GameBoard/GameBoard.tsx">
import React, { useRef, useEffect, useState, useMemo, useCallback } from 'react';
import { Box, Paper } from '@mui/material';
import GameCell from './GameCell';
import { useGame } from '../../contexts/GameContext';

const GameBoard: React.FC = () => {
  const { game, isMyTurn, makeMove, lastMove } = useGame();
  const containerRef = useRef<HTMLDivElement>(null);
  const boardRef = useRef<HTMLDivElement>(null);
  const [cellSize, setCellSize] = useState(50);
  
  // Memoize winning cells to avoid recalculating on every render
  const winningCellsSet = useMemo(() => {
    if (!game?.winningLine) return new Set<string>();
    return new Set(
      game.winningLine.map(line => `${line.row}-${line.col}`)
    );
  }, [game?.winningLine]);

  const handleCellClick = useCallback((row: number, col: number): void => {
    // Only allow clicks if it's my turn, game is playing, and cell is empty
    if (!game) return;
    if (isMyTurn && game.gameStatus === 'playing' && game.board[row]?.[col] === 0) {
      makeMove(row, col);
    }
  }, [game, isMyTurn, makeMove]);

  useEffect(() => {
    if (!game) return;
    
    let timeoutId: NodeJS.Timeout | null = null;
    let rafId: number | null = null;
    let lastUpdateTime = 0;
    const THROTTLE_MS = 100; // Throttle to max once per 100ms

    const updateCellSize = (): void => {
      if (containerRef.current && game) {
        const containerWidth = containerRef.current.offsetWidth;
        const maxWidth = Math.min(containerWidth * 0.9, 800);
        const calculatedSize = Math.min(maxWidth / game.boardSize, 60);
        const finalSize = Math.max(calculatedSize, 35); // Minimum 35px
        setCellSize(finalSize);
      }
    };

    const throttledUpdate = (): void => {
      const now = Date.now();
      
      // Clear any pending updates
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      // If enough time has passed, update immediately
      if (now - lastUpdateTime >= THROTTLE_MS) {
        lastUpdateTime = now;
        updateCellSize();
      } else {
        // Otherwise, schedule update for later
        const delay = THROTTLE_MS - (now - lastUpdateTime);
        timeoutId = setTimeout(() => {
          lastUpdateTime = Date.now();
          updateCellSize();
          timeoutId = null;
        }, delay);
      }
    };

    // Initial update
    updateCellSize();
    lastUpdateTime = Date.now();

    // Use requestAnimationFrame for smoother updates during zoom
    const handleResize = (): void => {
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
      rafId = requestAnimationFrame(throttledUpdate);
    };

    window.addEventListener('resize', handleResize, { passive: true });
    
    return () => {
      window.removeEventListener('resize', handleResize);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [game?.boardSize]); // Only re-run when boardSize changes

  if (!game) {
    return <div>No game loaded</div>;
  }

  return (
    <Box
      ref={containerRef}
      sx={{
        width: '100%',
        maxWidth: '800px',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        margin: '0 auto',
        mb: 3,
        mx: 'auto',
      }}
    >
      <Paper
        elevation={0}
        sx={{
          p: { xs: 2, md: 4 },
          background: '#ffffff',
          borderRadius: 4,
          boxShadow: '0 12px 40px rgba(126, 200, 227, 0.15)',
          border: '2px solid rgba(126, 200, 227, 0.2)',
          transition: 'all 0.3s ease',
        }}
      >
        <Box
          sx={{
            position: 'relative',
            display: 'grid',
            gridTemplateColumns: `repeat(${game.boardSize}, 1fr)`,
            gap: 0,
            border: '3px solid #7ec8e3',
            borderRadius: 2,
            overflow: 'hidden',
            boxShadow: 'inset 0 2px 8px rgba(126, 200, 227, 0.1)',
          }}
          ref={boardRef}
        >
          {game.board.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
              const cellKey = `${rowIndex}-${colIndex}`;
              const isWinningCell = winningCellsSet.has(cellKey);
              const isLastMoveCell = lastMove !== null && lastMove.row === rowIndex && lastMove.col === colIndex;
              return (
                <GameCell
                  key={cellKey}
                  value={cell}
                  row={rowIndex}
                  col={colIndex}
                  onClick={handleCellClick}
                  disabled={!isMyTurn || game.gameStatus !== 'playing'}
                  boardSize={game.boardSize}
                  cellSize={cellSize}
                  isLastMove={isLastMoveCell}
                  isWinningCell={isWinningCell}
                />
              );
            })
          )}
          {/* Winning line overlay */}
          {game.winningLine && game.winningLine.length >= 2 && (
            <svg
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                zIndex: 10,
              }}
            >
              <line
                x1={(game.winningLine[0].col + 0.5) * cellSize}
                y1={(game.winningLine[0].row + 0.5) * cellSize}
                x2={(game.winningLine[game.winningLine.length - 1].col + 0.5) * cellSize}
                y2={(game.winningLine[game.winningLine.length - 1].row + 0.5) * cellSize}
                stroke="#ff6b6b"
                strokeWidth={4}
                strokeLinecap="round"
                opacity={0.8}
              />
            </svg>
          )}
        </Box>
      </Paper>
    </Box>
  );
};

export default GameBoard;
</file>

<file path="frontend/src/components/GameInfo/GameInfo.tsx">
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import { useGame } from '../../contexts/GameContext';

const GameInfo: React.FC = () => {
  const { game, players, currentPlayer, myPlayerNumber } = useGame();

  if (!game) {
    return null;
  }

  const getStatusText = (): string => {
    switch (game.gameStatus) {
      case 'waiting':
        return 'Waiting for players...';
      case 'playing':
        return `Player ${currentPlayer}'s turn`;
      case 'finished':
        if (game.winner === 'draw') {
          return 'Draw!';
        }
        return `Player ${game.winner} wins!`;
      case 'abandoned':
        return 'Game abandoned';
      default:
        return '';
    }
  };

  return (
    <Paper 
      elevation={0}
      sx={{ 
        p: { xs: 2, md: 2.5 }, 
        background: '#ffffff',
        border: '2px solid transparent',
        borderRadius: 3,
        backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
        backgroundOrigin: 'border-box',
        backgroundClip: 'padding-box, border-box',
        boxShadow: '0 4px 16px rgba(126, 200, 227, 0.12)',
      }}
    >
      <Box sx={{ mb: 2.5 }}>
        <Typography 
          variant="subtitle1" 
          sx={{ 
            color: '#2c3e50', 
            fontWeight: 700, 
            fontSize: '0.95rem',
            mb: 1.5,
            textTransform: 'uppercase',
            letterSpacing: '0.5px',
          }}
        >
          üìä Game Status
        </Typography>
        <Box sx={{ 
          p: 1.5, 
          borderRadius: 2, 
          bgcolor: 'rgba(126, 200, 227, 0.08)',
          border: '1px solid rgba(126, 200, 227, 0.2)',
        }}>
          <Typography 
            variant="body1" 
            sx={{ 
              fontWeight: 600, 
              color: '#2c3e50',
              fontSize: '0.95rem',
            }}
          >
            {getStatusText()}
          </Typography>
        </Box>
      </Box>
      
      <Box sx={{ mb: 2.5 }}>
        <Typography 
          variant="subtitle1" 
          sx={{ 
            fontWeight: 700, 
            mb: 1.5,
            color: '#2c3e50',
            fontSize: '0.95rem',
            textTransform: 'uppercase',
            letterSpacing: '0.5px',
          }}
        >
          üë• Players
        </Typography>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
          {players.map((player, index) => (
            <Box 
              key={index} 
              sx={{ 
                p: 1.5,
                borderRadius: 2,
                bgcolor: myPlayerNumber === player.playerNumber 
                  ? 'rgba(126, 200, 227, 0.1)' 
                  : 'rgba(0,0,0,0.02)',
                border: myPlayerNumber === player.playerNumber 
                  ? '1px solid rgba(126, 200, 227, 0.3)' 
                  : '1px solid transparent',
              }}
            >
              <Typography 
                variant="body2" 
                sx={{ 
                  fontWeight: 600,
                  color: '#2c3e50',
                  fontSize: '0.9rem',
                }}
              >
                {player.playerNumber === 1 ? '‚úï' : '‚óã'} {player.username}
                {player.isGuest && ' (Guest)'}
                {myPlayerNumber === player.playerNumber && ' üë§'}
              </Typography>
            </Box>
          ))}
        </Box>
      </Box>
      
      <Box>
        <Typography 
          variant="subtitle1" 
          sx={{ 
            fontWeight: 700, 
            mb: 1.5,
            color: '#2c3e50',
            fontSize: '0.95rem',
            textTransform: 'uppercase',
            letterSpacing: '0.5px',
          }}
        >
          ‚öôÔ∏è Game Rules
        </Typography>
        <Box sx={{ 
          p: 1.5, 
          borderRadius: 2, 
          bgcolor: 'rgba(168, 230, 207, 0.08)',
          border: '1px solid rgba(168, 230, 207, 0.2)',
        }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <Typography 
                variant="body2" 
                sx={{ 
                  fontWeight: 600,
                  color: '#2c3e50',
                  fontSize: '0.9rem',
                }}
              >
                Block Two Ends:
              </Typography>
              <Typography 
                variant="body2" 
                sx={{ 
                  fontWeight: 700,
                  color: game.rules.blockTwoEnds ? '#a8e6cf' : '#ffaaa5',
                  fontSize: '0.9rem',
                }}
              >
                {game.rules.blockTwoEnds ? '‚úì ON' : '‚úó OFF'}
              </Typography>
            </Box>
            {game.rules.allowUndo && (
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Typography 
                  variant="body2" 
                  sx={{ 
                    fontWeight: 600,
                    color: '#2c3e50',
                    fontSize: '0.9rem',
                  }}
                >
                  Allow Undo:
                </Typography>
                <Typography 
                  variant="body2" 
                  sx={{ 
                    fontWeight: 700,
                    color: '#a8e6cf',
                    fontSize: '0.9rem',
                  }}
                >
                  ‚úì ON
                </Typography>
              </Box>
            )}
          </Box>
        </Box>
      </Box>
    </Paper>
  );
};

export default GameInfo;
</file>

<file path="frontend/src/components/RoomCodeDisplay.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Box, Typography, Paper, IconButton, Snackbar } from '@mui/material';
import { ContentCopy, Check } from '@mui/icons-material';
import { logger } from '../utils/logger';

interface RoomCodeDisplayProps {
  roomCode: string;
  label?: string;
}

const RoomCodeDisplay: React.FC<RoomCodeDisplayProps> = ({ roomCode, label = 'Room Code' }) => {
  const [copied, setCopied] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  const handleCopy = async (): Promise<void> => {
    try {
      await navigator.clipboard.writeText(roomCode);
      setCopied(true);
      // Clear existing timeout if any
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        setCopied(false);
        timeoutRef.current = null;
      }, 2000);
    } catch (error) {
      logger.error('Failed to copy:', error);
    }
  };

  return (
    <>
      <Paper
        elevation={0}
        sx={{
          p: { xs: 2, md: 2.5 },
          display: 'flex',
          alignItems: 'center',
          gap: 2,
          background: '#ffffff',
          border: '2px solid transparent',
          borderRadius: 3,
          backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
          backgroundOrigin: 'border-box',
          backgroundClip: 'padding-box, border-box',
          boxShadow: '0 8px 24px rgba(168, 230, 207, 0.12)',
          transition: 'box-shadow 0.3s ease',
          '&:hover': {
            boxShadow: '0 12px 32px rgba(168, 230, 207, 0.18)',
          },
        }}
      >
        <Box>
          <Typography variant="caption" sx={{ color: '#2c3e50', fontWeight: 600 }}>
            {label}
          </Typography>
          <Typography
            variant="h4"
            sx={{
              fontFamily: 'monospace',
              fontWeight: 800,
              letterSpacing: 3,
              background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              backgroundClip: 'text',
              fontSize: { xs: '1.75rem', md: '2.25rem' },
            }}
          >
            {roomCode}
          </Typography>
        </Box>
        <IconButton
          onClick={handleCopy}
          sx={{
            ml: 'auto',
            color: '#7ec8e3',
            '&:hover': {
              backgroundColor: 'rgba(126, 200, 227, 0.15)',
            },
          }}
        >
          {copied ? <Check sx={{ color: '#a8e6cf' }} /> : <ContentCopy />}
        </IconButton>
      </Paper>
      <Snackbar
        open={copied}
        autoHideDuration={2000}
        message="Room code copied to clipboard!"
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      />
    </>
  );
};

export default RoomCodeDisplay;
</file>

<file path="frontend/src/services/api.ts">
import axios from 'axios';
import { API_BASE_URL } from '../utils/constants';
import { AuthResponse, User } from '../types/user.types';
import { Game, GameHistory } from '../types/game.types';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add token to requests
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});


// Auth APIs
export const authApi = {
  register: async (username: string, email: string, password: string): Promise<AuthResponse> => {
    const response = await api.post('/auth/register', { username, email, password });
    return response.data;
  },
  login: async (email: string, password: string): Promise<AuthResponse> => {
    const response = await api.post('/auth/login', { email, password });
    return response.data;
  },
  getMe: async (): Promise<User> => {
    const response = await api.get('/auth/me');
    return response.data;
  },
};

// Game APIs
export const gameApi = {
  create: async (boardSize: number, rules: any): Promise<Game> => {
    try {
    // Use getGuestId() from utils instead of localStorage
    const { getGuestId } = await import('../utils/guestId');
    const guestId = getGuestId();
      const { logger } = await import('../utils/logger');
      logger.log('[gameApi.create] Calling API with:', { boardSize, rules, guestId });
    const response = await api.post('/games/create', { boardSize, rules, guestId });
      logger.log('[gameApi.create] Response received:', response.data);
    return response.data;
    } catch (error: any) {
      const { logger } = await import('../utils/logger');
      logger.error('[gameApi.create] API call failed:', error);
      logger.error('[gameApi.create] Error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
        config: error.config
      });
      throw error;
    }
  },
  getGame: async (roomId: string): Promise<Game> => {
    const response = await api.get(`/games/${roomId}`);
    return response.data;
  },
  getGameByCode: async (roomCode: string): Promise<Game> => {
    const response = await api.get(`/games/code/${roomCode}`);
    return response.data;
  },
  getUserGames: async (userId: string): Promise<Game[]> => {
    const response = await api.get(`/games/user/${userId}`);
    return response.data;
  },
  joinGame: async (roomId: string): Promise<Game> => {
    // Use getGuestId() from utils instead of localStorage
    const { getGuestId } = await import('../utils/guestId');
    const guestId = getGuestId();
    const response = await api.post(`/games/${roomId}/join`, { guestId });
    return response.data;
  },
  leaveGame: async (roomId: string): Promise<{ message: string; gameDeleted: boolean }> => {
    // Use getGuestId() from utils instead of localStorage
    const { getGuestId } = await import('../utils/guestId');
    const guestId = getGuestId();
    const response = await api.post(`/games/${roomId}/leave`, { guestId });
    return response.data;
  },
  getWaitingGames: async (): Promise<any[]> => {
    const response = await api.get('/games/waiting');
    return response.data;
  },
  getGameHistory: async (): Promise<{ history: GameHistory[]; total: number }> => {
    // Check if user is authenticated
    const token = localStorage.getItem('token');
    const isAuthenticated = !!token;
    
    if (isAuthenticated) {
      // Authenticated user - get from API
      try {
        const response = await api.post('/games/history', {});
        const { logger } = await import('../utils/logger');
        logger.log('[API] getGameHistory (authenticated) response:', response.data);
        return response.data;
      } catch (error: any) {
        const { logger } = await import('../utils/logger');
        logger.error('[API] Failed to get game history from server:', error);
        // Fallback to empty if API fails
        return { history: [], total: 0 };
      }
    } else {
      // Guest user - get from localStorage
      const { getGuestHistory } = await import('../utils/guestHistory');
      const history = getGuestHistory();
      const { logger } = await import('../utils/logger');
      logger.log('[API] getGameHistory (guest) from localStorage:', history.length, 'games');
      return { history, total: history.length };
    }
  },
};

// Game Stats APIs
export const gameStatsApi = {
  getUserGameStats: async (gameId: string, userId: string) => {
    const response = await api.get(`/games/${gameId}/stats/${userId}`);
    return response.data;
  },
  getMyGameStats: async (gameId: string) => {
    const response = await api.get(`/games/${gameId}/stats/my-stats`);
    return response.data;
  },
  submitGameResult: async (gameId: string, result: 'win' | 'loss' | 'draw', score?: number, customStats?: any, gameData?: any) => {
    const response = await api.post(`/games/${gameId}/stats/submit`, {
      result,
      score,
      customStats,
      gameData,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substring(7),
    });
    return response.data;
  },
};

// Leaderboard APIs
export const leaderboardApi = {
  getLeaderboard: async (gameId: string, period: 'daily' | 'weekly' | 'all-time' = 'all-time', limit: number = 50, offset: number = 0) => {
    const response = await api.get(`/leaderboard/${gameId}?period=${period}&limit=${limit}&offset=${offset}`);
    return response.data;
  },
  getUserRank: async (gameId: string, userId: string, period: 'daily' | 'weekly' | 'all-time' = 'all-time') => {
    const response = await api.get(`/leaderboard/${gameId}/rank/${userId}?period=${period}`);
    return response.data;
  },
  getRankAroundUser: async (gameId: string, userId: string, period: 'daily' | 'weekly' | 'all-time' = 'all-time', range: number = 5) => {
    const response = await api.get(`/leaderboard/${gameId}/around/${userId}?period=${period}&range=${range}`);
    return response.data;
  },
  // Legacy endpoints for backward compatibility
  getTopPlayers: async (limit: number = 10, gameId?: string): Promise<User[]> => {
    const url = gameId ? `/leaderboard/${gameId}?limit=${limit}` : `/leaderboard/top?limit=${limit}${gameId ? `&gameId=${gameId}` : ''}`;
    const response = await api.get(url);
    return response.data;
  },
};

// User APIs
export const userApi = {
  getProfile: async (userId: string): Promise<User> => {
    const response = await api.get(`/users/${userId}/profile`);
    return response.data;
  },
  getUserGames: async (userId: string) => {
    const response = await api.get(`/users/${userId}/games`);
    return response.data;
  },
  getUserGameStats: async (userId: string, gameId: string) => {
    const response = await api.get(`/users/${userId}/games/${gameId}`);
    return response.data;
  },
  getMyProfile: async (): Promise<User> => {
    const response = await api.get(`/users/me/profile`);
    return response.data;
  },
  updateProfile: async (userId: string, data: Partial<User>): Promise<User> => {
    const response = await api.put(`/users/${userId}`, data);
    return response.data;
  },
};

export default api;
</file>

<file path="frontend/src/App.tsx">
import React, { useEffect } from 'react';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { Box, GlobalStyles } from '@mui/material';
import { AuthProvider } from './contexts/AuthContext';
import { SocketProvider } from './contexts/SocketContext';
import { GameProvider } from './contexts/GameContext';
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import GameRoomPage from './pages/GameRoomPage';
import JoinGamePage from './pages/JoinGamePage';
import LeaderboardPage from './pages/LeaderboardPage';
import ProfilePage from './pages/ProfilePage';

const theme = createTheme({
  palette: {
    primary: {
      main: '#7ec8e3',
      light: '#a8d5e2',
      dark: '#5ba8c7',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#a8e6cf',
      light: '#c8f0df',
      dark: '#88d6b7',
      contrastText: '#2c3e50',
    },
    background: {
      default: '#ffffff',
      paper: '#ffffff',
    },
    text: {
      primary: '#2c3e50',
      secondary: '#5a6a7a',
    },
    success: {
      main: '#a8e6cf',
    },
    warning: {
      main: '#ffb88c',
    },
    error: {
      main: '#ffaaa5',
    },
    info: {
      main: '#7ec8e3',
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          textTransform: 'none',
          fontWeight: 600,
          padding: '10px 24px',
          transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
          boxShadow: '0 2px 8px rgba(126, 200, 227, 0.15)',
          '&:hover': {
            boxShadow: '0 4px 16px rgba(126, 200, 227, 0.25)',
          },
        },
        contained: {
          background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
          color: '#ffffff',
          fontWeight: 700,
          boxShadow: '0 4px 12px rgba(126, 200, 227, 0.3)',
          border: 'none',
          '&:hover': {
            background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
            boxShadow: '0 6px 16px rgba(126, 200, 227, 0.4)',
            transform: 'translateY(-2px)',
            border: 'none',
          },
        },
        outlined: {
          borderColor: '#7ec8e3',
          borderWidth: 2,
          color: '#2c3e50',
          fontWeight: 600,
          '&:hover': {
            borderColor: '#5ba8c7',
            borderWidth: 2,
            background: 'rgba(126, 200, 227, 0.08)',
            transform: 'translateY(-1px)',
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          background: '#ffffff',
          border: '1px solid rgba(126, 200, 227, 0.15)',
        },
        elevation1: {
          boxShadow: '0 2px 8px rgba(44, 62, 80, 0.08), 0 1px 3px rgba(0,0,0,0.04)',
        },
        elevation2: {
          boxShadow: '0 4px 12px rgba(44, 62, 80, 0.1), 0 2px 4px rgba(0,0,0,0.06)',
        },
        elevation3: {
          boxShadow: '0 6px 16px rgba(44, 62, 80, 0.12), 0 3px 6px rgba(0,0,0,0.08)',
        },
        elevation4: {
          boxShadow: '0 8px 24px rgba(44, 62, 80, 0.15), 0 4px 8px rgba(0,0,0,0.1)',
        },
      },
    },
  },
});

// Create router with data router API
const router = createBrowserRouter([
  {
    path: '/',
    element: <HomePage />,
  },
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/join',
    element: <JoinGamePage />,
  },
  {
    path: '/game/:roomId',
    element: <GameRoomPage />,
  },
  {
    path: '/leaderboard',
    element: <LeaderboardPage />,
  },
  {
    path: '/profile',
    element: <ProfilePage />,
  },
]);

function App() {
  // Prevent zoom gestures (trackpad, mouse wheel with ctrl/cmd, touch pinch)
  useEffect(() => {
    const preventZoom = (e: WheelEvent | TouchEvent): void => {
      // Prevent zoom with Ctrl/Cmd + Wheel (trackpad zoom)
      if (e instanceof WheelEvent) {
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          e.stopPropagation();
        }
        return;
      }
      
      // Prevent pinch zoom on touch devices
      if (e instanceof TouchEvent && e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
      }
    };

    const preventGestureZoom = (e: Event): void => {
      e.preventDefault();
      e.stopPropagation();
    };

    // Add event listeners
    document.addEventListener('wheel', preventZoom, { passive: false, capture: true });
    document.addEventListener('touchstart', preventZoom, { passive: false, capture: true });
    document.addEventListener('touchmove', preventZoom, { passive: false, capture: true });
    document.addEventListener('touchend', preventZoom, { passive: false, capture: true });
    document.addEventListener('gesturestart', preventGestureZoom, { passive: false, capture: true });
    document.addEventListener('gesturechange', preventGestureZoom, { passive: false, capture: true });
    document.addEventListener('gestureend', preventGestureZoom, { passive: false, capture: true });

    // Also prevent zoom via keyboard shortcuts
    const preventKeyboardZoom = (e: KeyboardEvent): void => {
      // Prevent Ctrl/Cmd + Plus/Minus/0 (zoom shortcuts)
      if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0')) {
        e.preventDefault();
        e.stopPropagation();
      }
    };

    document.addEventListener('keydown', preventKeyboardZoom, { passive: false, capture: true });

    // Cleanup
    return () => {
      document.removeEventListener('wheel', preventZoom as EventListener, true);
      document.removeEventListener('touchstart', preventZoom as EventListener, true);
      document.removeEventListener('touchmove', preventZoom as EventListener, true);
      document.removeEventListener('touchend', preventZoom as EventListener, true);
      document.removeEventListener('gesturestart', preventGestureZoom, true);
      document.removeEventListener('gesturechange', preventGestureZoom, true);
      document.removeEventListener('gestureend', preventGestureZoom, true);
      document.removeEventListener('keydown', preventKeyboardZoom, true);
    };
  }, []);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <GlobalStyles
        styles={{
          '*': {
            touchAction: 'pan-x pan-y', // Allow panning but prevent pinch zoom
          },
          'html, body': {
            touchAction: 'pan-x pan-y',
            userSelect: 'none',
            WebkitUserSelect: 'none',
            WebkitTouchCallout: 'none',
            WebkitTapHighlightColor: 'transparent',
          },
          // Prevent double-tap zoom on iOS
          '*:not(input):not(textarea):not(select)': {
            WebkitTouchCallout: 'none',
            WebkitUserSelect: 'none',
          },
        }}
      />
      <Box
        sx={{
          minHeight: '100vh',
          background: 'linear-gradient(135deg, #f8fbff 0%, #ffffff 50%, #f0f9ff 100%)',
          backgroundAttachment: 'fixed',
          touchAction: 'pan-x pan-y',
        }}
      >
        <AuthProvider>
          <SocketProvider>
            <GameProvider>
              <RouterProvider router={router} />
            </GameProvider>
          </SocketProvider>
        </AuthProvider>
      </Box>
    </ThemeProvider>
  );
}

export default App;
</file>

<file path="frontend/src/components/GameControls/GameControls.tsx">
import React, { useState } from 'react';
import { Box, Button, Dialog, DialogTitle, DialogContent, DialogActions, Typography, CircularProgress, Snackbar, Alert } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useGame } from '../../contexts/GameContext';
import { logger } from '../../utils/logger';

interface GameControlsProps {
  onLeaveGame?: () => Promise<void>;
}

const GameControls: React.FC<GameControlsProps> = ({ onLeaveGame }) => {
  const { game, surrender, startGame, newGame, leaveRoom, requestUndo, approveUndo, rejectUndo, myPlayerNumber, pendingUndoMove, undoRequestSent, clearPendingUndo, players } = useGame();
  const navigate = useNavigate();
  const [isLeaving, setIsLeaving] = useState(false);
  const [showLeaveConfirm, setShowLeaveConfirm] = useState(false);

  const canStartGame = game?.gameStatus === 'waiting' && players.length === 2 && myPlayerNumber === 1;
  const showWinnerModal = game?.gameStatus === 'finished' && game.winner !== null;
  
  // Removed debug logging to improve performance

  if (!game) {
    return null;
  }

  const handleSurrender = (): void => {
    if (window.confirm('Are you sure you want to surrender?')) {
      surrender();
    }
  };

  const handleNewGame = (): void => {
    if (game.gameStatus === 'finished') {
      newGame();
    }
  };

  const handlePlayAgain = (): void => {
    handleNewGame();
  };

  const handleLeaveRoomClick = (): void => {
    setShowLeaveConfirm(true);
  };

  const handleLeaveConfirm = async (): Promise<void> => {
    setShowLeaveConfirm(false);
    try {
      setIsLeaving(true);
      // Use onLeaveGame if provided (from GameRoomPage to handle blocker), otherwise use default
      if (onLeaveGame) {
        await onLeaveGame();
      } else {
        await leaveRoom();
        // Navigate to home after successfully leaving
        navigate('/');
      }
    } catch (error) {
      logger.error('Error leaving game:', error);
      // Still navigate even if there's an error
      if (!onLeaveGame) {
        navigate('/');
      }
    } finally {
      setIsLeaving(false);
    }
  };

  const handleLeaveCancel = (): void => {
    setShowLeaveConfirm(false);
  };

  const getWinnerMessage = (): string => {
    if (game.winner === 'draw') {
      return "It's a Draw!";
    }
    const winnerPlayer = players.find(p => p.playerNumber === game.winner);
    if (winnerPlayer) {
      const isYou = myPlayerNumber === game.winner;
      return `${winnerPlayer.username} ${isYou ? '(You)' : ''} Wins!`;
    }
    return `Player ${game.winner} Wins!`;
  };

  // Count total moves on the board
  const getMoveCount = (): number => {
    let moveCount = 0;
    for (let i = 0; i < game.board.length; i++) {
      for (let j = 0; j < game.board[i].length; j++) {
        if (game.board[i][j] !== 0) {
          moveCount++;
        }
      }
    }
    return moveCount;
  };

  // Count moves made by the current player
  const getMyMoveCount = (): number => {
    if (!myPlayerNumber) return 0;
    let moveCount = 0;
    for (let i = 0; i < game.board.length; i++) {
      for (let j = 0; j < game.board[i].length; j++) {
        if (game.board[i][j] === myPlayerNumber) {
          moveCount++;
        }
      }
    }
    return moveCount;
  };

  const handleRequestUndo = (): void => {
    // Calculate move number from board state
    const moveCount = getMoveCount();
    if (moveCount > 0) {
      requestUndo(moveCount);
    }
  };

  // Check if undo is available - player must have made at least 1 move
  const canRequestUndo = (): boolean => {
    if (!myPlayerNumber) return false;
    const myMoveCount = getMyMoveCount();
    return myMoveCount >= 1; // Player must have made at least 1 move to request undo
  };

  const handleApproveUndo = (): void => {
    if (pendingUndoMove !== null) {
      approveUndo(pendingUndoMove);
      clearPendingUndo();
    }
  };

  const handleRejectUndo = (): void => {
    rejectUndo();
    clearPendingUndo();
  };

  return (
    <Box sx={{ width: '100%' }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1.5 }}>
        {canStartGame && (
          <Button variant="contained" size="medium" onClick={startGame} fullWidth>
            Start Game
          </Button>
        )}
        {game.gameStatus === 'playing' && (
          <>
            {game.rules.allowUndo && canRequestUndo() && (
              <Button 
                variant="outlined" 
                size="medium" 
                onClick={handleRequestUndo} 
                disabled={!myPlayerNumber || undoRequestSent} 
                fullWidth
                startIcon={undoRequestSent ? <CircularProgress size={16} /> : null}
                sx={{
                  ...(undoRequestSent && {
                    bgcolor: 'rgba(126, 200, 227, 0.1)',
                    borderColor: '#7ec8e3',
                    color: '#7ec8e3',
                  }),
                }}
              >
                {undoRequestSent ? 'Waiting for response...' : 'Request Undo'}
              </Button>
            )}
            <Button variant="outlined" color="error" size="medium" onClick={handleSurrender} fullWidth>
              Surrender
            </Button>
          </>
        )}
        {game.gameStatus === 'finished' && !showWinnerModal && (
          <Button variant="contained" size="medium" onClick={handleNewGame} fullWidth>
            New Game
          </Button>
        )}
        {!showWinnerModal && (
          <Button 
            variant="outlined" 
            color="secondary" 
            size="medium" 
            onClick={handleLeaveRoomClick} 
            disabled={isLeaving}
            fullWidth
            startIcon={isLeaving ? <CircularProgress size={16} /> : null}
          >
            {isLeaving ? 'Leaving...' : 'Leave Game'}
          </Button>
        )}
      </Box>

      <Dialog open={pendingUndoMove !== null} onClose={handleRejectUndo}>
        <DialogTitle>Undo Request</DialogTitle>
        <DialogContent>
          <Typography>Your opponent wants to undo the last move. Do you approve?</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleRejectUndo}>Reject</Button>
          <Button onClick={handleApproveUndo} variant="contained">
            Approve
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for undo request feedback */}
      <Snackbar
        open={undoRequestSent}
        autoHideDuration={3000}
        onClose={() => {}}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert severity="info" sx={{ width: '100%' }}>
          Undo request sent! Waiting for opponent's response...
        </Alert>
      </Snackbar>

      <Dialog 
        open={showWinnerModal} 
        onClose={() => {}} 
        maxWidth="sm" 
        fullWidth
        PaperProps={{
          sx: {
            background: '#ffffff',
            borderRadius: 4,
            boxShadow: '0 20px 60px rgba(126, 200, 227, 0.25)',
            border: '2px solid transparent',
            backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            backgroundOrigin: 'border-box',
            backgroundClip: 'padding-box, border-box',
            overflow: 'hidden',
          }
        }}
      >
        <DialogTitle
          sx={{
            textAlign: 'center',
            pt: 5,
            pb: 2,
            background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.05) 0%, rgba(168, 230, 207, 0.05) 100%)',
          }}
        >
          <Typography
            variant="h3"
            sx={{
              background: game.winner === 'draw' 
                ? 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)'
                : myPlayerNumber === game.winner
                ? 'linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)'
                : 'linear-gradient(135deg, #ffb88c 0%, #ffaaa5 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              backgroundClip: 'text',
              fontWeight: 800,
              mb: 2,
              fontSize: { xs: '2rem', md: '2.5rem' },
            }}
          >
            {getWinnerMessage()}
          </Typography>
          {game.winner !== 'draw' && (
            <Typography 
              variant="h6" 
              sx={{ 
                color: '#5a6a7a', 
                mt: 1,
                fontWeight: 500,
                fontSize: '1.1rem',
              }}
            >
              {myPlayerNumber === game.winner ? 'üéâ Congratulations!' : 'üòî Better luck next time!'}
            </Typography>
          )}
        </DialogTitle>
        <DialogContent sx={{ textAlign: 'center', pb: 3, px: 4 }}>
          <Box sx={{ mb: 4 }}>
            <Typography 
              variant="h6" 
              sx={{ 
                fontWeight: 700, 
                mb: 3, 
                color: '#2c3e50',
                fontSize: '1.1rem',
              }}
            >
              üèÜ Final Score
            </Typography>
            <Box sx={{ 
              display: 'flex', 
              justifyContent: 'center', 
              gap: 4,
            }}>
              <Box sx={{ 
                p: 2.5,
                borderRadius: 3,
                bgcolor: 'rgba(126, 200, 227, 0.1)',
                border: '1px solid rgba(126, 200, 227, 0.3)',
                minWidth: 120,
              }}>
                <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 1, fontWeight: 600 }}>
                  Player 1
                </Typography>
                <Typography variant="h4" sx={{ fontWeight: 700, color: '#7ec8e3' }}>
                  {game.score.player1}
                </Typography>
              </Box>
              <Box sx={{ 
                p: 2.5,
                borderRadius: 3,
                bgcolor: 'rgba(168, 230, 207, 0.1)',
                border: '1px solid rgba(168, 230, 207, 0.3)',
                minWidth: 120,
              }}>
                <Typography variant="body2" sx={{ color: '#5a6a7a', mb: 1, fontWeight: 600 }}>
                  Player 2
                </Typography>
                <Typography variant="h4" sx={{ fontWeight: 700, color: '#a8e6cf' }}>
                  {game.score.player2}
                </Typography>
              </Box>
            </Box>
          </Box>
        </DialogContent>
        <DialogActions sx={{ justifyContent: 'center', pb: 5, px: 4, gap: 2 }}>
          <Button
            variant="outlined"
            onClick={handleLeaveRoomClick}
            disabled={isLeaving}
            sx={{
              minWidth: 160,
              py: 1.5,
              borderRadius: 2,
              borderColor: '#7ec8e3',
              borderWidth: 2,
              color: '#2c3e50',
              fontWeight: 700,
              textTransform: 'none',
              fontSize: '1rem',
              transition: 'all 0.3s ease',
              '&:hover': {
                borderColor: '#5ba8c7',
                borderWidth: 2,
                backgroundColor: 'rgba(126, 200, 227, 0.08)',
              },
            }}
          >
            Leave Room
          </Button>
          <Button
            variant="contained"
            onClick={handlePlayAgain}
            sx={{
              minWidth: 160,
              py: 1.5,
              borderRadius: 2,
              background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
              color: '#ffffff',
              fontWeight: 700,
              textTransform: 'none',
              fontSize: '1rem',
              boxShadow: '0 4px 14px rgba(126, 200, 227, 0.4)',
              transition: 'all 0.3s ease',
              '&:hover': {
                background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
                boxShadow: '0 6px 20px rgba(126, 200, 227, 0.5)',
              },
            }}
          >
            Play Again
          </Button>
        </DialogActions>
      </Dialog>

      {/* Leave Game Confirmation Dialog */}
      <Dialog 
        open={showLeaveConfirm} 
        onClose={handleLeaveCancel}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle
          sx={{
            background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            backgroundClip: 'text',
            fontWeight: 700,
            fontSize: '1.5rem',
            textAlign: 'center',
            pb: 1,
          }}
        >
          ‚ö†Ô∏è Leave Game?
        </DialogTitle>
        <DialogContent>
          <Typography 
            variant="body1" 
            sx={{ 
              color: '#2c3e50', 
              textAlign: 'center',
              py: 2,
              fontSize: '1.1rem',
            }}
          >
            Are you sure you want to leave this game? 
            {game.gameStatus === 'playing' && (
              <Box component="span" sx={{ display: 'block', mt: 1, fontWeight: 600, color: '#ffaaa5' }}>
                The game is still in progress!
              </Box>
            )}
          </Typography>
        </DialogContent>
        <DialogActions sx={{ justifyContent: 'center', pb: 3, px: 3, gap: 2 }}>
          <Button
            variant="outlined"
            onClick={handleLeaveCancel}
            sx={{
              minWidth: 120,
              py: 1.25,
              borderRadius: 2,
              borderColor: '#7ec8e3',
              borderWidth: 2,
              color: '#2c3e50',
              fontWeight: 600,
              textTransform: 'none',
              fontSize: '1rem',
              '&:hover': {
                borderColor: '#5ba8c7',
                borderWidth: 2,
                backgroundColor: 'rgba(126, 200, 227, 0.08)',
              },
            }}
          >
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleLeaveConfirm}
            disabled={isLeaving}
            startIcon={isLeaving ? <CircularProgress size={16} color="inherit" /> : null}
            sx={{
              minWidth: 120,
              py: 1.25,
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffaaa5 0%, #ff8a80 100%)',
              color: '#ffffff',
              fontWeight: 700,
              textTransform: 'none',
              fontSize: '1rem',
              boxShadow: '0 4px 14px rgba(255, 170, 165, 0.4)',
              '&:hover': {
                background: 'linear-gradient(135deg, #ff8a80 0%, #ff6b6b 100%)',
                boxShadow: '0 6px 20px rgba(255, 170, 165, 0.5)',
              },
            }}
          >
            {isLeaving ? 'Leaving...' : 'Leave'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default GameControls;
</file>

<file path="frontend/src/pages/GameRoomPage.tsx">
import React, { useEffect, useState, useRef } from 'react';
import { Container, Box, CircularProgress, Typography, Dialog, DialogTitle, DialogContent, DialogActions, Button } from '@mui/material';
import { useParams, useNavigate, useBlocker } from 'react-router-dom';
import { useGame } from '../contexts/GameContext';
import { gameApi } from '../services/api';
import GameBoard from '../components/GameBoard/GameBoard';
import GameInfo from '../components/GameInfo/GameInfo';
import GameControls from '../components/GameControls/GameControls';
import RoomCodeDisplay from '../components/RoomCodeDisplay';
import { logger } from '../utils/logger';

const GameRoomPage: React.FC = () => {
  const { roomId } = useParams<{ roomId: string }>();
  const navigate = useNavigate();
  const { game, players, joinRoom, setGame, myPlayerNumber, leaveRoom, startGame } = useGame();
  const [loading, setLoading] = useState(true);
  const [showLeaveConfirm, setShowLeaveConfirm] = useState(false);
  const [isLeaving, setIsLeaving] = useState(false);
  const hasLeftRef = useRef(false);
  const pendingNavigation = useRef<(() => void) | null>(null);
  
  // isWaiting: game status is waiting AND not enough players (< 2) - show waiting message only
  // This includes when host leaves and player2 becomes player1 (only 1 player remains)
  const isWaiting = game && game.gameStatus === 'waiting' && players.length < 2;
  // canStartGame: game status is waiting AND has exactly 2 players ready to start - show board with Start button
  const canStartGame = game && game.gameStatus === 'waiting' && players.length === 2;
  
  // Block navigation (back button, programmatic navigation) using useBlocker
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      game !== null && 
      !hasLeftRef.current && 
      currentLocation.pathname !== nextLocation.pathname
  );
  
  // Handle blocked navigation
  useEffect(() => {
    if (blocker.state === 'blocked') {
      setShowLeaveConfirm(true);
      pendingNavigation.current = blocker.proceed;
    }
  }, [blocker]);
  
  // Handle browser tab close (but not reload)
  // Note: We don't call leave game API here because we can't distinguish
  // between reload and closing tab. Socket will handle disconnect automatically.
  useEffect(() => {
    if (!game || hasLeftRef.current || !roomId) return;
    
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      // Only show warning if game is in progress
      // Don't call leave game API - let socket handle disconnect
      // This way, reload won't remove player from game
      if (game.gameStatus === 'playing') {
        e.preventDefault();
        e.returnValue = ''; // Chrome requires returnValue to be set
        return ''; // Some browsers require return value
      }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [game, roomId]);
  
  // Wrapper function to handle leave game with proper flag setting
  const handleLeaveGame = async (): Promise<void> => {
    // Set flag first to prevent blocker from blocking navigation
    hasLeftRef.current = true;
    try {
      await leaveRoom();
      // Navigate to home after leaving
      navigate('/');
    } catch (error) {
      logger.error('Error leaving game:', error);
      // Still navigate even if there's an error
      navigate('/');
    }
  };

  const handleLeaveConfirm = async (): Promise<void> => {
    setShowLeaveConfirm(false);
    try {
      setIsLeaving(true);
      await handleLeaveGame();
    } catch (error) {
      logger.error('Error leaving game:', error);
    } finally {
      setIsLeaving(false);
    }
  };
  
  const handleLeaveCancel = (): void => {
    setShowLeaveConfirm(false);
    if (blocker.state === 'blocked') {
      blocker.reset();
    }
    pendingNavigation.current = null;
  };
  
  // Removed debug logging to improve performance

  useEffect(() => {
    if (!roomId) {
      navigate('/');
      return;
    }

    let isMounted = true;

    const loadGame = async (): Promise<void> => {
      try {
        setLoading(true);
        logger.log('[GameRoomPage] Loading game with roomId:', roomId);
        const gameData = await gameApi.getGame(roomId);
        logger.log('[GameRoomPage] Game loaded successfully:', gameData);
        if (isMounted) {
          // Set game first, then join room
          setGame(gameData);
          // Join room immediately - joinRoom will handle the game state check
          joinRoom(roomId);
          setLoading(false);
        }
      } catch (error: any) {
        logger.error('[GameRoomPage] Failed to load game:', error);
        // If game not found (404), it might have been deleted
        if (isMounted) {
          setLoading(false);
          if (error.response?.status === 404) {
            logger.log('[GameRoomPage] Game not found (404) - navigating to home');
            navigate('/');
          } else {
            logger.log('[GameRoomPage] Error loading game - navigating to home');
          navigate('/');
          }
        }
      }
    };

    loadGame();

    return () => {
      isMounted = false;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  // Navigate to home if game is deleted (game becomes null) - but only if not loading
  // Don't navigate during initial load or when we're in the process of leaving
  // Use a ref to track if we've completed initial load
  const initialLoadCompleteRef = useRef(false);
  
  useEffect(() => {
    if (!loading && game) {
      initialLoadCompleteRef.current = true;
    }
  }, [loading, game]);

  useEffect(() => {
    // Only navigate if:
    // 1. Game is null
    // 2. We have a roomId
    // 3. We haven't left manually
    // 4. We're not currently loading
    // 5. Initial load has completed (to avoid navigating during initial mount)
    if (game === null && roomId && !hasLeftRef.current && !loading && initialLoadCompleteRef.current) {
      logger.log('[GameRoomPage] Game is null and initial load completed - navigating to home');
      navigate('/');
    }
  }, [game, roomId, navigate, loading]);

  if (loading || !game) {
    return (
      <Container maxWidth="lg">
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            minHeight: '80vh',
            gap: 2,
          }}
        >
          <CircularProgress />
          <Typography variant="body1" color="text.secondary">
            Loading game...
          </Typography>
        </Box>
      </Container>
    );
  }

  return (
    <>
      {/* Leave Confirmation Dialog */}
      <Dialog 
        open={showLeaveConfirm} 
        onClose={handleLeaveCancel} 
        maxWidth="xs" 
        fullWidth
        disableEscapeKeyDown={isLeaving}
      >
        <DialogTitle sx={{ textAlign: 'center', pt: 4, pb: 2 }}>
          <Typography variant="h5" sx={{ fontWeight: 700, color: '#2c3e50' }}>
            ‚ö†Ô∏è Leave Game?
          </Typography>
        </DialogTitle>
        <DialogContent sx={{ textAlign: 'center', pb: 2 }}>
          <Typography variant="body1" sx={{ color: '#5a6a7a', mb: 2 }}>
            Are you sure you want to leave this game?
          </Typography>
          {game && game.gameStatus === 'playing' && (
            <Typography variant="body2" sx={{ color: '#ffaaa5', fontWeight: 600 }}>
              The game is still in progress!
            </Typography>
          )}
        </DialogContent>
        <DialogActions sx={{ justifyContent: 'center', pb: 4, px: 3, gap: 2 }}>
          <Button
            variant="outlined"
            onClick={handleLeaveCancel}
            disabled={isLeaving}
            sx={{
              minWidth: 120,
              py: 1.25,
              borderRadius: 2,
              borderColor: '#7ec8e3',
              borderWidth: 2,
              color: '#2c3e50',
              fontWeight: 600,
              textTransform: 'none',
              fontSize: '0.95rem',
              transition: 'all 0.3s ease',
              '&:hover': {
                borderColor: '#5ba8c7',
                borderWidth: 2,
                backgroundColor: 'rgba(126, 200, 227, 0.08)',
              },
            }}
          >
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleLeaveConfirm}
            disabled={isLeaving}
            sx={{
              minWidth: 120,
              py: 1.25,
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffaaa5 0%, #ffb88c 100%)',
              color: '#ffffff',
              fontWeight: 700,
              textTransform: 'none',
              fontSize: '0.95rem',
              boxShadow: '0 4px 14px rgba(255, 170, 165, 0.4)',
              transition: 'all 0.3s ease',
              '&:hover': {
                background: 'linear-gradient(135deg, #e08a85 0%, #e09a7c 100%)',
                boxShadow: '0 6px 20px rgba(255, 170, 165, 0.5)',
              },
            }}
          >
            {isLeaving ? 'Leaving...' : 'Leave'}
          </Button>
        </DialogActions>
      </Dialog>

      <Box
        sx={{
          minHeight: '100vh',
          background: 'linear-gradient(135deg, #f8fbff 0%, #ffffff 30%, #f0f9ff 100%)',
          position: 'relative',
          overflow: 'hidden',
          '&::before': {
            content: '""',
            position: 'absolute',
            top: -50,
            right: -50,
            width: 300,
            height: 300,
            borderRadius: '50%',
            background: 'radial-gradient(circle, rgba(126, 200, 227, 0.1) 0%, transparent 70%)',
            animation: 'float 20s ease-in-out infinite',
            '@keyframes float': {
              '0%, 100%': { transform: 'translate(0, 0) scale(1)' },
              '50%': { transform: 'translate(-30px, -30px) scale(1.1)' },
            },
          },
          '&::after': {
            content: '""',
            position: 'absolute',
            bottom: -100,
            left: -100,
            width: 400,
            height: 400,
            borderRadius: '50%',
            background: 'radial-gradient(circle, rgba(168, 230, 207, 0.1) 0%, transparent 70%)',
            animation: 'float 25s ease-in-out infinite reverse',
            '@keyframes float': {
              '0%, 100%': { transform: 'translate(0, 0) scale(1)' },
              '50%': { transform: 'translate(30px, 30px) scale(1.1)' },
            },
          },
        }}
      >
        {/* Left Sidebar - Room Code, Game Info & Controls - Fixed */}
        <Box
          sx={{
            display: { xs: 'none', lg: 'flex' },
            flexDirection: 'column',
            gap: 2,
            position: 'fixed',
            left: { lg: 24 },
            top: { lg: 24 },
            width: { lg: '280px' },
            height: { lg: 'calc(100vh - 48px)' },
            maxHeight: { lg: 'calc(100vh - 48px)' },
            overflowY: 'auto',
            zIndex: 10,
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              background: 'rgba(126, 200, 227, 0.05)',
              borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              background: 'rgba(126, 200, 227, 0.2)',
              borderRadius: '3px',
              '&:hover': {
                background: 'rgba(126, 200, 227, 0.3)',
              },
            },
          }}
        >
          <RoomCodeDisplay roomCode={game.roomCode} />
          <GameInfo />
          <GameControls onLeaveGame={handleLeaveGame} />
        </Box>

        {/* Main Content Area - Board Only */}
        <Box
          sx={{ 
            position: 'relative', 
            zIndex: 1,
            ml: { lg: '328px' }, // Margin for fixed left sidebar (280px + 48px gap)
            mr: { lg: '328px' }, // Margin for fixed right sidebar (280px + 48px gap)
              display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
              minHeight: 'calc(100vh - 40px)',
            py: { xs: 2, md: 3 },
            width: { lg: 'calc(100% - 656px)' }, // 328px * 2 for both sidebars
            }}
          >
          {/* Game Board - Center, Large */}
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              width: '100%',
              position: 'relative',
            }}
          >
            {isWaiting ? (
              <Box
                sx={{
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: 3,
                  p: 5,
                  borderRadius: 3,
                  bgcolor: 'rgba(126, 200, 227, 0.05)',
                  border: '2px dashed rgba(126, 200, 227, 0.3)',
                  width: '100%',
                  maxWidth: '600px',
                }}
              >
                <Typography
                  variant="h4"
                  sx={{
                    background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    backgroundClip: 'text',
                    fontWeight: 700,
                    fontSize: { xs: '1.75rem', md: '2.25rem' },
                    textAlign: 'center',
                  }}
                >
                  ‚è≥ Waiting for player...
                </Typography>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: '#5a6a7a', 
                    fontWeight: 500,
                    fontSize: '1.1rem',
                    textAlign: 'center',
                  }}
                >
                  Share the room code with another player to start the game
                </Typography>
              </Box>
            ) : canStartGame ? (
              // Game is waiting but has 2 players - show board with Start Game button
              <Box sx={{ width: '100%', display: 'flex', justifyContent: 'center', position: 'relative' }}>
                <GameBoard />
                <>
                  {/* Semi-transparent overlay */}
                  <Box
                    sx={{
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      right: 0,
                      bottom: 0,
                      bgcolor: 'rgba(0, 0, 0, 0.3)',
                      backdropFilter: 'blur(4px)',
                      WebkitBackdropFilter: 'blur(4px)',
                      willChange: 'transform',
                      zIndex: 5,
                      borderRadius: 4,
                      pointerEvents: 'none',
                    }}
                  />
                  {/* Start Game Button */}
                  <Box
                    sx={{
                      position: 'absolute',
                      top: '50%',
                      left: '50%',
                      transform: 'translate(-50%, -50%)',
                      zIndex: 10,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 2,
                    }}
                  >
                    <Button
                      variant="contained"
                      size="large"
                      onClick={startGame}
                      sx={{
                        minWidth: 200,
                        py: 2,
                        px: 4,
                        borderRadius: 3,
                        background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                        color: '#ffffff',
                        fontWeight: 700,
                        fontSize: '1.2rem',
                        textTransform: 'none',
                        boxShadow: '0 8px 24px rgba(126, 200, 227, 0.4)',
                        transition: 'all 0.3s ease',
                        '&:hover': {
                          background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
                          boxShadow: '0 12px 32px rgba(126, 200, 227, 0.5)',
                          transform: 'translateY(-2px)',
                        },
                      }}
                    >
                      üéÆ Start Game
                    </Button>
                    <Box
                      sx={{
                        bgcolor: 'rgba(255, 255, 255, 0.95)',
                        px: 2,
                        py: 1.5,
                        borderRadius: 2,
                        backdropFilter: 'blur(8px)',
                        WebkitBackdropFilter: 'blur(8px)',
                        willChange: 'transform',
                        boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                        textAlign: 'center',
                      }}
                    >
                      <Typography
                        variant="body2"
                        sx={{
                          color: '#2c3e50',
                          fontWeight: 600,
                          mb: 0.5,
                          fontSize: '0.95rem',
                        }}
                      >
                        Ready to play! Click to start
                      </Typography>
                      <Typography
                        variant="caption"
                        sx={{
                          color: '#7ec8e3',
                          fontWeight: 600,
                          fontSize: '0.8rem',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: 0.5,
                        }}
                      >
                        ‚ö° Who clicks Start goes first!
                      </Typography>
                    </Box>
                  </Box>
                </>
              </Box>
            ) : (
              // Game is playing - show board normally
              <Box sx={{ width: '100%', display: 'flex', justifyContent: 'center', position: 'relative' }}>
              <GameBoard />
              </Box>
            )}
          </Box>
        </Box>

        {/* Right Sidebar - Players Info & Score - Fixed */}
        <Box
          sx={{
            display: { xs: 'none', lg: 'flex' },
            flexDirection: 'column',
            gap: 2,
            position: 'fixed',
            right: { lg: 24 },
            top: { lg: 24 },
            width: { lg: '280px' },
            height: { lg: 'calc(100vh - 48px)' },
            maxHeight: { lg: 'calc(100vh - 48px)' },
            overflowY: 'auto',
            zIndex: 10,
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              background: 'rgba(126, 200, 227, 0.05)',
              borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              background: 'rgba(126, 200, 227, 0.2)',
              borderRadius: '3px',
              '&:hover': {
                background: 'rgba(126, 200, 227, 0.3)',
              },
            },
          }}
        >
          <Box
            sx={{
              p: 2.5,
              borderRadius: 3,
              bgcolor: '#ffffff',
              border: '2px solid transparent',
              backgroundImage: 'linear-gradient(#ffffff, #ffffff), linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
              backgroundOrigin: 'border-box',
              backgroundClip: 'padding-box, border-box',
              boxShadow: '0 4px 16px rgba(126, 200, 227, 0.12)',
            }}
          >
            <Typography
              variant="subtitle1"
              sx={{
                fontWeight: 700,
                mb: 2.5,
                color: '#2c3e50',
                fontSize: '0.95rem',
                textTransform: 'uppercase',
                letterSpacing: '0.5px',
                textAlign: 'center',
              }}
            >
              üë• Players & Score
            </Typography>
            <Box
              sx={{
                display: 'flex',
                flexDirection: 'column',
                gap: 2.5,
              }}
            >
              {players.map((player) => {
                const isCurrentTurn = game.gameStatus === 'playing' && game.currentPlayer === player.playerNumber;
                const isPlayer1 = player.playerNumber === 1;
                
                return (
                  <Box
                    key={player.playerNumber}
                    sx={{
                      p: 2,
                      borderRadius: 2,
                      bgcolor: isPlayer1 
                        ? 'rgba(126, 200, 227, 0.08)' 
                        : 'rgba(168, 230, 207, 0.08)',
                      border: isCurrentTurn
                        ? `2px solid ${isPlayer1 ? '#7ec8e3' : '#a8e6cf'}`
                        : isPlayer1
                        ? '1px solid rgba(126, 200, 227, 0.2)'
                        : '1px solid rgba(168, 230, 207, 0.2)',
                      textAlign: 'center',
                      position: 'relative',
                      boxShadow: isCurrentTurn 
                        ? `0 4px 16px ${isPlayer1 ? 'rgba(126, 200, 227, 0.3)' : 'rgba(168, 230, 207, 0.3)'}`
                        : 'none',
                      transform: isCurrentTurn ? 'scale(1.02)' : 'scale(1)',
                      transition: 'all 0.3s ease',
                      animation: isCurrentTurn ? 'pulse 2s ease-in-out infinite' : 'none',
                      '@keyframes pulse': {
                        '0%, 100%': {
                          boxShadow: isCurrentTurn 
                            ? `0 4px 16px ${isPlayer1 ? 'rgba(126, 200, 227, 0.3)' : 'rgba(168, 230, 207, 0.3)'}`
                            : 'none',
                        },
                        '50%': {
                          boxShadow: isCurrentTurn 
                            ? `0 6px 24px ${isPlayer1 ? 'rgba(126, 200, 227, 0.5)' : 'rgba(168, 230, 207, 0.5)'}`
                            : 'none',
                        },
                      },
                    }}
                  >
                    <Typography
                      variant="body2"
                      sx={{
                        color: '#5a6a7a',
                        fontWeight: 600,
                        display: 'block',
                        mb: 1,
                        fontSize: '0.8rem',
                      }}
                    >
                      Player {player.playerNumber}
                      {myPlayerNumber === player.playerNumber && ' üë§ (You)'}
                    </Typography>
                    <Typography
                      variant="body1"
                      sx={{
                        color: isCurrentTurn ? (isPlayer1 ? '#7ec8e3' : '#a8e6cf') : '#2c3e50',
                        fontWeight: isCurrentTurn ? 700 : 600,
                        display: 'block',
                        mb: 1.5,
                        fontSize: isCurrentTurn ? '1rem' : '0.9rem',
                        wordBreak: 'break-word',
                        transition: 'all 0.3s ease',
                      }}
                    >
                      {isCurrentTurn && 'üéØ '}
                      {player.username}
                      {player.isGuest && ' (Guest)'}
                      {isCurrentTurn && myPlayerNumber === player.playerNumber && ' - Your Turn!'}
                      {isCurrentTurn && myPlayerNumber !== player.playerNumber && ' - Their Turn'}
                    </Typography>
                    <Typography
                      variant="h4"
                      sx={{
                        fontWeight: 700,
                        color: isPlayer1 ? '#7ec8e3' : '#a8e6cf',
                        fontSize: '2rem',
                      }}
                    >
                      {isPlayer1 ? game.score.player1 : game.score.player2}
                    </Typography>
                  </Box>
                );
              })}
            </Box>
          </Box>
        </Box>
      </Box>
    </>
  );
};

export default GameRoomPage;
</file>

<file path="frontend/src/pages/HomePage.tsx">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Box, 
  Container, 
  Typography, 
  Button, 
  Paper, 
  Select, 
  MenuItem, 
  FormControl, 
  InputLabel, 
  TextField, 
  CircularProgress, 
  Chip,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  useTheme,
  useMediaQuery,
  IconButton,
  Fade,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import PersonIcon from '@mui/icons-material/Person';
import LeaderboardIcon from '@mui/icons-material/Leaderboard';
import LoginIcon from '@mui/icons-material/Login';
import HistoryIcon from '@mui/icons-material/History';
import { useNavigate, Link } from 'react-router-dom';
import GameCard from '../components/GameCard/GameCard';
import { gameApi } from '../services/api';
import { useAuth } from '../contexts/AuthContext';
import { BOARD_SIZES, DEFAULT_BOARD_SIZE } from '../utils/constants';
import { validateRoomCode, formatRoomCode } from '../utils/roomCode';
import HistoryModal from '../components/HistoryModal/HistoryModal';
import { socketService } from '../services/socketService';
import { logger } from '../utils/logger';

interface WaitingGame {
  _id: string;
  roomId: string;
  roomCode: string;
  boardSize: number;
  gameStatus: string;
  displayStatus?: 'waiting' | 'ready' | 'playing';
  statusLabel?: string;
  canJoin?: boolean;
  hasPlayer1: boolean;
  hasPlayer2: boolean;
  playerCount?: number;
  player1Username: string | null;
  createdAt: string;
}

interface GameItem {
  id: string;
  name: string;
  icon: string;
  description: string;
  available: boolean;
  color: string;
}

const GAMES: GameItem[] = [
  {
    id: 'caro',
    name: 'Caro',
    icon: 'üéØ',
    description: 'Classic strategy game',
    available: true,
    color: '#7ec8e3',
  },
  // Future games will be added here
];

const HomePage: React.FC = () => {
  const navigate = useNavigate();
  const { isAuthenticated, user, logout } = useAuth();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [selectedGame, setSelectedGame] = useState<string>('caro');
  const [boardSize, setBoardSize] = useState<number>(DEFAULT_BOARD_SIZE);
  const [blockTwoEnds, setBlockTwoEnds] = useState(false);
  const [joinRoomCode, setJoinRoomCode] = useState('');
  const [joinError, setJoinError] = useState('');
  const [joinLoading, setJoinLoading] = useState(false);
  const [waitingGames, setWaitingGames] = useState<WaitingGame[]>([]);
  const [loadingGames, setLoadingGames] = useState(true);
  const [joiningGameId, setJoiningGameId] = useState<string | null>(null);
  const [sidebarOpen, setSidebarOpen] = useState(!isMobile);
  const [historyModalOpen, setHistoryModalOpen] = useState(false);

  // Track mounted games to only animate new ones
  const mountedGamesRef = useRef<Set<string>>(new Set());
  const updateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Smart merge function - ch·ªâ update ph·∫ßn thay ƒë·ªïi, kh√¥ng replace to√†n b·ªô array
  const smartMergeGames = useCallback((newGames: WaitingGame[], currentGames: WaitingGame[]): WaitingGame[] => {
    const gameMap = new Map<string, WaitingGame>();
    
    // Add all current games to map
    currentGames.forEach(game => {
      gameMap.set(game.roomId, game);
    });
    
    // Track which games are new (for animation)
    const newGameIds = new Set<string>();
    
    // Update or add new games
    newGames.forEach(newGame => {
      const existing = gameMap.get(newGame.roomId);
      if (existing) {
        // Only update if something actually changed
        const hasChanged = 
          existing.gameStatus !== newGame.gameStatus ||
          existing.displayStatus !== newGame.displayStatus ||
          existing.statusLabel !== newGame.statusLabel ||
          existing.playerCount !== newGame.playerCount ||
          existing.canJoin !== newGame.canJoin;
        
        if (hasChanged) {
          gameMap.set(newGame.roomId, newGame);
        }
      } else {
        // New game - add it
        gameMap.set(newGame.roomId, newGame);
        newGameIds.add(newGame.roomId);
      }
    });
    
    // Remove games that no longer exist
    const currentRoomIds = new Set(currentGames.map(g => g.roomId));
    const newRoomIds = new Set(newGames.map(g => g.roomId));
    newRoomIds.forEach(roomId => {
      if (!currentRoomIds.has(roomId)) {
        mountedGamesRef.current.delete(roomId);
      }
    });
    
    // Mark new games as mounted
    newGameIds.forEach(roomId => {
      mountedGamesRef.current.add(roomId);
    });
    
    // Sort by createdAt (newest first)
    return Array.from(gameMap.values()).sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }, []);

  const handleCreateGame = async (): Promise<void> => {
    try {
      logger.log('[HomePage] Creating game with:', { boardSize, blockTwoEnds });
      const game = await gameApi.create(boardSize, {
        blockTwoEnds,
        allowUndo: true,
        maxUndoPerGame: 3,
        timeLimit: null,
      });

      logger.log('[HomePage] Game created successfully:', game.roomId);
      navigate(`/game/${game.roomId}`);
    } catch (error: any) {
      logger.error('[HomePage] Failed to create game:', error);
      logger.error('[HomePage] Error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
        stack: error.stack
      });
      const errorMessage = error.response?.data?.message || error.message || 'Failed to create game. Please try again.';
      alert(`Failed to create game: ${errorMessage}`);
    }
  };

  const handleJoinGame = async (): Promise<void> => {
    setJoinError('');
    
    const formattedCode = formatRoomCode(joinRoomCode);
    if (!validateRoomCode(formattedCode)) {
      setJoinError('Room code must be 6 characters (A-Z, 0-9)');
      return;
    }

    setJoinLoading(true);
    try {
      const game = await gameApi.getGameByCode(formattedCode);
      
      const canJoin = game.gameStatus === 'waiting' || 
                     (game.gameStatus === 'playing' && (!game.player2 && !game.player2GuestId));

      if (!canJoin && game.gameStatus !== 'waiting') {
        setJoinError('This game is already full or finished');
        setJoinLoading(false);
        return;
      }

      await gameApi.joinGame(game.roomId);
      navigate(`/game/${game.roomId}`);
    } catch (err: any) {
      setJoinError(err.response?.data?.message || 'Game not found. Please check the room code.');
      setJoinLoading(false);
    }
  };

  const handleJoinCodeChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
    setJoinRoomCode(value);
    setJoinError('');
  };

  const loadWaitingGames = useCallback(async (silent: boolean = false): Promise<void> => {
    try {
      if (!silent) {
        setLoadingGames(true);
      }
      const games = await gameApi.getWaitingGames();
      
      // Use smart merge instead of direct set
      setWaitingGames(prev => smartMergeGames(games, prev));
    } catch (error) {
      logger.error('Failed to load waiting games:', error);
    } finally {
      if (!silent) {
        setLoadingGames(false);
      }
    }
  }, [smartMergeGames]);

  useEffect(() => {
    // Initial load
    loadWaitingGames();
    
    // Fallback interval - tƒÉng l√™n 30s (ch·ªâ d√πng khi socket kh√¥ng ho·∫°t ƒë·ªông)
    const interval = setInterval(() => loadWaitingGames(true), 30000);
    
    // Socket.IO listeners for real-time updates
    const socket = socketService.getSocket();
    // Capture ref value at effect start to avoid stale closure
    const currentTimeoutRef = updateTimeoutRef.current;
    
    if (socket) {
      const handleGameCreated = () => {
        logger.log('[HomePage] Game created event received');
        loadWaitingGames(true); // Silent update - kh√¥ng hi·ªÉn th·ªã loading
      };
      
      const handleGameStatusUpdated = () => {
        logger.log('[HomePage] Game status updated event received');
        loadWaitingGames(true); // Silent update
      };
      
      const handleGameDeleted = (data: { roomId: string }) => {
        logger.log('[HomePage] Game deleted event received:', data.roomId);
        // Remove game from list immediately without API call
        setWaitingGames(prev => {
          const filtered = prev.filter(game => game.roomId !== data.roomId);
          // Also remove from mounted games ref
          mountedGamesRef.current.delete(data.roomId);
          return filtered;
        });
      };
      
      socket.on('game-created', handleGameCreated);
      socket.on('game-status-updated', handleGameStatusUpdated);
      socket.on('game-deleted', handleGameDeleted);
      
      return () => {
        clearInterval(interval);
        if (currentTimeoutRef) {
          clearTimeout(currentTimeoutRef);
        }
        if (socket) {
          socket.off('game-created', handleGameCreated);
          socket.off('game-status-updated', handleGameStatusUpdated);
          socket.off('game-deleted', handleGameDeleted);
        }
      };
    }
    
    return () => {
      clearInterval(interval);
      if (currentTimeoutRef) {
        clearTimeout(currentTimeoutRef);
      }
    };
  }, [loadWaitingGames]);

  const handleQuickJoin = async (game: WaitingGame): Promise<void> => {
    setJoiningGameId(game.roomId);
    try {
      await gameApi.joinGame(game.roomId);
      navigate(`/game/${game.roomId}`);
    } catch (error: any) {
      logger.error('Failed to join game:', error);
      alert(error.response?.data?.message || 'Failed to join game');
      loadWaitingGames();
    } finally {
      setJoiningGameId(null);
    }
  };

  const drawerWidth = 280;
  const currentGame = GAMES.find(g => g.id === selectedGame);

  return (
    <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: '#f8fbff' }}>
      {/* Sidebar - Game Selection */}
      <Drawer
        variant={isMobile ? 'temporary' : 'permanent'}
        open={sidebarOpen}
        onClose={() => setSidebarOpen(false)}
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
            background: '#ffffff',
            borderRight: '1px solid rgba(126, 200, 227, 0.12)',
            boxShadow: 'none',
            position: 'fixed',
            top: 0,
            left: 0,
            height: '100vh',
            overflowY: 'auto',
            display: 'flex',
            flexDirection: 'column',
            '&::-webkit-scrollbar': {
              width: '6px',
            },
            '&::-webkit-scrollbar-track': {
              background: 'rgba(126, 200, 227, 0.05)',
              // borderRadius: '3px',
            },
            '&::-webkit-scrollbar-thumb': {
              background: 'rgba(126, 200, 227, 0.2)',
              // borderRadius: '3px',
              '&:hover': {
                background: 'rgba(126, 200, 227, 0.3)',
              },
            },
          },
        }}
      >
        <Box sx={{ p: 3, pb: 2.5, pt: 3.5 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 1 }}>
            <Box
              sx={{
                width: 44,
                height: 44,
                // borderRadius: 2.5,
                background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 4px 12px rgba(126, 200, 227, 0.25)',
              }}
            >
              <Typography sx={{ fontSize: '1.5rem' }}>üéÆ</Typography>
            </Box>
            <Box>
              <Typography
                variant="h6"
                sx={{
                  background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  backgroundClip: 'text',
                  fontWeight: 800,
                  fontSize: '1.15rem',
                  lineHeight: 1.2,
                  mb: 0.25,
                }}
              >
                Game Hub
              </Typography>
              <Typography variant="caption" sx={{ color: '#8a9ba8', fontSize: '0.75rem', fontWeight: 500 }}>
                Select a game
              </Typography>
            </Box>
          </Box>
        </Box>
        <Divider sx={{ borderColor: 'rgba(126, 200, 227, 0.12)', mx: 0 }} />
        <List sx={{ px: 2, py: 2 }}>
          {GAMES.map((game) => (
            <ListItem key={game.id} disablePadding sx={{ mb: 1 }}>
              <ListItemButton
                selected={selectedGame === game.id}
                onClick={() => setSelectedGame(game.id)}
                disabled={!game.available}
                sx={{
                  borderRadius: 2.5,
                  py: 1.75,
                  px: 2,
                  position: 'relative',
                  overflow: 'hidden',
                  '&::before': {
                    content: '""',
                    position: 'absolute',
                    left: 0,
                    top: 0,
                    bottom: 0,
                    width: '4px',
                    background: 'linear-gradient(180deg, #7ec8e3 0%, #a8e6cf 100%)',
                    opacity: selectedGame === game.id ? 1 : 0,
                    transition: 'opacity 0.3s ease',
                  },
                  '&.Mui-selected': {
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.12) 0%, rgba(168, 230, 207, 0.12) 100%)',
                    border: '1px solid rgba(126, 200, 227, 0.2)',
                    boxShadow: '0 4px 12px rgba(126, 200, 227, 0.15)',
                    '&:hover': {
                      background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.18) 0%, rgba(168, 230, 207, 0.18) 100%)',
                    },
                  },
                  '&:hover': {
                    backgroundColor: 'rgba(126, 200, 227, 0.06)',
                  },
                  '&.Mui-disabled': {
                    opacity: 0.5,
                  },
                }}
              >
                <ListItemIcon sx={{ minWidth: 44 }}>
                  <Box
                    sx={{
                      width: 40,
                      height: 40,
                      borderRadius: 2,
                      background: selectedGame === game.id 
                        ? 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)'
                        : 'rgba(126, 200, 227, 0.1)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      transition: 'all 0.3s ease',
                    }}
                  >
                    <Typography sx={{ fontSize: '1.4rem' }}>{game.icon}</Typography>
                  </Box>
                </ListItemIcon>
                <ListItemText
                  primary={game.name}
                  secondary={game.description}
                  primaryTypographyProps={{
                    fontWeight: selectedGame === game.id ? 700 : 600,
                    fontSize: '0.95rem',
                    color: selectedGame === game.id ? '#2c3e50' : '#5a6a7a',
                  }}
                  secondaryTypographyProps={{
                    fontSize: '0.75rem',
                    color: '#8a9ba8',
                    mt: 0.25,
                  }}
                />
                {!game.available && (
                  <Chip
                    label="Soon"
                    size="small"
                    sx={{
                      height: 22,
                      fontSize: '0.65rem',
                      bgcolor: 'rgba(255, 170, 165, 0.15)',
                      color: '#ffaaa5',
                      fontWeight: 600,
                      border: '1px solid rgba(255, 170, 165, 0.3)',
                    }}
                  />
                )}
              </ListItemButton>
            </ListItem>
          ))}
        </List>
        
        {/* Auth Section */}
        <Divider sx={{ borderColor: 'rgba(126, 200, 227, 0.12)', mx: 0, mt: 'auto' }} />
        <Box sx={{ p: 2 }}>
          {isAuthenticated ? (
            <>
              <Box sx={{ mb: 2 }}>
                <Box
                  sx={{
                    p: 2,
                    borderRadius: 2.5,
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.12) 0%, rgba(168, 230, 207, 0.12) 100%)',
                    border: '1px solid rgba(126, 200, 227, 0.2)',
                    mb: 1.5,
                  }}
                >
                  <Typography
                    variant="body2"
                    sx={{
                      color: '#5a6a7a',
                      fontWeight: 600,
                      fontSize: '0.75rem',
                      mb: 0.5,
                      textTransform: 'uppercase',
                      letterSpacing: '0.5px',
                    }}
                  >
                    üë§ Logged in as
                  </Typography>
                  <Typography
                    variant="body1"
                    sx={{
                      color: '#2c3e50',
                      fontWeight: 700,
                      fontSize: '0.95rem',
                      wordBreak: 'break-word',
                    }}
                  >
                    {user?.username || 'User'}
                  </Typography>
                </Box>
              </Box>
              <Button
                component={Link}
                to="/profile"
                fullWidth
                startIcon={<PersonIcon />}
                sx={{
                  mb: 1.5,
                  py: 1.5,
                  borderRadius: 2.5,
                  textTransform: 'none',
                  fontWeight: 600,
                  fontSize: '0.9rem',
                  background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.1) 0%, rgba(168, 230, 207, 0.1) 100%)',
                  border: '1px solid rgba(126, 200, 227, 0.3)',
                  color: '#2c3e50',
                  '&:hover': {
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.2) 0%, rgba(168, 230, 207, 0.2) 100%)',
                    borderColor: 'rgba(126, 200, 227, 0.5)',
                  },
                }}
              >
                Profile
              </Button>
              <Button
                component={Link}
                to="/leaderboard"
                fullWidth
                startIcon={<LeaderboardIcon />}
                sx={{
                  mb: 1.5,
                  py: 1.5,
                  borderRadius: 2.5,
                  textTransform: 'none',
                  fontWeight: 600,
                  fontSize: '0.9rem',
                  background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.1) 0%, rgba(168, 230, 207, 0.1) 100%)',
                  border: '1px solid rgba(126, 200, 227, 0.3)',
                  color: '#2c3e50',
                  '&:hover': {
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.2) 0%, rgba(168, 230, 207, 0.2) 100%)',
                    borderColor: 'rgba(126, 200, 227, 0.5)',
                  },
                }}
              >
                Leaderboard
              </Button>
              <Button
                onClick={() => setHistoryModalOpen(true)}
                fullWidth
                startIcon={<HistoryIcon />}
                sx={{
                  mb: 1.5,
                  py: 1.5,
                  borderRadius: 2.5,
                  textTransform: 'none',
                  fontWeight: 600,
                  fontSize: '0.9rem',
                  background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.1) 0%, rgba(168, 230, 207, 0.1) 100%)',
                  border: '1px solid rgba(126, 200, 227, 0.3)',
                  color: '#2c3e50',
                  '&:hover': {
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.2) 0%, rgba(168, 230, 207, 0.2) 100%)',
                    borderColor: 'rgba(126, 200, 227, 0.5)',
                  },
                }}
              >
                History
              </Button>
              <Button
                onClick={logout}
                fullWidth
                sx={{
                  py: 1.5,
                  borderRadius: 2.5,
                  textTransform: 'none',
                  fontWeight: 600,
                  fontSize: '0.9rem',
                  color: '#ffaaa5',
                  border: '1px solid rgba(255, 170, 165, 0.3)',
                  '&:hover': {
                    background: 'rgba(255, 170, 165, 0.1)',
                    borderColor: 'rgba(255, 170, 165, 0.5)',
                  },
                }}
              >
                Logout
              </Button>
            </>
          ) : (
            <>
              <Button
                onClick={() => setHistoryModalOpen(true)}
                fullWidth
                startIcon={<HistoryIcon />}
                sx={{
                  mb: 1.5,
                  py: 1.5,
                  borderRadius: 2.5,
                  textTransform: 'none',
                  fontWeight: 600,
                  fontSize: '0.9rem',
                  background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.1) 0%, rgba(168, 230, 207, 0.1) 100%)',
                  border: '1px solid rgba(126, 200, 227, 0.3)',
                  color: '#2c3e50',
                  '&:hover': {
                    background: 'linear-gradient(135deg, rgba(126, 200, 227, 0.2) 0%, rgba(168, 230, 207, 0.2) 100%)',
                    borderColor: 'rgba(126, 200, 227, 0.5)',
                  },
                }}
              >
                History
              </Button>
            <Button
              component={Link}
              to="/login"
              fullWidth
              startIcon={<LoginIcon />}
              sx={{
                py: 1.75,
                borderRadius: 2.5,
                textTransform: 'none',
                fontWeight: 700,
                fontSize: '0.95rem',
                background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                color: '#ffffff',
                boxShadow: '0 4px 12px rgba(126, 200, 227, 0.3)',
                '&:hover': {
                  background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
                  boxShadow: '0 6px 16px rgba(126, 200, 227, 0.4)',
                },
              }}
            >
              Login / Register
            </Button>
            </>
          )}
        </Box>
      </Drawer>

      {/* Main Content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          width: { md: `calc(100% - ${drawerWidth}px)` },
          display: 'flex',
          flexDirection: 'column',
          minHeight: '100vh',
          ml: { md: 0 }, // Ensure no margin overlap
        }}
      >
        {/* Mobile Menu Button */}
        {isMobile && (
          <Box
            sx={{
              position: 'fixed',
              top: 16,
              left: 16,
              zIndex: (theme) => theme.zIndex.drawer + 1,
            }}
          >
            <IconButton
              onClick={() => setSidebarOpen(true)}
              sx={{
                width: 48,
                height: 48,
                background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                color: '#ffffff',
                boxShadow: '0 4px 12px rgba(126, 200, 227, 0.3)',
                '&:hover': {
                  background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
                  boxShadow: '0 6px 16px rgba(126, 200, 227, 0.4)',
                },
              }}
            >
              <MenuIcon />
            </IconButton>
          </Box>
        )}

        {/* Page Content */}
        <Box sx={{ flex: 1, background: 'linear-gradient(180deg, #f8fbff 0%, #ffffff 50%, #f0f9ff 100%)' }}>
          <Container maxWidth="xl" sx={{ py: { xs: 4, md: 5 }, px: { xs: 2, md: 3 } }}>
            {/* Hero Section */}
            <Fade in timeout={600}>
              <Box sx={{ textAlign: 'center', mb: { xs: 5, md: 6 } }}>
                <Box
                  sx={{
                    display: 'inline-flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: 80,
                    height: 80,
                    borderRadius: 4,
                    background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                    boxShadow: '0 8px 24px rgba(126, 200, 227, 0.3)',
                    mb: 2,
                  }}
                >
                  <Typography sx={{ fontSize: '3rem' }}>{currentGame?.icon}</Typography>
                </Box>
                <Typography 
                  variant="h2" 
                  sx={{
                    background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    backgroundClip: 'text',
                    fontWeight: 900,
                    mb: 1.5,
                    fontSize: { xs: '2.25rem', sm: '3rem', md: '3.5rem' },
                    letterSpacing: '-1px',
                    lineHeight: 1.1,
                  }}
                >
                  {currentGame?.name} Game
                </Typography>
                <Typography 
                  variant="h6" 
                  sx={{ 
                    color: '#5a6a7a', 
                    fontWeight: 400, 
                    fontSize: { xs: '1rem', md: '1.15rem' },
                    maxWidth: '650px',
                    mx: 'auto',
                    lineHeight: 1.7,
                  }}
                >
                  Challenge your friends to an exciting game of strategy and skill
                </Typography>
              </Box>
            </Fade>

            {/* Action Cards */}
            <Box sx={{ 
              display: 'grid', 
              gridTemplateColumns: { xs: '1fr', lg: '1fr 1fr' }, 
              gap: { xs: 3, md: 4 },
              mb: 6,
              maxWidth: '1200px',
              mx: 'auto',
            }}>
              {/* Create Game Card */}
              <Fade in timeout={800}>
                <Paper 
                  elevation={0}
                  sx={{ 
                    p: { xs: 3.5, md: 4.5 },
                    background: 'rgba(255, 255, 255, 0.8)',
                    backdropFilter: 'blur(8px)',
                    WebkitBackdropFilter: 'blur(8px)',
                    willChange: 'transform',
                    border: '1px solid rgba(126, 200, 227, 0.2)',
                    borderRadius: 4,
                    position: 'relative',
                    overflow: 'hidden',
                    boxShadow: '0 8px 32px rgba(126, 200, 227, 0.12)',
                    transition: 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
                    '&:hover': {
                      boxShadow: '0 16px 48px rgba(126, 200, 227, 0.2)',
                    },
                    '&::before': {
                      content: '""',
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      right: 0,
                      height: '5px',
                      background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                      borderRadius: '16px 16px 0 0',
                    },
                  }}
                >
                  <Box sx={{ mb: 3.5 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 1 }}>
                      <Box
                        sx={{
                          width: 48,
                          height: 48,
                          borderRadius: 2.5,
                          background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          boxShadow: '0 4px 12px rgba(126, 200, 227, 0.3)',
                        }}
                      >
                        <Typography sx={{ fontSize: '1.5rem' }}>‚ú®</Typography>
                      </Box>
                      <Box>
                        <Typography 
                          variant="h5" 
                          sx={{ 
                            color: '#2c3e50', 
                            fontWeight: 700, 
                            fontSize: { xs: '1.4rem', md: '1.6rem' },
                            mb: 0.25,
                          }}
                        >
                          Create New Game
                        </Typography>
                        <Typography variant="body2" sx={{ color: '#5a6a7a', fontSize: '0.9rem' }}>
                          Set up your game board and invite friends
                        </Typography>
                      </Box>
                    </Box>
                  </Box>

                  <FormControl fullWidth sx={{ mb: 3 }}>
                    <InputLabel sx={{ fontWeight: 500, color: '#5a6a7a' }}>Board Size</InputLabel>
                    <Select
                      value={boardSize}
                      onChange={(e) => setBoardSize(Number(e.target.value))}
                      label="Board Size"
                      sx={{ 
                        borderRadius: 2.5,
                        bgcolor: 'rgba(126, 200, 227, 0.05)',
                      }}
                    >
                      {BOARD_SIZES.map((size) => (
                        <MenuItem key={size} value={size}>
                          {size}x{size}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>

                  <Box sx={{ mb: 3 }}>
                    <Button
                      variant={blockTwoEnds ? 'contained' : 'outlined'}
                      onClick={() => setBlockTwoEnds(!blockTwoEnds)}
                      fullWidth
                      sx={{ 
                        py: 1.5,
                        borderRadius: 2.5,
                        textTransform: 'none',
                        fontWeight: 600,
                        fontSize: '0.95rem',
                        // Ensure consistent spacing to prevent layout shift
                        boxSizing: 'border-box',
                        minHeight: '48px', // Fixed height to prevent layout shift
                        // For contained variant, no border at all
                        ...(blockTwoEnds && {
                          border: 'none',
                          borderWidth: 0,
                          '&:hover': {
                            border: 'none',
                            borderWidth: 0,
                          },
                          '&:focus': {
                            border: 'none',
                            borderWidth: 0,
                          },
                          '&:focus-visible': {
                            outline: '2px solid rgba(126, 200, 227, 0.5)',
                            outlineOffset: '2px',
                          },
                        }),
                        // For outlined variant, border is visible
                        ...(!blockTwoEnds && {
                          borderWidth: 2,
                          borderColor: '#7ec8e3',
                          borderStyle: 'solid',
                          '&:hover': {
                            borderColor: '#5ba8c7',
                            borderWidth: 2,
                            borderStyle: 'solid',
                          },
                          '&:focus': {
                            borderWidth: 2,
                            borderStyle: 'solid',
                          },
                        }),
                      }}
                    >
                      Block Two Ends: {blockTwoEnds ? 'ON' : 'OFF'}
                    </Button>
                  </Box>

                  <Button
                    variant="contained"
                    size="large"
                    fullWidth
                    onClick={handleCreateGame}
                    sx={{ 
                      py: 2,
                      borderRadius: 2.5,
                      textTransform: 'none',
                      fontSize: '1.05rem',
                      fontWeight: 700,
                      background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                      boxShadow: '0 6px 20px rgba(126, 200, 227, 0.4)',
                      '&:hover': {
                        background: 'linear-gradient(135deg, #5ba8c7 0%, #88d6b7 100%)',
                        boxShadow: '0 8px 28px rgba(126, 200, 227, 0.5)',
                      },
                    }}
                  >
                    üöÄ Create Game
                  </Button>
                </Paper>
              </Fade>

              {/* Join Game Card */}
              <Fade in timeout={1000}>
                <Paper 
                  elevation={0}
                  sx={{ 
                    p: { xs: 3.5, md: 4.5 },
                    background: 'rgba(255, 255, 255, 0.8)',
                    backdropFilter: 'blur(8px)',
                    WebkitBackdropFilter: 'blur(8px)',
                    willChange: 'transform',
                    border: '1px solid rgba(168, 230, 207, 0.2)',
                    borderRadius: 4,
                    position: 'relative',
                    overflow: 'hidden',
                    boxShadow: '0 8px 32px rgba(168, 230, 207, 0.12)',
                    transition: 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
                    '&:hover': {
                      boxShadow: '0 16px 48px rgba(168, 230, 207, 0.2)',
                    },
                    '&::before': {
                      content: '""',
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      right: 0,
                      height: '5px',
                      background: 'linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
                      borderRadius: '16px 16px 0 0',
                    },
                  }}
                >
                  <Box sx={{ mb: 3.5 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, mb: 1 }}>
                      <Box
                        sx={{
                          width: 48,
                          height: 48,
                          borderRadius: 2.5,
                          background: 'linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          boxShadow: '0 4px 12px rgba(168, 230, 207, 0.3)',
                        }}
                      >
                        <Typography sx={{ fontSize: '1.5rem' }}>üéØ</Typography>
                      </Box>
                      <Box>
                        <Typography 
                          variant="h5" 
                          sx={{ 
                            color: '#2c3e50', 
                            fontWeight: 700, 
                            fontSize: { xs: '1.4rem', md: '1.6rem' },
                            mb: 0.25,
                          }}
                        >
                          Join Game
                        </Typography>
                        <Typography variant="body2" sx={{ color: '#5a6a7a', fontSize: '0.9rem' }}>
                          Enter a room code to join an existing game
                        </Typography>
                      </Box>
                    </Box>
                  </Box>
                  <TextField
                    fullWidth
                    label="Room Code"
                    value={joinRoomCode}
                    onChange={handleJoinCodeChange}
                    placeholder="ABC123"
                    inputProps={{
                      maxLength: 6,
                      style: {
                        textAlign: 'center',
                        fontSize: '26px',
                        fontFamily: 'monospace',
                        letterSpacing: 5,
                        fontWeight: 'bold',
                      },
                    }}
                    InputLabelProps={{
                      shrink: true,
                    }}
                    sx={{ 
                      mb: 2.5,
                      '& .MuiOutlinedInput-root': {
                        borderRadius: 2.5,
                        bgcolor: 'rgba(168, 230, 207, 0.05)',
                        '& fieldset': {
                          borderColor: 'rgba(168, 230, 207, 0.3)',
                        },
                        '&:hover fieldset': {
                          borderColor: 'rgba(168, 230, 207, 0.5)',
                        },
                        '&.Mui-focused fieldset': {
                          borderColor: '#a8e6cf',
                          borderWidth: 2,
                        },
                      },
                      '& .MuiInputLabel-root': {
                        transform: 'translate(14px, 20px) scale(1)',
                        '&.MuiInputLabel-shrink': {
                          transform: 'translate(14px, -9px) scale(0.75)',
                        },
                      },
                      '& .MuiOutlinedInput-input': {
                        padding: '18px 14px',
                      },
                    }}
                  />
                  {joinError && (
                    <Box sx={{ 
                      mb: 2.5, 
                      p: 2, 
                      borderRadius: 2.5, 
                      bgcolor: 'rgba(255, 170, 165, 0.1)',
                      border: '1px solid rgba(255, 170, 165, 0.3)',
                    }}>
                      <Typography color="error" variant="body2" sx={{ textAlign: 'center', fontWeight: 500 }}>
                        {joinError}
                      </Typography>
                    </Box>
                  )}
                  <Button
                    variant="contained"
                    size="large"
                    fullWidth
                    onClick={handleJoinGame}
                    disabled={joinLoading || joinRoomCode.length !== 6}
                    sx={{ 
                      mb: 1.5,
                      py: 2,
                      borderRadius: 2.5,
                      textTransform: 'none',
                      fontSize: '1.05rem',
                      fontWeight: 700,
                      background: 'linear-gradient(135deg, #a8e6cf 0%, #7ec8e3 100%)',
                      boxShadow: '0 6px 20px rgba(168, 230, 207, 0.4)',
                      '&:hover': {
                        background: 'linear-gradient(135deg, #88d6b7 0%, #5ba8c7 100%)',
                        boxShadow: '0 8px 28px rgba(168, 230, 207, 0.5)',
                      },
                      '&:disabled': {
                        background: 'linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%)',
                        color: '#9e9e9e',
                        boxShadow: 'none',
                        cursor: 'not-allowed',
                        opacity: 0.6,
                      },
                    }}
                  >
                    {joinLoading ? (
                      <>
                        <CircularProgress size={20} sx={{ mr: 1.5, color: '#ffffff' }} />
                        Joining...
                      </>
                    ) : (
                      'üéÆ Join Game'
                    )}
                  </Button>
                  <Button
                    component={Link}
                    to="/join"
                    variant="outlined"
                    fullWidth
                    sx={{ 
                      borderRadius: 2.5,
                      textTransform: 'none',
                      py: 1.5,
                      borderColor: 'rgba(126, 200, 227, 0.3)',
                      color: '#5a6a7a',
                      '&:hover': {
                        borderColor: '#7ec8e3',
                        bgcolor: 'rgba(126, 200, 227, 0.05)',
                      },
                    }}
                  >
                    Or use join page
                  </Button>
                </Paper>
              </Fade>
            </Box>

            {/* Waiting Games Section */}
            <Box sx={{ maxWidth: '1200px', mx: 'auto' }}>
              <Fade in timeout={1200}>
                <Box sx={{ mb: 4, textAlign: 'center' }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1.5, mb: 1 }}>
                    <Typography
                      component="span"
                      sx={{
                        fontSize: { xs: '1.5rem', md: '1.75rem' },
                        lineHeight: 1,
                      }}
                    >
                      üéÆ
                    </Typography>
                    <Typography 
                      variant="h4" 
                      sx={{
                        background: 'linear-gradient(135deg, #7ec8e3 0%, #a8e6cf 100%)',
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        backgroundClip: 'text',
                        fontWeight: 800,
                        fontSize: { xs: '1.5rem', md: '2rem' },
                        m: 0,
                      }}
                    >
                      Available Games
                    </Typography>
                  </Box>
                  <Typography variant="body1" sx={{ color: '#5a6a7a', fontSize: '0.95rem', fontWeight: 500 }}>
                    Join a game that's waiting for players
                  </Typography>
                </Box>
              </Fade>

              {loadingGames ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', py: 6 }}>
                  <CircularProgress sx={{ color: '#7ec8e3' }} />
                </Box>
              ) : waitingGames.length === 0 ? (
                <Fade in timeout={1400}>
                  <Paper
                    elevation={0}
                    sx={{
                      p: 5,
                      textAlign: 'center',
                      bgcolor: 'rgba(255, 255, 255, 0.6)',
                      backdropFilter: 'blur(8px)',
                    WebkitBackdropFilter: 'blur(8px)',
                    willChange: 'transform',
                      border: '1px solid rgba(126, 200, 227, 0.2)',
                      borderRadius: 4,
                      boxShadow: '0 8px 32px rgba(126, 200, 227, 0.1)',
                    }}
                  >
                    <Typography variant="body1" sx={{ color: '#5a6a7a', fontSize: '1rem' }}>
                      No games waiting for players at the moment. Create a new game to get started!
                    </Typography>
                  </Paper>
                </Fade>
              ) : (
                <Box
                  sx={{
                    display: 'grid',
                    gridTemplateColumns: { xs: '1fr', sm: 'repeat(2, 1fr)', md: 'repeat(3, 1fr)', lg: 'repeat(4, 1fr)' },
                    gap: 2.5,
                  }}
                >
                  {waitingGames.map((game) => {
                    const isNewGame = !mountedGamesRef.current.has(game.roomId);
                    return (
                      <GameCard
                        key={game.roomId}
                        game={game}
                        isNewGame={isNewGame}
                        joiningGameId={joiningGameId}
                        onJoin={handleQuickJoin}
                      />
                    );
                  })}
                </Box>
              )}
            </Box>
          </Container>
        </Box>
      </Box>

      {/* History Modal */}
      <HistoryModal open={historyModalOpen} onClose={() => setHistoryModalOpen(false)} />
    </Box>
  );
};

export default HomePage;
</file>

</files>
